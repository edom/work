#+TITLE: Making the only programming language we will ever need
#+DATE: 2018-07-22 02:45 +0700
#+PERMALINK: /plres0.html
#+OPTIONS: ^:nil
* TODO <2018-09-15> Make the programming language
- cite:DBLP:conf/popl/CookHC90
- cite:cartwright2013inheritance
* TODO Compare programming language research journals and conferences
Which ones should we care about?
Which ones are the real deal?
** ICFP
** OOPSLA
** PLDI
** POPL
** PACM
** PACMPL
** DBLP vs Semantic Scholar?
https://dblp.uni-trier.de/
* TODO <2018-09-15> Find out how type systems may guarantee pointer safety
Is escape analysis the only way?
** TODO <2018-09-15> Study Sixten type system
** TODO <2018-09-15> Study Rust type system
See [[https://doc.rust-lang.org/reference/type-system.html][Rust type system reference]].
* Type systems
** What is a type? Understanding what a type is from how it is used
Mathematically, A type is a set whose membership is syntactically decidable.

Engineeringly, A type gives meaning to bit patterns.

A type encodes meaning into bit patterns.
    - For example, consider the bit pattern 11111111.
        - It means -1 as an int8.
        - It means 127 as an uint8.
    - Types help translate programs.

Type system helps machines help us.
We shouldn't focus on type systems.
We should focus on logic.
We should focus on making machines help us.
The question is not how to make a good type system.
The question is how to offload the job as much as possible from humans to machines.

A programming language is a formal system.
A type system is a formal system.
Therefore a type system is a formal system embedded in a bigger formal system that is a programming language.

Programming languages have semantics, even if it is implicit.

A type defines the memory layout (bit pattern) of its values.

A type constrains values and expressions.

A type determines what values a function can take/give.

There are also other uses of types.

The question is: What is a type?
What principles should we follow when we design a language?

- https://news.ycombinator.com/item?id=8045115
    - [[https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/][Dynamic Languages are Static Languages | Existential Type]]
** Church types and Curry types
- https://lispcast.com/church-vs-curry-types/
- [[https://www.reddit.com/r/programming/comments/2cavea/church_vs_curry_types_two_conflicting_perspectives/][Church vs Curry Types -- Two conflicting perspectives : programming]]
** Row polymorphism
Why is it called row polymorphism?
Where is the row?
See "Objects and Aspects: Row Polymorphism", Neel Krishnaswami [[https://www.cs.cmu.edu/~neelk/rows.pdf][pdf]]

In the following, the function =set_name_r=  is row-polymorphic.
The function =set_name_n= is not row-polymorphic.
#+BEGIN_SRC
type Person = { name : String; age : Int; };
type Company = { name : String; location : String; };

set_name_r : String -> {name:String; r;} -> {name:String; r;};
set_name_r new_name {name=n; r;} = {name=new_name; r;};

set_name_n : String -> {name:String;} -> {name:String;};
set_name_n new_name {name=n;} = {name=new_name;};

john : Person;
john = { name="John"; age = 20; }

joe : Person;
joe = set_name_r "Joe" john;

not_person : {name:String};
not_person = set_name_n "What" john;

abc = { name="ABC"; location="1 ABC Way"; };
def = set_name_r "DEF" abc;
#+END_SRC
Without row polymorphism, we would have to write set_name twice: once for each type.
*** Row polymorphism vs subtyping
https://cs.stackexchange.com/questions/53998/what-are-the-major-differences-between-row-polymorphism-and-subtyping
*** Row polymorphism vs structural subtyping
https://news.ycombinator.com/item?id=13047934
** what
- Liquid Haskell https://ucsd-progsys.github.io/liquidhaskell-blog/
- [[https://brianmckenna.org/blog/row_polymorphism_isnt_subtyping][Row Polymorphism Isn't Subtyping - BAM Weblog]]
- recursive types http://ecee.colorado.edu/~siek/ecen5013/spring10/lecture15.pdf
- http://tomasp.net/coeffects/
- 2008, article, "Church and Curry: Combining Intrinsic and Extrinsic Typing", Frank Pfenning https://www.cs.cmu.edu/~fp/papers/andrews08.pdf
- From Wadler home page
  - [[http://groups.inf.ed.ac.uk/abcd/][From Data Types to Session Types: A Basis for Concurrency and Distribution]]
- [[https://www.reddit.com/r/dependent_types/comments/8qig0u/vectors_are_records_too_pdf/][Vectors are records, too (pdf) : dependent_types]]
- https://wiki.haskell.org/Untypechecking is "converting from a type to a term".
- NOOL 2016 article "Static Typing Without Static Types — Typing Inheritance from the Bottom Up" [[http://www.it.uu.se/workshop/nool16/nool16-paper4.pdf][pdf]]
** Parametricity
- Every recursive type can be written as `mu a. F a` where F is the associated free functor?
    - Example: `List a = Fix (F a)` where `F a b = 1 + a * b`.
    - `Fix F = F (Fix F)` is the least fixed point of F.
- Why should we care about parametricity?
    - [[https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/][Parametricity: Money for Nothing and Theorems for Free - Bartosz Milewski's Programming Cafe]]
** Subtyping
A subtyping relation is an ordering of types.

So what? That is technically correct but that doesn't give any insights.

A subtype is an ordering that follows the Liskov substitution principle?

** Type-checking
- Every type checking algorithm is unification (logic programming).
    - If the programmer annotates a term, use that annotation.
    - If the a term is not annotated, annotate that term with a freshly generated variable.
    - Unify everything according to the typing rules.
    - See Algorithm W in [[https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system][WP:Hindley–Milner type system]].
** Algebraic subtyping?

- subtyping
    - algebraic subtyping
        - 2016, PhD thesis, "Algebraic subtyping", Stephen Dolan https://www.cl.cam.ac.uk/~sd601/thesis.pdf
        - "Polymorphism, subtyping and type inference in MLsub" http://www.cl.cam.ac.uk/~sd601/papers/mlsub-preprint.pdf
            - from http://lambda-the-ultimate.org/node/5393
                    - from https://contributors.scala-lang.org/t/algebraic-subtyping/577
- http://www.cl.cam.ac.uk/~sd601/papers/mlsub-preprint.pdf
- https://www.cl.cam.ac.uk/~sd601/thesis.pdf
- https://cs.stackexchange.com/questions/53998/what-are-the-major-differences-between-row-polymorphism-and-subtyping
- https://www.cl.cam.ac.uk/teaching/1415/L28/rows.pdf
- 2017, "Introduction to homotopy type theory", http://www.cs.nott.ac.uk/~psztxa/ss-types-17/notes-summer17.pdf
- http://www.cs.nott.ac.uk/~psztxa/ss-types-17/
- https://homotopytypetheory.org/book/
- https://en.wikipedia.org/wiki/Subtyping
- https://en.wikipedia.org/wiki/Circle-ellipse_problem
- What does "X is a Y" mean?
It means P(X) => P(Y) for every predicate P.
Liskov substitution principle.
Does it mean "X is a subclass of Y" or "X is an instance of Y"?
* References
bibliography:default
bibliographystyle:simple
