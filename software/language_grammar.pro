:- module(language_grammar, [
    grammar_kb1/2,
    grammar_kb2/2,
    grammar_analysis/2,
    analysis_reorder/2,
    analysis_kb1/2
]).
:- use_module('./map.pro').
:- use_module('./language_prolog.pro').
/** <module> grammar description language

A language that describes context-free languages.
*/

grammar_analysis(Rules,Rules0) :-
    findall(
        rule(Head,Input,Body3),
        (
            kb_rule(Rules,(Head:-Body)),
            analyze0(Body,Body0),
            gflatten(Body0,Body1),

            analyze1(Input,Body1,Body2),
            %Body1=Body2,

            analyze2(Rules,Body2,Body3),
            %Body2=Body3,

            true
        ),
        Rules0
    ).

        % Group conjunctions and disjunctions from trees into lists.
        analyze0((A,B),con([AA,BB])) :- !, analyze0(A,AA), analyze0(B,BB).
        analyze0((A;B),dis([AA,BB])) :- !, analyze0(A,AA), analyze0(B,BB).
        analyze0(A,match(A)) :- string(A), !.
        analyze0(A,call(A)) :- !.

        % Flatten conjunctions and disjunctions.
        gflatten(match(A),match(A)) :- !.
        gflatten(call(A),call(A)) :- !.
        gflatten(con(A),con(B)) :- !, gflattencon(A,B).
        gflatten(dis(A),dis(B)) :- !, gflattendis(A,B).
        gflatten(A,_) :- !, domain_error(_,A).

            gflattencon([],[]) :- !.
            gflattencon([con(A)|B],C) :- !, append(A,B,D), gflattencon(D,C).
            gflattencon([A|B],[D|E]) :- !, gflatten(A,D), gflattencon(B,E).

            gflattendis([],[]) :- !.
            gflattendis([dis(A)|B],C) :- !, append(A,B,D), gflattendis(D,C).
            gflattendis([A|B],[D|E]) :- !, gflatten(A,D), gflattendis(B,E).

        % Annotate with inputs.
        analyze1(I,match(A),match(I,A)) :- !.
        analyze1(I,call(A),call(I,A)) :- !.
        analyze1(I,con(A),con(I,J,B)) :- !, analyze1con(J,A,B).
        analyze1(I,dis(A),dis(I,B)) :- !, analyze1dis(I,A,B).

            analyze1con([],[],[]) :- !.
            % [string-inlining]
            % This optional optimization inlines string matching into the append/2 call generated by analyze_kb1/2.
            analyze1con([J|K],[match(A)|B],D) :- !, string_codes(A,J), analyze1con(K,B,D).
            analyze1con([J|K],[A|B],[C|D]) :- !, analyze1(J,A,C), analyze1con(K,B,D).

            analyze1dis(_,[],[]) :- !.
            analyze1dis(I,[A|B],[C|D]) :- !, analyze1(I,A,C), analyze1dis(I,B,D).

        % Annotate call/2 with orders.
        analyze2(G,match(I,A),match(I,A)) :- !.
        analyze2(G,call(I,A),call(O,I,A)) :- !, callorder(G,A,O).
        analyze2(G,con(I,J,A),con(I,J,B)) :- analyze2con(G,A,B).
        analyze2(G,dis(I,A),dis(I,B)) :- analyze2dis(G,A,B).

            analyze2con(_,[],[]) :- !.
            analyze2con(G,[A|B],[C|D]) :- !, analyze2(G,A,C), analyze2con(G,B,D).

            analyze2dis(_,[],[]) :- !.
            analyze2dis(G,[A|B],[C|D]) :- !, analyze2(G,A,C), analyze2dis(G,B,D).

            callorder(G,A,late) :- grammar_maycallself(G,A), !.
            callorder(_,_,early) :- !.

                /** grammar_maycallself(+Rules,+Head)

                True iff Head may call itself directly or indirectly.
                */
                grammar_maycallself(G,F) :- functor(F,N,A), functor(F0,N,A), kb_depend(G,F,F0).

            ordlt(late,early).

            ordmin(late).

            ordmax(early).

            ordmin(A,B,A) :- ordlt(A,B), !.
            ordmin(_,B,B) :- !.

            ordmax(A,B,B) :- ordlt(A,B), !.
            ordmax(A,_,A) :- !.

analysis_reorder(Rules,Rules0) :-
    findall(
        rule(Head,Input,Body0),
        (
            member(rule(Head,Input,Body), Rules),
            reorder(Body,Body0)
        ),
        Rules0
    ).

    reorder([],[]) :- !.
    reorder([A|B],[C|D]) :- !, reorder(A,C), reorder(B,D).
    reorder(match(I,A),match(I,A)) :- !.
    reorder(call(O,I,A),call(O,I,A)) :- !.
    reorder(con(I,J,A),con(I,J,C)) :- !, reordercon(A,B), reorder(B,C).
    reorder(dis(I,A),dis(I,B)) :- !, reorder(A,B).

        reordercon(List,Re) :- !, gpartition(List,Early,Late), append(Early,Late,Re).

            % gpartition(List,Early,Late)
            gpartition([],[],[]) :- !.
            gpartition([A|B],[A|C],D) :- getorder(A,early), !, gpartition(B,C,D).
            gpartition([A|B],C,[A|D]) :- getorder(A,late), !, gpartition(B,C,D).
            gpartition(A,_,_) :- !, domain_error(_,A).

                getorder(match(_,_),P) :- !, P = early.
                getorder(call(O,_,_),P) :- !, O=P.
                getorder(con(_,_,_),P) :- !, O=late.
                getorder(dis(_,_),P) :- !, O=late.
                getorder(A,_) :- !, domain_error(_,A).

analysis_kb1(A,K) :- map(An,Ru,grule_phorn1(An,Ru),A,K).

    grule_phorn1(rule(Head,Input,Body), P) :- !,
        P = (Head0:-Body0),
        functor_addargs(Head,[Input],Head0),
        gbody_pbody1(Body,Body0).
    grule_phorn1(A,_) :- !, domain_error(_,A).

        % This is called if the optional optimization [string-inlining] is skipped.
        gbody_pbody1(match(I,A),B) :- !, string_codes(A,C), B = (I=C).
        gbody_pbody1(call(_,I,A),B) :- !, functor_addargs(A,[I],B).
        gbody_pbody1(con(I,J,A),B) :- B = (#append(J,I), C), gbodycon(A,C).
        gbody_pbody1(dis(_,A),B) :- gbodydis(A,B).

            gbodycon([A],B) :- !, gbody_pbody1(A,B).
            gbodycon([A|B],(C,D)) :- !, gbody_pbody1(A,C), gbodycon(B,D).

            gbodydis([A],B) :- !, gbody_pbody1(A,B).
            gbodydis([A|B],(C;D)) :- !, gbody_pbody1(A,C), gbodydis(B,D).

/** grammar_kb1(+Grammar, -Rules)

Each grammar rule is translated to a Prolog rule of the same name with 1 additional parameter Input.

This works with left-recursive grammars.

This is a convenience predicate that chains these predicates:
    - grammar_analysis/2
    - analysis_reorder/2
    - analysis_kb1/2
*/
grammar_kb1(G,K) :-
    grammar_analysis(G,A),
    analysis_reorder(A,R),
    analysis_kb1(R,K).

/** grammar_kb2(+Grammar, -Rules)

Translate grammar description to difference-list knowledge base.

Each grammar rule is translated to a Prolog rule of the same name with 2 additional parameters Input and Rest.

Similar to definite-clause grammar (DCG).

This does not work with left-recursive grammars.
*/
grammar_kb2([],[]).
grammar_kb2([GA|GB],[PA|PB]) :- grammar_kb2(GA,PA), grammar_kb2(GB,PB).
grammar_kb2((GHead:-GBody), (PHead:-PBody)) :-
    ghead_phead(GHead,PHead,Input,Rest),
    gbody_pbody(GBody,PBody,Input,Rest).

    ghead_phead(G,P,I,R) :- functor_addargs(G,[I,R],P).

        functor_addargs(F0,Args,F1) :- F0=..F, append(F,Args,G), F1=..G.

    gbody_pbody(#G,P,_,_) :- !, P = #G.
    gbody_pbody((GA,GB),P,S0,S9) :- !, P=(PA,PB), gbody_pbody(GA,PA,S0,S4), gbody_pbody(GB,PB,S4,S9).
    gbody_pbody((GA;GB),P,S0,S9) :- !, P=(PA;PB), gbody_pbody(GA,PA,S0,S9), gbody_pbody(GB,PB,S0,S9).
    gbody_pbody((GA|GB),P,S0,S9) :- !, P=(PA;PB), gbody_pbody(GA,PA,S0,S9), gbody_pbody(GB,PB,S0,S9).
    gbody_pbody(G,P,S0,S9) :- string(G), !, string_codes(G,Codes), P = #append(Codes,S9,S0).
    gbody_pbody(G,P,S0,S9) :- functor_addargs(G,[S0,S9],P).
