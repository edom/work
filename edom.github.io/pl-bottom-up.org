#+TITLE: A programming language designed from the bottom up
#+DATE: 2019-11-04 04:00:00 +0700
#+PERMALINK: /pl-bottom-up.html
* Introduction
- Example of bottom-up language design and how each level reduces cognitive load:
  - Begin with machine code.
  - Provide mnemonics for instructions.
  - Provide the illusion of infinite custom-named registers and orthogonal operands.
  - Provide macros subroutines as extensible instructions.
  - Provide the illusion of infinite custom-named registers and orthogonal operands.
  - Provide macros and subroutines as extensible instructions.
  - Provide named locations.
  - Provide the illusion of infinite memory.
  - Abstract away processor registers.
  - Abstract away pointers.
  - Expression.
  - Infix expression syntax.
  - First-class functions.
  - The program itself is a procedural program that tells the interpreter what code to generate.
  - End up with something like Randall Hyde's High Level Assembly?
* Starting with assembly
We may begin from x86 assembly.

First we abstract away locations, registers, memory,
so that we can write something like this:
#+BEGIN_EXAMPLE
mov dword ptr [var_1], [var_2]
#+END_EXAMPLE

Macro Assembler (MASM)?
TASM, NASM, what?

There does not exist a computer with infinite memory.
Why do we pretend, with garbage collection, that the computer had infinite memory?
Because it simplifies most problems?

What is the problem with these:
High-Level Assembly,
typed assembly languages such as TALx86 \cite{crary1999talx86}[fn::<2019-11-04> https://www.cis.upenn.edu/~stevez/papers/MCGG99.pdf],
LLVM IR,
MSIL,
JVM bytecodes?

We can add a type system to assembly language to enforce constraints like these:
- "Add-integer" takes two integers.
- "Add-pointer" takes a pointer of alignment N and an integer that is an integral multiple of N.
- It is illegal to add two pointers.

For example, a type may be:
- =Integer N= where N is 1, 2, 4, or 8
- =Pointer A= where A is the alignment (1, 2, 4, or 8)

One difficulty is that the same register may sometimes contain an integer and sometimes contain a pointer.

We can "solve" that with Static Single Assignment (SSA) Form and automatic register allocation.

But perhaps the bigger issue is to abstract away the difference between processors;
why should we care if it is an Intel processor, a Motorola processor, a Symbolics Lisp machine, or something else?

Even though the machine does not know about subroutines,
we organize our programs into subroutines;
we find it more convenient to work with subroutines than to work with instructions.
We feel that the instructions are too finely-grained, unnecessarily detailed.
