#+TITLE: Programming language design
#+DATE: 2018-12-15 01:35 +0700
#+PERMALINK: /proglang.html
#+OPTIONS: ^:nil toc:nil
#+MATHJAX: yes
* Story?
I have been writing Java code for a few years now.
I always wonder whether there is a more concise way to write programs.

I have years of unfaithful on-and-off relationships with various languages,
such as Haskell, Prolog, and Racket.

Prolog and Racket sparks joy in me when I write programs in them.

I think everyone has grievances with all languages.

How is the magical ellipsis in =syntax-case= implemented?

How is Typed Racket implemented?

RacketCon has some interesting talks.

In English, we often invent new vocabularies, but we rarely invent new syntax.
English is a domain specific language whose domain is everyday human communication.
English can act as its own meta-language.
English contains a fragment of logic.

In a language, are we more concerned about expressing the problem or expressing the solution?

Scribble is better than Pandoc?
Alien technology, productivity multiplier?
But I feel that Racket is a bit slow?

Robby Findler impressively demonstrated[fn::Lambda Jam 2015 - Robby Findler - Racket: A Programming-Language Programming Language #YOWLambdaJam https://www.youtube.com/watch?v=hFlIl0Zo234]
Racket as a programming-language programming language.

Is Scribble or Pollen
 [fn::https://docs.racket-lang.org/pollen/]
 [fn::(fourth RacketCon): Matthew Butterick — Like a Blind Squirrel in a Ferrari https://www.youtube.com/watch?v=IMz09jYOgoc&feature=youtu.be]
the authoring system I have been looking for?
Does my journey end where Matthew Butterick's journey ends?
Patoline?[fn::http://patoline.org/]

It is regrettable that we have XML while S-expressions suffice, if not better.

I love Erik Meijer's crazy talk[fn::One Hacker Way Rational alternative of Agile - Erik Meijer https://www.youtube.com/watch?v=2u0sNRO-QKQ]:
- 24:31 tenth man, Israeli intelligence, devil's advocate
- 26:54 you should never stick around in a company for more than three years (unless you own it, perhaps)
- 43:50 we pay more for plumbers than we pay more for software; it's crazy

I have become pragmatic.
I see a class as a way to avoid repeating the first parameter of a collection of related functions.
That a class corresponds to an entity in the real world is accidental.
The essence of a class is to factor out a group of method parameters that often occur together.

I think Python's class is a stupid workaround:
What is the point of having classes and instance methods if you have to type "self" as the first argument of the parameter list?
The point of languages is to express ideas concisely.
Class-based programming only works if the first "self" argument is implicit.

One annoying surprise in bash is that the following program doesn't work,
perhaps because pipe starts new child processes?
#+BEGIN_EXAMPLE
echo foo | read
#+END_EXAMPLE

<2019-07-06>
I think the most important thing in a programming language is to separate names and referents,
that is, to be able to express things without naming them:
anonymous classes, anonymous functions, anonymous modules, anonymous objects, anonymous everything.
But it's cumbersome to do recursion without names.
* StackOverflow is harmful?
StackOverflow is full of bad advices and bad codes.

StackOverflow is great for expert developers who are trying to remember the details of a piece of code,
but bad for novices who don't know of the consequences of what they are pasting into their terminal.

Ubuntu StackExchange answer writers are too eager to recommend sudo,
and readers seem to be too eager to copy without understanding.
The result: Broken Ubuntu installation.
It did happen to a coworker of mine.
I think we all had a coworker who mindlessly copied stuff from StackExchange only to break their operating system installation
while not solving the original problem they set out to solve.
It goes like this:
- You have a problem.
- You copy a snippet from Stack Exchange.
- Now you have two problems.
* To write an IDE, we need a module system, not a type system
Module system is a prerequisite for writing an IDE and program analysis tool.

The setting/fixing of bindings/references/sites statically.

"Go to definition" and "find usages" is more important than type system.

Correct rename refactoring is more important than type system.

It is important to always be able to determine whether two names refer to the same thing.
"This name is declared/defined in <somewhere>"
"This name and that name refer to the same thing"
* Lisp and Scheme: converging?
Lisp now has static binding (lexical binding).

Scheme now has dynamic binding with "parameterize".

Some Lisp implementations have proper tail calls?

Lisp has multi-methods / generic functions for overloading (using the same name to work with several types).
Scheme standard does not specify overloading?
Guile has GOOPS.
https://www.gnu.org/software/guile/manual/html_node/Methods-and-Generic-Functions.html
Chicken Scheme.

I want to write "map"; I don't want to write "vector-map" or "<container>-map" for every container type.
* Expression-problem, OOP vs FP, subclass vs operation
OOP vs FP:
OOP makes adding subclasses easy but makes adding operations hard.
FP makes adding operations easy but makes adding subclasses hard.
Which one is more likely in our case, adding subclass or adding operation?

// In FP, it is easy to add functions working with Shape, but hard to add a new type of Shape.
data Shape = Circle | Rectangle

// In OOP, it is easy to add new subclasses of Shape, but hard to add methods to Shape.
class Shape
class Circle extends Shape
class Rectangle extends Shape

What if we need to both add subclasses and add operations?

Sometimes it is possible to add an overridable method with default implementation.

Can we combine OOP and FP to get the best of both worlds, so that it is easy to add subclasses and it is easy to add operations?
Or are we going to get the worst of both worlds?
If Scala aims to combine OOP and FP, what is Scala's solution to the expression problem?
How do we solve the expression problem in TypeScript?
http://fileadmin.cs.lth.se/sde/people/gorel/misc/ExpProblemTalkPart1.pdf
* Names and referents should be separated
** Executive summary
The target audience is programming language designers and implementors.

I suggest that programming language implementors follow these principles:
- Maximum composability and name-clash-freedom
  - The language must clearly separate names and referents.
    Name must not be a property of anything.
    Every language element must be able to exist anonymously.
    Every language element must be able to be referred to by a name.
    Example: JavaScript function vs C function.
  - The module systems must be a combination of JavaScript module system and Ocaml module system.
    Module must be first-class and anonymous.
- Metaprogrammability
  - The language must be homoiconic.
    The language must comfortably model its own syntax.
  - The language must use Curry-style type system (extrinsic typing), not Church-style type system (intrinsic typing).
- Usability
  - Overloading (giving same name several different meanings at the same time)?
  - The language must be lexically scoped.

We have two choices: Fix existing languages, or create a new language.
** Total separation between names and referents
*** Example with functions
Consider this example:
#+BEGIN_EXAMPLE
// C
double add1 (double x) { return x + 1; }

// JavaScript
var add1 = function (x) { return x + 1; };
#+END_EXAMPLE
In C, the name "add1" is a property of the function.
In JavaScript, "add1" is not a property of the function, but "add1" is a name that we use to refer to the function.

An analogous example:
"Erik" is not a property of me.
"Erik" is the name that people use to refer to me in a local scope (inside a room where I am the only person with that name).
My existence does not depend on the name people use to refer to me.
This is contrary to C that requires every function to decide its own name.

This separation between names and referents enhances composability.
In programming parlance, when we say "everything should be first-class",
we mean this total separation between names and referents.

A function must not decide its own name.
The caller of that function picks a name that it uses to refer to that function.
The same goes for modules and every other language element that can be named.
*** Example with modules
The key message:
- A thing (function, module, etc.) should not decide its own name.
- The implementation must be able to load a file into an anonymous module.
- The implementation must load the same file at most once.

If you satisfy those constraints, it will be simple to resolve name clashes in your language.

To avoid name clash, your module system must satisfy these:
- The user of a module, not the module itself, decides what to call that module.
  A module must not name itself.
  A module does not have a name.
  A name is not a property of a module.
  A name is something that the user of that module uses to refer to that module.
- A module can contain other modules.

As far as I know,
the only languages with satisfactory module systems are JavaScript and TypeScript.
Ocaml's anonymous modules and local imports are more satisfactory than JavaScript modules,
but Ocaml as a whole is unsatisfactory because Ocaml infers module names from file names.

Most programming languages are unsatisfactory.
A thing should not decide its own name.
#+BEGIN_EXAMPLE
// Java
package foo;      // Unsatisfactory: package foo decides its own name
class Cls {
}

-- Haskell
module Foo where  -- Unsatisfactory: module Foo decides its own name
data Bar = Baz

## Ruby
module Foo        ## Unsatisfactory: module Foo decides its own name
  class Bar
  end
end

// C++
namespace foo {   // Unsatisfactory: namespace foo decides its own name
}
#+END_EXAMPLE

The implementation must be able to /load a file into an anonymous module/:
#+BEGIN_SRC javascript
// JavaScript module system is satisfactory:
// foo.js contains a module, but it does not decide its own name;
// the user of foo.js decides that
// my_module is the local name it uses to refer to the module.
var my_module = require("foo.js");
#+END_SRC

The implementation must /load the same file at most once/.
(Two files are the same iff their paths resolve to the same canonical path.)
In this example, the contents of "foo.js" should be parsed exactly once.
#+BEGIN_SRC javascript
// JavaScript
var foo1 = require("foo.js");
var foo2 = require("foo.js");
// foo2 should refer to the same thing that foo1 refers to
#+END_SRC

A language used by millions of programmers must separate names and referents to avoid naming conflicts.
*** Philosophical investigation
Designing anything good:
Name is not a property of anything.
Name is a linguistic artifact that we use to refer to something.
A function does not have a name.
A predicate does not have a name.

A language must clearly separate names and referents (the things that the names refer to).

If Prolog is to have anonymous predicates, then it works with second-order logic, no longer with first-order logic.

The job of a module is to disambiguate names.
Example: which "member/2" do we mean?
*** Does it make sense in a language with nominal typing?
Such as Haskell, Java, Ur/Web?
* Basic questions
** How is a programming language a language?
A language is a convention for representing thoughts.

Important concepts have shorter encodings.
Who judges what is important?
The speakers.
** Why is it easy to mix natural languages but not programming languages?
The reason it is easy to mix natural languages is that their syntaxes are the same.
Their differences are superficial: the vocabulary.
They all serve to talk about the common things in human experience: eating, trees, lions, dogs, foods.
They share semantics.

Programming languages have wildly varying semantics.
Some doesn't even have clear semantics.
** How should we judge the quality of languages in general and programming languages in particular?
For example, English speakers judge that the quantity of a noun is important, when something happens is improtant.
German speakers judge that the gender of nouns is important.
The morphological features of a language reflects what its early speakers think is important to communicate.
Hypothesis: The genders of nouns reflect the early speakers' idea of what male is and what female is.

C makes memory manipulation easy.
Haskell makes functions easy.
Prolog makes database and inference easy.
Java is supposed to make working in big teams easy.

There is always a trade-off.
If something is made easier, something else must be made harder.
If something is encoded shorter, something else must be encoded longer.
Language is like Huffman coding built into the brain.
** When are programmers happy?
Happiness happens when what the programmer thinks is important coincides with what the language designer thinks is important.
For example, when I'm writing an accounting software, I don't care about the registers, pointers, memory addresses, and so on.
In this case, I care more about ontology than about pointers.
* Pre-design
** How should we design a programming language?
Language design should start from semantics.

Names and referents should be separated (orthogonal).

A language is only as good as how it promotes communication.

What is communicated through a programming language?
Two things: what things exist, and how those things should be manipulated.

Design is about trade-offs?
Type inference requires limiting language expressivity?
** What are the design constraints of a programming language?
A programming language must be ultimately translatable to the machine's primitives.

Wirth's "Algorithms + Data Structures = Programs"?[fn::https://en.wikipedia.org/wiki/Algorithms_%2B_Data_Structures_%3D_Programs]

Barbara Liskov: "Our compilers today are not powerful enough to support or enforce semantic constraints.",
answering question "Do you think that in those examples it’s worth having a refined subtype to explicitly encode the difference between the LIFO and FIFO semantics
as part of a typing system or that would be something that would be annotated externally to the type system, like semantic constraints?"[fn::https://www.infoq.com/interviews/barbara-liskov]

A programming language should not preclude efficient implementations.
** Literature research
What literature exists for programming language design?

What can programming language researchers learn from the philosophy of language?

Things to summarize:
- 1966 article "The Next 700 Programming Languages" http://www.math.bas.bg/bantchev/place/iswim/next700.pdf
- 1997 article "Scripting: Higher Level Programming for the 21st Century" http://artemisa.unicauca.edu.co/~lgarreta/elenguajes/readings/scripting.pdf
  - "This article is an opinion piece that explains why scripting languages
    will handle many of the programming tasks of the next century better than system programming
    languages."
- Other people's opinions about designing programming languages:
  - http://www.inquisition.ca/en/info/gepsypl/rules.htm
  - 2015 dissertation "Evidence-based programming language design: a philosophical and methodological exploration",
    [[https://jyx.jyu.fi/handle/123456789/47698][abstract]],
    [[https://jyx.jyu.fi/bitstream/handle/123456789/47698/978-951-39-6388-0_vaitos04122015.pdf][pdf]]
    - It's mostly philosophy of what "evidence-based" means.
    - It doesn't design a programming language.
    - It could have been shorter.
  - https://www.reddit.com/r/ProgrammingLanguages/comments/9ep9xq/what_i_did_not_steal_from_perl_6/
    - "What's a character?" https://www.perlmonks.org/?node_id=1214956
  - https://www.reddit.com/r/ProgrammingLanguages/comments/9eqrfy/what_are_the_biggest_problems_with_programming/
  - 2017 article "The End of History? Using a Proof Assistant to Replace Language Design with Library Design" [[https://www.cs.purdue.edu/homes/bendy/Fiat/fiat-snapl.pdf][pdf]]
  - [[http://purduepl.github.io/index.html][Purdue university programming languages group]]
- Shopping for ideas:
  - [[https://www.reddit.com/r/ProgrammingLanguages/comments/8vcrzb/what_are_some_interesting_language_features_that/][What are some interesting language features that may not be well known? : ProgrammingLanguages]]
  - https://softwareengineering.stackexchange.com/questions/55047/what-is-the-greatest-design-flaw-you-have-faced-in-any-programming-language
  - https://www.reddit.com/r/ProgrammingLanguages/comments/9erq87/languages_with_separate_types_for_pointers_to_the/
  - http://math.andrej.com/2009/05/29/mathematically-structured-but-not-necessarily-functional-programming/
  - read, "true sums of products" http://hackage.haskell.org/package/generics-sop
- "The Programming Languages Zoo [...] demonstrates various concepts and techniques used in programming language design and implementation.
  It is a good starting point [...]"
  http://plzoo.andrej.com/

Unanswered questions:
- Is there a homoiconic statically-typed language?
  Does type system hamper homoiconicity?
- Can we make high-level declarative language without garbage collection?

Making a programming language
https://www.reddit.com/r/ProgrammingLanguages/comments/9ky7o6/writing_my_own_programming_language/e72qjll/
banzr: 'Racket is taught in universities to be used to write languages. Use "match" and "cases" to build the parser and interpreter. Good luck!'


2017 "Language Oriented Modularity: From Theory to Practice"
http://programming-journal.org/2017/1/10/

2017 "Classless Object Semantics"
http://researcharchive.vuw.ac.nz/handle/10063/6681

http://www.pl-enthusiast.net/2015/05/27/what-is-pl-research-and-how-is-it-useful/
* Program correctness
** What is correct?
** How do we know that our program is correct?
If we know that program \(x\) is correct,
and we know that program transformation \(f\) preserves correctness,
then we can infer that \(f(x)\) is correct.

Otherwise, our software may be correct but we don't know, or worse, incorrect and we don't know.
** Type systems, lightweight program reasoning systems
A type system is a sublanguage for reasoning about programs, for expressing some properties of programs.
*** Is a type a set?
<2019-02-04>
Phil Freeman asked "Can someone explain why people object to thinking of types as sets? I mean, I normally don’t, but it doesn’t seem incorrect necessarily."
https://twitter.com/paf31/status/1092111216950992897

*** When should we introduce a type system?
- 2005 article "Introduction to Type Theory" [[http://www.cs.ru.nl/~erikb/onderwijs/sl2/materiaal/tt-sl2.pdf][pdf]]
*** Is inheritance subtyping?
   :PROPERTIES:
   :CUSTOM_ID: is-inheritance-subtyping
   :END:

The short article [2] basically tells the user to read AbdelGawad's other works.

- 1 [1] 1989, "Inheritance is not subtyping", [[https://www.cs.utexas.edu/users/wcook/papers/InheritanceSubtyping90/CookPOPL90.pdf][pdf]]
- 2 [2] 2013, "Inheritance is subtyping", [[https://pdfs.semanticscholar.org/569c/9b35375144756761167fd4a2571b1d97f0e8.pdf][pdf]]
- [[https://www.cmi.ac.in/~madhavan/courses/pl2009/lecturenotes/lecture-notes/node28.html][Subtyping vs inheritance]]
  - Subtyping and inheritance are orthogonal concepts.

A language should provide both nominal and structural subtyping.

- 2008, "Integrating Nominal and Structural Subtyping", [[http://www.cs.cmu.edu/~aldrich/papers/ecoop08.pdf][pdf]]

We can define structural subtyping for C structs.

We can define layout types (almost like ASN.1):

#+BEGIN_EXAMPLE
    layout {
        at byte 0;
        def var0 : little_endian int32;
        at byte 4;
        def var1 : big_endian int32;
        reserve 8 byte;
        skip 4 byte; -- synonym for reserve
        def var2 : int8;
        def var3 : array of 4 int8;
        align 16;
        def var4 : layout {
            reserve 16 byte;
            def var1 : int8;
            align 32;
        };
    }
#+END_EXAMPLE

We can define intersection, union, concatenation, and composition/nesting of two layout types.

Why don't we just build ASN.1 into the language?

- [[http://whiley.org/2010/12/13/why-not-use-structural-subtyping/][Why not use Structural Subtyping?]]

  - What is it trying to say?

*** Maximum polymorphism?
   :PROPERTIES:
   :CUSTOM_ID: maximum-polymorphism
   :END:

- Read this: [[https://blog.inf.ed.ac.uk/apl16/archives/178/comment-page-1][Lecture 4: Higher Polymorphism | Advances in Programming Languages]]
- [[https://github.com/lampepfl/dotty/issues/1886][Rethink Structural Types · Issue #1886 · lampepfl/dotty]]

  - "However, there is another area where statically-typed languages are often more awkward than dynamically-typed ones: database access."
  - Keynote - What's Different In Dotty by Martin Odersky https://www.youtube.com/watch?v=9lWrt6H6UdE

*** Typing records
   :PROPERTIES:
   :CUSTOM_ID: typing-records
   :END:

A record type can be thought of as a product type whose components are named.

If each value =valN= has type =typN=, then the record ={key1=val1; key2=val2; ...;}= has type ={key1:typ1; key2:typ2; ...;}=.
For example, the record ={name="John"; age=20}= has type ={name:String; age:Int;}=.

*** Polymorphism is code generation
   :PROPERTIES:
   :CUSTOM_ID: polymorphism-is-code-generation
   :END:

- Consider translating =id : a -> a= to assembly.

  - If types define memory layout (bit representation), then the compiler must generate an =id= function for every =a=.
  - If the language uses runtime type tagging, then there doesn't have to be more than one=id= functions.

*** Fixed points and recursive types
   :PROPERTIES:
   :CUSTOM_ID: fixed-points-and-recursive-types
   :END:

A thing \( x \) is a /fixed point/ of function \( f \) iff \( f(x) = x \).

A function may have zero, one, or many fixed points.

A thing \( x : A \) is a /least fixed point/ of function \( f : A \to A \) iff
\( x \) is a minimum of the set of the fixed points of \( f \).
The words "least" and "minimum" assume an ordering \( \le \).
This ordering should be clear from context.

If \( f \) has exactly one least fixed point \( x \) with respect to ordering \( \le \), then we write \( \mu_\le(f) = x \).

The syntax \( \mu a. b \) means \( \mu_\le(\lambda a. b) \).
The syntax \( \mu a. b \) is analogous to lambda expression syntax \( \lambda a. b \).

What is the ordering used in formulating the least fixed point of a recursive algebraic data type?

todo: equirecursive types and isorecursive types

*** Benefits and drawbacks of static type checking
The benefits of types:

- Types prevent stupid mistakes.
- Types can be used to improve program efficiency.
- Types are documentation for both human and machine.
  Types communicate intention to both human and machine.

The drawbacks of types:

- Some safe programs don't typecheck.
- Some programs become longer.
  - Haskell's type system complicates the AST decoration problem.
    In TypeScript, the AST decoration problem is trivial;
    you just add a field at runtime.
**** Arguments for static type checking?
***** What?
- There are two camps:
  - DTL (dynamically typed language)
  - STL (statically typed language)
- Every programmer is lazy, but differently.
  - People who use DTLs are too lazy to write the types.
  - People who use STLs are too lazy to do what machines can do, such as
    - detecting typos,
    - avoiding unintentional conversions,
    - tracing the code, 2 weeks later, to find out the type of a variable.
- People who use DTLs are too diligent.
They love to do what machines can do: type checking.
- Static typing enables you to be lazier.
  Help the machine help you avoid work.
  By investing in a few keystrokes, you will get these in return:
- The machine will catch more mistakes for you.
- You can have an IDE that finds references correctly.
  This enables features such as "Jump to definition", "Rename", and even more fancy refactorings.
- Moral of the story:
  - Let the machines do all the boring stuffs.
  - Be future-lazy, not present-lazy.
    Do things now so that you can be lazy later.
    Don't be lazy now only to regret it later.
    - People who organize their things are too lazy to spend mental effort later in a scramble to find things.
    - People who don't organize their things are just too lazy to do it, and would rather just experience regret in the future than experience some hardship now for a better future.
    - The sane solution to "too lazy to write types" is to pick a language with type inference, not to ditch types altogether.
    Don't throw the baby out with the bathwater.
- This argument also applies to functional programming vs procedural programming.
  Indeed this argument applies to every technology.
  Adopting technology enables us to be lazier.
- People buy tractors because they are too lazy to till their fields with hoes.
- People use frameworks because they are too lazy to do the same plumbing again and again.
- People strive to avoid side-effects in functional programming because they are too lazy to debug synchronization errors.
- The only thing the human race isn't too lazy to do is to think about lazier ways of doing things.
***** What?
- https://dimjasevic.net/marko/2018/10/23/typed-functional-programming-and-software-correctness/
  - "what can be done about a programmer’s limited time to write correct software?
    While there are multiple plausible answers to this question,
    I will argue that a very effective solution is to use typed functional programming."
  - 2017 https://dimjasevic.net/marko/2017/11/10/a-subtyping-polymorphism-misfortune/
    - "the interaction between subtyping and parametric polymorphism asks for trouble"
    - type-parameter variance and polymorphism don't mix?
*** Prolog is ideal for writing a typechecker, and TypeScript is ideal for typechecking AST decorations, so we should fuse Prolog and TypeScript.
Abdullah pointed out to me that TypeScript interface is similar to Ocaml polymorphic variant?
**** But there is Racket and its languages such as ProfessorJ, Datalog.
- "Creating languages" https://docs.racket-lang.org/guide/languages.html
* Concepts?
** Then, design the concrete syntax
The concrete syntax of \( \Gamma \vdash A \) is \( with(\Gamma,A) \).
** Macro, reflection, reification, quoting
The language should be a model of itself.

The language should be able to describe itself.

Does that cause a paradox?
** What program, execution, and termination mean in declarative paradigms

In functional paradigm:

- The program is a big lambda expression.
- Execution is beta-reduction / term-rewriting.
- Execution terminates when the program reaches normal form (is no longer beta-reducible).

In satisfying-logic paradigm:

- The program is a big logic formula.
- Execution is trying to satisfy the formula.
- Execution terminates when satisfiability is determined.

In theorem-proving paradigm:

- The program is a big logic formula, presumably in conjunctive-normal form.
- Execution is trying to prove the main(world) goal.
- Execution terminates when the goal is proved or disproved.

** Records, also for namespaces and modules

We want records because /records obviate namespaces and modules/.

We want namespaces and modules because they are necessary for humans to manage large programs.

*** We don't want to represent records as functions.

We can describe the semantics of a record r as a function r : string -> expression.

There are several options to pretty-print a record:

- Define a =show-record= function that is different from =show=.
- But we want polymorphic =show=. We want one =show= function to work for all things.
- If a record is represented by a lambda abstraction, then pretty-printing the record will pretty-print a lambda abstraction.
  We don't want that.
  We want pretty-printed records to look like how we write records.

*** We want records to be applicable like lambda; we add a new beta-reduction rule for "applying" records.

Record access is function application.
To get the field =fld= or record =rec=, evaluate =rec fld=.

The record =rec= with the the field =fld= updated to =new= is the expression =\ name -> IF name = fld THEN new ELSE rec fld=.

We add this beta-reduction rule:

- If X is a record, and Y is a string, then =X Y= reduces to =get X Y=.

We want to pretend that records are functions.
We want to use records as if they were functions.
But we don't want records to be functions; we want to pretty-print records as records, not as lambda abstractions.

*** Modules as record functions

A module is a function taking a record and giving a record.
The input is called /imports/ or /dependencies/.
The output is called /exports/.

Example:

#+BEGIN_EXAMPLE
\ { add; } -> { add_one: \ x -> add x 1; }
#+END_EXAMPLE

*** Record expressions

We add these expression syntax rules:

- If each of x1,...,xn is a label and each of e1,...,en is an expression, then ={x1:e1; ...; xn:en;}= is a /record expression/.
- =union R S= is a /record union expression/.
- record update expression (should be polymorphic)
- record filtering/selection/intersection expression

An example of a record expression is ={id: \ x -> x; app: \ f x -> f x;}=.

*** Labels

A /label/ is a string.
If the label doesn't contain funny characters, it doesn't have to be quoted.
For example, ={"a":1;}= and ={a:1;}= are the same thing.

Should we generalize label to expression?
** Annotations: user-defined metadata attached to concrete syntax tree nodes

We add these expression syntax rules:

- If M is an expression and E is an expression, then =E : M= (read: data E annotated with metadata M) is an /annotated expression/.
  - Alternative syntax: =E : M= can also be written =meta M E=.

This generalizes type systems.
With type systems, you annotate an expression with a type expression.
With general annotations, you annotate an expression with another expression (some of which are type expressions).

We assume that the outermost metadata update wins:

- meta M (meta N E) = meta M E

We add metadata extraction function symbol =meta-of=.

We add these beta-reduction rules:

- reduce (meta M E) = reduce E
- reduce (meta-of (meta M E)) = reduce M
- reduce (meta-of E) = #<empty-record> (for expressions without metadata)

This is like Java/C# annotation but more principled?

*** Annotation is not type

This is an example of type annotation that our annotation above can't handle: =\ (x : T) -> y=,
because =x= is not an expression.
** Modeling all data

*** Hypothesis: data = ADTs + records + row polymorphism

Hypothesis: All data can be modeled by a combination of these:

- product (tuple)
- sum (alternative, union)
- record (tuple with named components)
- row polymorphism

Can we use web standards to define an ontology (so we can use Protege to edit it)?
https://protege.stanford.edu/

- Does Eclipse EMF have textual representation?

*** Church-representation of products, sums, and algebraic data types in general

https://en.wikipedia.org/wiki/Lambda_calculus#Pairs

Let [x] mean the /representation/ of x.

A /product/ (a,b) can be represented as [(a,b)] = \ f -> f [a] [b].

The left projection p1 is represented as [p1] = \ p -> p (\ a b -> a).

If we assume the sum type A + B, then:

- The choice inl a can be represented as [inl a] = \ f g -> f [a].
- The choice inr b can be represented as [inr b] = \ f g -> g [b].

A recursive data type such as "stream a = (a, stream a)" can be represented as:

- [cons h t] = \ f -> f [h] [t].

Thus [a : b : c : ...] = \ f -> f [a] (\ f -> f [b] (\ f -> f [c] ...)).

A recursive data type such as "list a = nil | cons a (list a)" can be represented as:

- [nil] = \ f g -> f.
- [cons x y] = \ f g -> g [x] [y].

Natural numbers "nat = z | s nat":

- [z] = \ f g -> f.
- [s x] = \ f g -> g [x].

Thus:

- [s z] = \ f g -> g (\ f g -> f)

*** Reverse semantics

Semantics maps syntax to mathematical object.

Reverse semantics maps mathematical object to syntax.
Reverse semantics is representation.
Reverse semantics is realization.

Example of reverse semantics is representing the tuple =(x,y)= with the lambda abstraction =\ f -> f [x] [y]= where =[x]= denotes the representation of x.

https://en.wikipedia.org/wiki/Realizability

*** Self-interpreter

1994 article "Efficient Self-Interpretation in Lambda Calculus"
** Representing knowledge; logic programming; symbolic AI
- https://en.wikipedia.org/wiki/Logic_programming#Knowledge_representation
- https://en.wikipedia.org/wiki/Knowledge_representation_and_reasoning

Example: We encode "a todo item has an int64 id" as

#+BEGIN_EXAMPLE
IF entity todo_app todo E THEN property E int64 id.
#+END_EXAMPLE
** Dynamic binding, contextual holes

- 1996 article "Enriching the lambda calculus with contexts: toward a theory of incremental program construction" https://dl.acm.org/citation.cfm?id=232652
- 1998 article "A lambda-calculus for dynamic binding" https://core.ac.uk/download/pdf/82810390.pdf
- 1998 article "Computing with Contexts: A simple approach" https://core.ac.uk/download/pdf/82065430.pdf
- 2009 article "Two-level Lambda-calculus" https://www.sciencedirect.com/science/article/pii/S1571066109002400

** Interpreters: Giving different meanings to the same syntax

Sometimes we want to interpret the same syntax (appearance, source code, text) differently.

** Precise memory accounting

We want precise memory accounting to enable the runtime to limit memory usage.

** Execution state reification, save states, saving and loading states, pausing and resuming computations

We want execution state reification so that we can do live process migration.

** After-2018 programming language requirements

*** Ergonomic error handling
*** REPL (read-eval-print loop)

The language must not preclude making a REPL for it.

REPL is important for immediate feedback, experimentation, exploration, and playing around.

*** Example of mixing nominal and structural subtyping

https://www.eclipse.org/n4js/features/nominal-and-structural-typing.html

*** Programming language should separate modeling and binding. Can we combine dynamic binding and static typing?

Example of binding is =import= statement.

*** Paradigm, approach, viewpoint, worldview?

- graph programming languages

  - https://cstheory.stackexchange.com/questions/3906/what-are-theoretically-sound-programming-languages-for-graph-problems

    - https://www.cs.york.ac.uk/plasma/wiki/index.php?title=GP_%28Graph_Programs%29
    - 2007, PhD thesis, Steinert, [[https://www.cs.york.ac.uk/ftpdir/reports/2007/YCST/15/YCST-2007-15.pdf]["The graph programming language GP"]]
    - a short visual example of "conditional rule schemata"

      - 2010, article, [[https://www.cs.york.ac.uk/plasma/publications/pdf/PoskittPlump.VS-Theory.10.pdf]["Hoare Logic for Graph Programs"]]

    - https://markorodriguez.com/2013/01/09/on-graph-computing/
    - https://en.wikipedia.org/wiki/Gremlin_(programming_language)

- equational programming?

  - 2017-2018, https://www.cs.vu.nl/~tcs/ep/
  - term-rewriting

    - retired, [[http://q-lang.sourceforge.net/][Q language]]

      - http://q-lang.sourceforge.net/examples.html
      - superseded by Pure

        - https://agraef.github.io/pure-lang/
        - https://en.wikipedia.org/wiki/Pure_(programming_language)
        - https://github.com/agraef/pure-lang/wiki/Rewriting

    - Joy

- 2002, article, [[http://www.cs.tufts.edu/comp/150PP/archive/norman-ramsey/pmonad.pdf]["Stochastic Lambda Calculus and Monads of Probability Distributions"]]
- "Purely functional lazy nondeterministic programming", [[https://www.cambridge.org/core/journals/journal-of-functional-programming/article/purely-functional-lazy-nondeterministic-programming/1E8BA117E549A9612BC4AF9804E5507A][paywall]]
- relational programming (pure logic programming?)

  - miniKanren

    - Byrd PhD thesis https://scholarworks.iu.edu/dspace/bitstream/handle/2022/8777/Byrd_indiana_0093A_10344.pdf

      - mentions other programming languages: Prolog, Mercury, Curry

- https://en.wikipedia.org/wiki/Multi-adjoint_logic_programming
- ramble

  - https://www.researchgate.net/project/Ontology-oriented-programming
  - http://www.doc.ic.ac.uk/~klc/OntProg.html

*** Low-code? Programming for the masses?

Limited programming?

What can we assume about the user's skill/knowledge/background?

- https://en.wikipedia.org/wiki/End-user_development
- https://en.wikipedia.org/wiki/Low-code_development_platforms
** Toward a language with first-class syntax?
   :PROPERTIES:
   :CUSTOM_ID: toward-a-language-with-first-class-syntax
   :END:

- composable grammars?

  - 2013, article, Viera & Swierstra, "First Class Syntax, Semantics, and Their Composition" http://www.cs.ru.nl/P.Achten/IFL2013/symposium_proceedings_IFL2013/ifl2013_submission_21.pdf

    - 2013, PhD thesis, Viera, "First Class Syntax, Semantics, and Their Composition" file:///home/erik/Downloads/viera.pdf

  - 1990, [[https://authors.library.caltech.edu/26726/]["A Primer for Program Composition Notation"]]
  - https://stackoverflow.com/questions/953185/composable-grammars
  - OMeta
  - Programming languages with programmable syntax

    - [[http://chrisseaton.com/katahdin/][Katahdin]]

  - parsing expression grammar, packrat

    - "Parsing ought to be easier"

      - https://news.ycombinator.com/item?id=2330830

        - "PEGs are one class of cleanly composable grammars."?

  - http://www.cs.cmu.edu/~Compose/
  - cryptographic protocol analysis

    - https://en.wikipedia.org/wiki/Universal_composability

- Programming languages with macros

  - Common Lisp
  - Scheme
  - Kotlin?
  - Clojure?
  - Scala? https://www.scala-lang.org/blog/2017/11/27/macros.html

** Enabling metaprogramming
   :PROPERTIES:
   :CUSTOM_ID: enabling-metaprogramming
   :END:

- [[https://stackoverflow.com/questions/50490883/why-is-ml-called-meta-language][metaprogramming - Why is ML called Meta-Language? - Stack Overflow]]
- related?

  - https://github.com/PostgREST/postgrest
  - http://rosecompiler.org/

- Metaprogramming

  - http://kaitai.io/

    - from description, generate parsers for binary data (as opposed to text data)

- Aspect-oriented programming is a restricted form of metaprogramming.

  - relationship between Aspect-Oriented Programming and Functional Programming

    - 2009, article, "What Does Aspect-Oriented Programming Mean for Functional Programmers?", [[https://www.cs.ox.ac.uk/files/2282/wgp14-wang.pdf][pdf]]
    - 2008, article, "On Feature Orientation and Functional Programming", [[https://pdfs.semanticscholar.org/522e/b6c2ea910ed074a13fe21767c9fa070fb685.pdf][pdf]]
    - 2016, article, "Realtime collaborative editor. Algebraic properties of the problem.", [[http://blog.haskell-exists.com/yuras/posts/realtime-collaborative-editor.html][html]]

      - see also Darcs patch theory

    - 2008, PhD thesis, "An Integrated System to Manage Crosscutting Concerns in Source Code", [[http://wwwtmp.st.ewi.tudelft.nl/arie/phds/Marin.pdf][pdf]]
    - 2003, article, "Language-independent aspect-oriented programming", [[http://www.tara.tcd.ie/handle/2262/32627][pdf available]]

- Java metaprogramming

  - Similar products

    - libraries

      - [[https://github.com/INRIA/spoon][INRIA Spoon]]
      - The =javax.lang.model= package of the Java standard library, but it does not model method bodies.

    - environments

      - [[http://www.eclipse.org/modeling/emf/][Eclipse Modeling Framework (EMF)]]
      - [[https://www.jetbrains.com/mps/][JetBrains MPS (Meta Programming System)]]
      - [[http://strategoxt.org/][Stratego/XT]]
      - TXL
      - [[http://www.eclipse.org/Xtext/][Eclipse Xtext]] and [[http://www.eclipse.org/xtend/][Eclipse Xtend]]

    - programming languages

      - Eclipse Xtend

    - parser generators

      - [[https://en.wikipedia.org/wiki/Compiler-compiler][WP:Compiler-compiler]]
      - [[https://en.wikipedia.org/wiki/Comparison_of_parser_generators][WP:Comparison of parser generators]]
      - [[http://www.antlr.org/][ANTLR (Another Tool for Language Recognition)]]
      - [[https://javacc.org/][JavaCC]]
      - YACC, Bison; with Lex, Flex

  - Related concepts

    - Model-driven development
    - Model-driven architecture

** Automatic (program) differentiation
   :PROPERTIES:
   :CUSTOM_ID: automatic-program-differentiation
   :END:

- What is the relationship between incremental lambda-calculus and automatic differentiation of programs (or of algebraic data types)?

** Extending functions
   :PROPERTIES:
   :CUSTOM_ID: extending-functions
   :END:

Not only classes, but also functions, should be extensible.

"To extend the function \( f : A \to B \) to the function \( f' : A' \to B' \)" means:

- For every \( x \in A \), we have \( f(x) = f'(x) \).
- \( A \subseteq A' \).
- \( B \subseteq B' \).

A consequence:
Every occurrence of \( f \) can be replaced with \( f' \) while preserving the meaning of the containing expression.

** A sketch about reusable language-oriented programming: CommonMark, Liquid, and Jekyll, reusable grammar?
   :PROPERTIES:
   :CUSTOM_ID: case-study-commonmark-liquid-and-jekyll-reusable-grammar
   :END:

I want something like this:

#+BEGIN_EXAMPLE
    data CommonMark = ... -- CommonMark AST
    data Liquid = ... -- Liquid AST
    type Jekyll = CommonMark + Liquid

    parse_cm : String -> Parser CommonMark
    parse_lq : String -> Parser Liquid
    parse_jk : String -> Parser Jekyll
    parse_jk = parse_cm + parse_lq
#+END_EXAMPLE

- [[https://stackoverflow.com/questions/953185/composable-grammars][design - Composable Grammars - Stack Overflow]]
- [[https://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2015/12/composable.html][Grammar reuse]]
- [[https://github.com/melt-umn/silver][melt-umn/silver: An attribute grammar-based programming language for composable language extensions]]
- OMeta, Katahdin
** Whole-program optimization?
   :PROPERTIES:
   :CUSTOM_ID: whole-program-optimization
   :END:

- https://stackoverflow.com/questions/3416980/why-arent-whole-program-optimizations-more-prevalent-now/27757382

** TODO <2018-09-15> Make the programming language
- \cite{DBLP:conf/popl/CookHC90}
- \cite{cartwright2013inheritance}
** TODO <2018-09-15> Find out how type systems may guarantee pointer safety
Is escape analysis the only way?
*** TODO <2018-09-15> Study Sixten type system
*** TODO <2018-09-15> Study Rust type system
See [[https://doc.rust-lang.org/reference/type-system.html][Rust type system reference]].
** Combine things and let the programmer choose?
*** Combine nominal subtyping and structural subtyping
** Effects?
- Reddit post "Try/Catch and Async/Await are just a specialized form of Algebraic Effects!" https://www.reddit.com/r/ProgrammingLanguages/comments/9kzcz6/trycatch_and_asyncawait_are_just_a_specialized/
  - 2016 article "Algebraic Effects for Functional Programming" https://www.microsoft.com/en-us/research/wp-content/uploads/2016/08/algeff-tr-2016-v2.pdf
    - "we show how algebraic effects generalize over common constructs like exception handling, state, iterators and async-await"
  - <2018-10-08> not yet performant
** Abdullah research roadmap
- Abbreviations:

  - CCC: Cartesian closed category ([[https://en.wikipedia.org/wiki/Cartesian_closed_category][Wikipedia]])

- Abdullah wants to make a monad-aware programming language.

  - Categories enable us to organize a hierarchy of effects?

    - effectful over category \( C \) = extends category \( C \)?

- The plan is to research two related things in parallel:

  - using algebraic subtyping to mix parametric subtyping and inheritance subtyping

    - [[https://www.cl.cam.ac.uk/~sd601/thesis.pdf][Stephen Dolan's Ph.D. thesis "Algebraic subtyping"]]

      - "Type systems which support subtyping care about the direction of data flow."
      - "Find the /simplest/ algebra of types, and /some/ syntax for them"

    - [[https://en.wikipedia.org/wiki/Subtyping][Wikipedia: Subtyping]]
    - Scala already tries to join parametric subtyping and inheritance subtyping.
      What is the problem with Scala?

- Related: [[file:%7B%%20link%20functional_programming.md %}][functional programming research]].
- Who is Abdullah?

  - Abdullah a.k.a. Kim-Ee Yeoh is [[https://www.atamo.com/][atamo.com]].

*** Research questions
   :PROPERTIES:
   :CUSTOM_ID: research-questions
   :END:

**** Possible questions
    :PROPERTIES:
    :CUSTOM_ID: possible-questions
    :END:

- What is the result of CPS-transforming a recursive function?

#+BEGIN_SRC haskell
    fac 0 = 1
    fac n = n * fac (n - 1)

    fac 0 k = k 1
    fac n k = fac (n - 1) $ \ x -> k (n * x)
#+END_SRC

Conjecture:
Every recursive function can be transformed to a tail-recursive function with a helper function \( f(x) = f(g(x)) \).

#+BEGIN_SRC haskell
    fac 0 = 1
    fac n = n * fac (n - 1)

    fach (a, 0) = (a, 0)
    fach (a, n) = fach (a * n, n - 1)

    fac n = fach (1, n)
#+END_SRC

How do we enable the caller to step the recursion?

#+BEGIN_SRC haskell
    fac n = \ k -> k (\ x -> x * fac (n - 1) k) n
    fac n (\ f x -> f x)

    tri 0 = 0
    tri n = n + tri (n - 1)

    tri :: Nat -> ((x -> c -> Nat) -> Nat -> Nat)
    tri 0 = \ k -> 0
    tri n = \ k -> k (\ x c -> x + tri (n - 1) c) n

    inc x = inc (x + 1)

    inc x = \ k -> k (\ ) (x + 1)
#+END_SRC

- [[https://github.com/dorchard/unfix][github: dorchard/unfix: Takes a recursive function and syntactically unties the recursive knot]]

**** What is the relationship between self-reference, recursion, and fixed points?
    :PROPERTIES:
    :CUSTOM_ID: what-is-the-relationship-between-self-reference-recursion-and-fixed-points
    :END:

We say that \( x \) is a /fixed point/ of \( f \) iff \( f(x) = x \).

[[https://mathoverflow.net/questions/126513/categories-of-recursive-functions][MO 126513: categories of recursive functions]]

- What is the essence of self-recursion?

  - =fix= does not exist in a strict language.

    - "The Z combinator will work in strict languages [...]" [[https://en.wikipedia.org/wiki/Fixed-point_combinator#Strict_fixed_point_combinator][WP: Fixed-point combinator]]

      - The Z combinator is obtained by eta-expanding the Y combinator.

**** What is the formal definition of strict, non-strict, eager, and lazy?
    :PROPERTIES:
    :CUSTOM_ID: what-is-the-formal-definition-of-strict-non-strict-eager-and-lazy
    :END:

The difference is explained by luqui on [[https://stackoverflow.com/questions/7140978/haskell-how-does-non-strict-and-lazy-differ][SO 7140978]]. - Strict and non-strict are about meaning (denotational semantics?).
Eager and lazy are about operation (operational semantics?). - Strictness is a domain-theoretic concept.
Laziness is a computer implementation detail. - This uses Haskell to introduce domain theory: [[https://en.wikibooks.org/wiki/Haskell/Denotational_semantics][Wikibooks: Haskell: Denotational semantics]]. - In Haskell, the least fixed point operator can be defined as =fix f = f (fix f)=. - Why is bottom the /least/ fixed point of =id=?
Every \( x \) is a fixed point of an identity function \( x \mapsto x \), isn't it? - What is the ordering? - "Semantic approximation order" - [[https://wiki.haskell.org/Lazy_vs._non-strict][Haskell wiki]] is wrong?
It conflates non-strictness with normal-order reduction strategy? - [[http://pages.cs.wisc.edu/~horwitz/CS704-NOTES/6.DENOTATIONAL-SEMANTICS.html#simple][A simple example of denotational semantics using a language of binary numerals]] - [[https://en.wikipedia.org/wiki/Binary_combinatory_logic][WP: Binary combinatory logic]].
Its semantics is SK calculus (SKI calculus without the redundant I combinator) which is equivalent to lambda calculus. - we can execute non-strict functions eagerly,
for example by strictness analysis or speculative execution.

People are often sloppy with these terms. Redditors. Experts. Researchers. Academics.
It is true that Haskell is non-strict.
It is true that Haskell (as implemented by GHC) is lazy.

We can infer these formal definitions: - A function \( f \) is /strict/ iff \( f(\bot) = \bot \). - "a strict function must map bottom to bottom" (from the SO answer)

**** How do we represent general recursion by a monad? How do we add general recursion to TFP? How do we do it with monads?
    :PROPERTIES:
    :CUSTOM_ID: how-do-we-represent-general-recursion-by-a-monad-how-do-we-add-general-recursion-to-tfp-how-do-we-do-it-with-monads
    :END:

Here we try to salvage [McBride2015].

TODO write the problem: how McBride's General doesn't compose

- Is McBride's General really a monad?
- Is Abdullah's M really a monad?
- Did Abdullah mistranslate McBride's General?
- Is there a way to transform begin-step-end to McBride's General or Abdullah's M?
- Start with axioms, then infer the data types.

These are the axioms that we want M to satisfy. - =rec f . rec g = rec (ext f . g)= - =rec f . rec g = rec (f <=< g)= - =rec pure = id=

How do we translate a recursive function =f : a -> b=
to an explicitly recursive function =f : a -> m b=?

#+BEGIN_SRC haskell
    -- Abdullah's M, obtained by translating
    -- the General in [McBride2015] from Agda to Haskell
    data M s t a
        = Em a
        | Ap (t -> M s t a) s

    cata :: (a -> r) -> ((t -> r) -> s -> r) -> r
    cata ar xrxr m = fix $ \ self m -> case m of
        Em a -> ar a
        Ap xma x -> xrxr (self . xma) x
#+END_SRC

- Why do we want to add general recursion to TFP?

  - Adding general recursion to a TFPL
    makes programming in that language more practical.

- There are several attempts to add general recursion to TFP.

  - [Nordstrom1988] (terminating general recursion)
  - [Bove2001] (simple general recursion in type theory)
  - [Capretta2005] (general recursion via coinductive types)
  - [McBride2015] (Turing-completeness totally free)
  - me on 2018-04-07? "Approximating general recursion in TFP"?
  - [[http://adam.chlipala.net/cpdt/html/GeneralRec.html][A non-termination monad inspired by domain theory]],
    part of the documentation of Coq's GeneralRec library

- How are monads useful in FP?

  - Monads allow embedding a strict language in a lazy language [Wadler1996].
  - "Monads may be regarded as a mild generalization of continuation-passing style." [Wadler1996]

- [[http://homepages.inf.ed.ac.uk/wadler/topics/monads.html][Philip Wadler's research on monads]]
- Reading triage:

  - Moggi 1991: Notions of computation and monads

    - Programs should form a category.

      - Every type becomes an object in the category.
      - Every (one-parameter) function becomes a morphism in the category.

    - "Kleisli triples are just an alternative description for monads. Although
      the former are easy to justify from a computational perspective, the latter
      are more widely used in the literature on category theory and have the
      advantage of being defined only in terms of functors and natural transformations,
      which make them more suitable for abstract manipulation."
    - Moggi's most cited paper, according to Google Scholar
    - [[https://www.disi.unige.it/person/MoggiE/][Moggi's home page]]

      - [[https://www.disi.unige.it/person/MoggiE/publications.html][Moggi's list of his publications]]

        - recent paper: 2010 "Monad Transformers as Monoid Transformers". Theoretical Computer Science, TCS vol.411

  - [[https://www.irif.fr/~mellies/mpri/mpri-ens/articles/moggi-computational-lambda-calculus-and-monads.pdf][Moggi 1989: Computational lambda-calculus and monads]]
  - 2017 Uustalu [[https://www.semanticscholar.org/paper/Partiality-and-Container-Monads-Uustalu-Veltri/a45cabd8696232a985368e5b7f138fd21a7bff9f][Partiality and container monads]]
  - [Sheard2003] (a pure language with default strict evaluation order and explicit laziness)
  - [Wadler1998] (how to add laziness to a strict language without even being odd)
  - [Wadler1992] "explores the use of monads to structure functional programs"
  - [[https://srfi.schemers.org/srfi-40/mail-archive/msg00059.html][Monad for lazy evaluation]],
    Scheme, SRFI-40 mail archive, Andre van Tonder
  - [[http://math.andrej.com/2008/11/17/not-all-computational-effects-are-monads/][Not all computational effects are monads]]
  - 2018 Tomas Petricek [[https://arxiv.org/pdf/1803.10195.pdf][What we talk about when we talk about monads]]

*** Result of meeting on 2018-04-21
   :PROPERTIES:
   :CUSTOM_ID: result-of-meeting-on-2018-04-21
   :END:

- https://mvanier.livejournal.com/2897.html
- Applicative Functor is a homomorphism over CCC (Cartesian closed category)?
- We can use a category as the denotation of a functional programming language.

  - An example of a category:

    - One object: Unit
    - One morphism:
    - Two functions:

      - =f0 x = Unit=
      - =f1 x = x=

- What is a CCC? It is a category that satisfies the axioms in [[https://en.wikipedia.org/wiki/Cartesian_closed_category][WP: CCC]].

*** Agenda for 2018-04-21
   :PROPERTIES:
   :CUSTOM_ID: agenda-for-2018-04-21
   :END:

**** Totality is not about termination
    :PROPERTIES:
    :CUSTOM_ID: totality-is-not-about-termination
    :END:

Consider this example.
This recursion is not structural.
However, it terminates under normal-order beta-reduction strategy.

#+BEGIN_SRC haskell
    -- Constant function.
    f : Nat -> Nat
    f _ = 0

    main : Nat
    main = f main
#+END_SRC

Is =main= a total function?
Does that question make sense?
Note that =main= is not a mathematical function.
The denotation of =main= might be a mathematical function.

Does totality depend on the reduction strategy?
Does that question make sense?

I conjecture that every general recursive function can be transformed into its begin-step-end form.
See "Approximating general recursion in TFP".

**** I think we can't add a Lazy Monad instance to Strict Haskell without changing the language semantics
    :PROPERTIES:
    :CUSTOM_ID: i-think-we-cant-add-a-lazy-monad-instance-to-strict-haskell-without-changing-the-language-semantics
    :END:

Here I try to (and fail to) add a Lazy monad to an imaginary language Strict Haskell (SH).

Imagine SH, a language with Haskell syntax
but with Scheme's applicative-order beta reduction (AOBR) instead of Haskell's normal-order beta reduction.
AOBR means: to evaluate =f x=, first evaluate =x=, and then evaluate =f x=.
SH is strict, and Haskell is lazy.

An inhabitant of the type =Lazy a= can be thought of as a thunk that will return an inhabitant of =a=.

To construct an expression of type =Lazy a=, combine these: - The expression =bottom= constructs a thunk will fail. - The expression =pure x= constructs a thunk that will return =x=.
Note that =x= is evaluated before the thunk is constructed. - The expression =delay f= constructs a thunk that will return the result of evaluating =f Unit=.
The type of =f= is =Unit -> a=.
Note that =f unit= is not evaluated when the thunk is constructed,
unlike =pure=. - The expression =eval t= evaluates or forces the thunk =t=.
The type of =eval= is =Lazy a -> Maybe a=.

We want to embed laziness into SH.
Formally, this means that we want this equation to hold

#+BEGIN_EXAMPLE
    eval (bottom >>= \ x -> pure c) = Just c
#+END_EXAMPLE

but this is impossible in SH because the =>>== is strict.

However, if the type of =>>== were this

#+BEGIN_EXAMPLE
    (Monad m) => m (Lazy a) -> (Lazy a -> m (Lazy b)) -> m (Lazy b)
#+END_EXAMPLE

then it would be possible to embed laziness into SH.

Thus =Lazy= cannot be a =Monad= instance in SH.

Monads allow embedding a strict language in a lazy language [Wadler1996].
We are trying the reverse (embedding a lazy language in a strict language).
We have just tried the most naive way.
It failed.

**** Does TFP really sacrifice Turing-completeness?
    :PROPERTIES:
    :CUSTOM_ID: does-tfp-really-sacrifice-turing-completeness
    :END:

- What is a rigorous definition of Turing-completeness?

  - [[https://en.wikipedia.org/wiki/Turing_completeness][Wikipedia]]:
    "a system of data-manipulation rules (such as a computer's instruction set, a programming language, or a cellular automaton)
    is said to be Turing complete or computationally universal if it can be used to simulate any Turing machine"

    - What does "simulate" mean?

  - What is the relationship among total Turing machine, partial Turing machine, total function, and partial function?
    See [[https://en.wikipedia.org/wiki/Machine_that_always_halts][Wikipedia: Machine that always halts]].

- Why do you ask this?

  - We've been thinking that totality precludes Turing-completeness, but Conor McBride disagrees in [McBride2015].

*** Results
   :PROPERTIES:
   :CUSTOM_ID: results
   :END:

**** Is continuation the mother of all monads?
    :PROPERTIES:
    :CUSTOM_ID: is-continuation-the-mother-of-all-monads
    :END:

Abdullah wants to prove that continuation is the mother of all monads.

I think I have a partial proof of that for all Haskell-98 type endofunctions.

The folder [[https://github.com/Lambda-Jakarta/research/tree/master/abdullah-conjecture][abdullah-conjecture]]
contains a proposed partial proof of the Abdullah conjecture for all Haskell 98 type endofunctions.
The proof can be checked by the Lean theorem prover version 3.
See also the [[https://leanprover.github.io/][Lean prover home page]].
To edit Lean source files, use Visual Studio Code and its Lean plugin.

*** Reading triage
   :PROPERTIES:
   :CUSTOM_ID: reading-triage
   :END:

[[https://pdfs.semanticscholar.org/b60b/1c2e49ec6f574f220f162c8fdc81b2831830.pdf][1995, D. A. Turner, Elementary Strong Functional Programming]]

[[https://nms.kcl.ac.uk/maribel.fernandez/papers/TCS10.pdf][Godel's System T revisited]]

[[http://semantic-domain.blogspot.co.id/2012/12/total-functional-programming-in-partial.html][Total Functional Programming in a Partial Impure Language]]

[[http://www.cse.chalmers.se/~coquand/bengt.pdf][Type theory and functional programming]]:
Can we see type theory as a functional programming language?

[[http://www.cse.chalmers.se/~coquand/][Thierry Coquand page at Chalmers]]

[[https://mathoverflow.net/questions/126513/categories-of-recursive-functions][MO 126513: Categories of recursive functions]]

[[https://www.researchgate.net/publication/234808984_Denotational_semantics_and_rewrite_rules_for_FP][Denotational semantics and rewrite rules for FP]]:
"We consider languages whose operational semantics is given by a set of rewrite rules."

[[http://www.allisons.org/ll/Semantics/][allisons.org: Denotational Semantics]]

The Y-combinator is \( \lambda f. (\lambda x. f ~ (x ~ x)) ~ (\lambda x. f ~ (x ~ x)) \).
[[https://en.wikipedia.org/wiki/Fixed-point_combinator][WP: Fixed-point combinator]]

[[http://siek.blogspot.co.id/2016/12/simple-denotational-semantics-for.html][Simple Denotational Semantics for the Lambda Calculus, Pω Revisited?]]

*** Undigested information fragments
   :PROPERTIES:
   :CUSTOM_ID: undigested-information-fragments
   :END:

- "Partiality is an effect"
  https://www.cs.ox.ac.uk/ralf.hinze/WG2.8/22/slides/tarmo.pdf
- "Partiality Monad Transformer"
  https://stackoverflow.com/questions/15192897/partiality-monad-transformer
- http://www.cse.chalmers.se/~nad/publications/danielsson-semantics-partiality-monad.pdf
- categorical programming language

  - http://web.sfc.keio.ac.jp/~hagino/thesis.pdf
  - https://mathoverflow.net/questions/3721/programming-languages-based-on-category-theory
  - https://softwareengineering.stackexchange.com/questions/216635/category-theory-based-language

- "Kleisli triple over a category"
- "Category formed by the Kleisli triples over a category"
- Moggi 1991:

  - "Kleisli triples are just an alternative description for monads. Although
    the former are easy to justify from a computational perspective, the latter
    are more widely used in the literature on category theory and have the
    advantage of being defined only in terms of functors and natural transformations, which make them more suitable for abstract manipulation."

- Where does monad come from? Who invented it? Why was it invented?
- What is the relationship among monad, natural transformation, Kleisli category of a monad, Eilenberg-Moore what, adjunction?
- Has some semantics link
  http://math.andrej.com/2016/08/06/hask-is-not-a-category/comment-page-1/
- [[ftp://nozdr.ru/biblio/kolxo3/Cs/CsLn/Mathematics%20of%20program%20construction..%2010%20conf.,%20MPC%202010%20(LNCS6120,%20Springer,%202010)(ISBN%203642133207)(O)(435s)_CsLn_.pdf#page=109][2010, "Subtyping, Declaratively: An Exercise in Mixed Induction and Coinduction", Nils Anders Danielsson and Thorsten Altenkirch]]
** Language design
- https://github.com/mjambon/ocaml-wishlist
** Designing configuration languages
  :PROPERTIES:
  :CUSTOM_ID: designing-configuration-languages
  :END:

*** What is a configuration language?
   :PROPERTIES:
   :CUSTOM_ID: what-is-a-configuration-language
   :END:

Configuration language is programming language minus Turing-completeness.

*** What is the best configuration language?
   :PROPERTIES:
   :CUSTOM_ID: what-is-the-best-configuration-language
   :END:

2018-08-31:
[[https://github.com/dhall-lang/dhall-lang][Dhall]] is the pinnacle of configuration languages, in my opinion, as far as I know.

Can a configuration language get any better than Dhall?

How far can we push configuration languages without Turing-completing it?

Dhall isn't the only Turing-incomplete language.
There are also Coq, Lean, Agda, and others.
Can we use these as configuration languages?
Should we?

*** Some rants
   :PROPERTIES:
   :CUSTOM_ID: some-rants
   :END:

Write your configuration in Dhall.
You minimize duplication.
It generates YAML/JSON.

Why stop there?
Replace all your YAML, JSON, XML, INI, PROPERTIES, configurations with Dhall.

2018-08-31:
We're considering HashiCorp Terraform.
I think they should use Dhall, or at least learn from Dhall, instead of creating their own
[[https://www.terraform.io/docs/configuration/syntax.html][HCL (HashiCorp Configuration Language)]].
We have a "Terraform Workaround Engineer" here at work.

Someone has done that: [[https://github.com/blast-hardcheese/dhall-terraform][dhall-terraform]].
** Designing markup languages
  :PROPERTIES:
  :CUSTOM_ID: designing-markup-languages
  :END:

A markup language adds some semantics to text.

- Finding the best document typesetting/processing system

  - What are some markup languages?

    - http://www.nongnu.org/skribilo/
    - markdown
    - reST (restructured text)
    - TeX, LaTeX
    - Unix roff, troff, nroff, man, GNU groff
    - GNU info

- Finding a lightweight semantic markup language with fixed ontology

  - [[https://en.wikipedia.org/wiki/Lightweight_markup_language][WP:Lightweight markup language]]
  - Which markup language?

    - reST
    - [[https://en.wikipedia.org/wiki/Textile_(markup_language)][Textile]]. GitHub Pages stopped supporting this.
    - S-expression
    - not Markdown?
    - https://tiddlywiki.com/static/WikiText.html
    - https://hackage.haskell.org/package/mmark
    - [[https://orgmode.org/][Org mode for Emacs -- Your Life in Plain Text]]

      - [[https://medium.com/@jackbaty/using-markdown-instead-of-org-mode-a78a1805c0ba][Using Markdown instead of Org Mode -- Jack Baty -- Medium]]

  - Which tool?

    - pandoc
    - hakyll

  - Which editor?

    - Vim
    - Emacs
    - Visual Studio Code
    - Too experimental

      - [[https://clearly.pl/tutorial/][clearly.pl]] reminds me of TiddlyWiki.
** Class-based programming
  :PROPERTIES:
  :CUSTOM_ID: class-based-programming
  :END:

- What is a class?

  - What is a class?

    - A class is a blueprint (a template).
    - A class is a way of organizing your program.

  - What does a class have?

    - A class has name, fields, and methods.

  - What does a class do?

    - A class groups data and code that needs that data.

- Every object belongs to a class.
- In class-based programming:

  - Objects don't have methods.
  - Classes have instance methods.
  - Each instance method can be called with an instance as a hidden argument.

- From procedural point of view, these two are the same:

#+BEGIN_EXAMPLE
    // Java

    object.method(arg0, arg1, ...)

    // C

    method(object, arg0, arg1, ...)
#+END_EXAMPLE

- The dot is just a syntax for passing an implicit first argument.
- The dot operator associates to the left:

#+BEGIN_EXAMPLE
    a.b().c().d() = ((a.b()).c()).d()
#+END_EXAMPLE
** Measuring programming language quality
- https://en.wikipedia.org/wiki/Goodhart%27s_law
*** Minimum IQ required to understand the language
*** Development cost
**** Length of program
**** Development effort; number of people; amount of time
*** Developer feeling/enjoyment
*** Maintenance cost
**** Cost due to runtime defects (defects discovered while the program is running in production environment)
*** Rosetta Stone: comparing programs that do the same thing in different languages
https://medium.com/concerning-pharo/elegant-pharo-code-bb590f0856d0
*** Learnability, masterability, usability
*** Measuring programming language quality by how easy is it to do the right thing
What is the right thing?

By probability of error of random programs?

How do we measure the probability that a program, uniformly randomly taken from the set of all legal programs in language L, contains an error?
** Intersection between programming language search and software engineering: The effect of programming language on software quality
- https://developers.slashdot.org/story/14/11/05/0530228/the-effect-of-programming-language-on-software-quality
  - 2014 article "A Large Scale Study of Programming Languages and Code Quality in Github" [[http://web.cs.ucdavis.edu/~filkov/papers/lang_github.pdf][pdf]]
    - I don't know enough to determine whether the methodology is valid.
** Beginning programming language research
- [[https://blog.acolyer.org/2018/01/26/a-practitioners-guide-to-reading-programming-languages-papers/][A practitioner's guide to reading programming languages papers]]
  - from [[https://www.reddit.com/r/ProgrammingLanguages/top/][top scoring links : ProgrammingLanguages]]
- https://waleedkhan.name/blog/getting-a-job-in-pl/
  - https://www.reddit.com/r/ProgrammingLanguages/comments/9ffiky/how_to_get_a_job_in_programming_languages/
** Racket syntax objects, read-syntax; does Prolog/Haskell have this?
- Must understand: reader and expander.
  - Racket parsing has two stages/levels: reader and expander.
  - (My guess?) The output of the reader is the input of the expander?
- https://docs.racket-lang.org/guide/hash-reader.html
  - "The difference between =read= and =read-syntax= is that read is meant to be used for data while =read-syntax= is meant to be used to parse programs."
  - Readtables work at the reader level.
  - Macros work at the expander level.
    - Macros can't change the lexicon.
** Stop abusing the equals sign
  :PROPERTIES:
  :CUSTOM_ID: stop-abusing-the-equals-sign
  :END:

The equals sign should be used for equations only and nothing else.

Consider this fragment in a hypothetical functional programming language.

#+BEGIN_SRC haskell
    hang : Nat
    hang = hang
#+END_SRC

The fragment =hang = hang= falsely suggests that it is an /equation/ like $x = x$.
We can substitute $x$ with any natural number, and the equation $x = x$ will still hold.
But that is not what we mean with =hang=.
We are defining a /rewrite rule/, not an equation.
Thus we should write =hang => hang= instead.

In an equation, the left and right side are equal.
We don't care if they are flipped.
In a rewrite rule, we care about direction.
We want to start with $1 + 1$ and end with $2$, not the other way,
unless we are writing a theorem prover.

Programming is hard enough already.
Let's not make it harder for students.
Stop using confusing notation.

Reading triage:

- [[https://www.researchgate.net/publication/286418817_Misuse_of_the_equals_sign_An_entrenched_practice_from_early_primary_years_to_tertiary_mathematics][Misuse of the equals sign: An entrenched practice from early primary years to tertiary mathematics]]
** Problems that the language has to solve
*** Solving the expression problem
*** Solving the AST decoration problem / AST typing problem
- Other names of this problem:
  - [[https://www.reddit.com/r/haskell/comments/1f91w3/the_ast_typing_problem/][AST typing problem]]
  - "Trees that grow" problem
- common problem in parsing: how to decorate AST in a functional language
  - 2013, article, [[http://blog.ezyang.com/2013/05/the-ast-typing-problem/][The AST typing problem]], Edward Z. Yang
    - 2010, discussion, "The AST typing problem", [[http://lambda-the-ultimate.org/node/4170][LTU]]
  - Embracing the Any type
    - [[http://javaparser.org/][JavaParser]] added an =Object data= field to the AST Node base class, but they changed their minds.
      - https://github.com/javaparser/javaparser/issues/456
      - https://github.com/javaparser/javaparser/pull/472
  - Structural typing
    - TypeScript (JavaScript) is ideal for AST decoration problem?
      You just add a key to the AST node object you want to decorate.
      - Any language with structural typing is ideal?
      #+BEGIN_EXAMPLE
          interface Node {
          }

          interface Node_parse extends Node {
          }

          interface Node_desugar extends Node_parse {
          }
      #+END_EXAMPLE
  - Loosely-typed Haskell?
    - This is basically the JavaScript way.
    #+BEGIN_SRC haskell
        type Key = String
        data Value
            = VNum Double
            | VStr String
            | VObj Object
        type Object = [(Key, Value)]
        type Node = Object
    #+END_SRC
  - 2017, article, "Trees that grow", https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf
    - "The compiler writer is then faced with two unpalatable choices.
      She can define a new data type representing the output decorated tree, at the cost of much duplication.
      Or she can write a single data type with all the necessary fields and constructors, at the cost of having many unused fields and constructors at different stages of compilation."
    - However, we can fake extensible ADTs with pattern synonyms, with Fix, and without type families.
      - Similar endeavors
        - https://wiki.haskell.org/Type_composition
      - Haskell doesn't beta-reduce types.
      - This is an example code:
      #+BEGIN_SRC haskell
          data Exp_ name exp
              = Var name
              | Add exp exp
              | ...

          data Locd a
              = MkLocd Loc a

          data Typed t a = MkTyped t a

          newtype Compose f g a = MkCompose { unCompose :: f (g a) }

          type PsExp name = Fix (Compose Locd (Exp_ name))
          type TcExp name = Fix (Compose Locd (Compose Typed (Exp_ name)))

          -- To ameliorate the verbosity:

          class Exp name exp where
              var :: name -> exp
              add :: exp -> exp -> exp
              ...

          instance Exp (PsExp name) where ...
          instance Exp (TcExp name) where ...
      #+END_SRC
  - What if GHC can "inline" data types at compile time?
    What if GHC can "inline" A and B in =data A = MA Int; data B = MB Int String; data E = EA A | EB B;=,
    producing =data E = EA Int | EB Int String=?
    Implementing this with Haskell 98 types should be straightforward.
  - related - "Data types a la carte" - http://hackage.haskell.org/package/compdata - Haskell type composition - https://wiki.haskell.org/Extensible_datatypes
- Other people's efforts
  - https://brianmckenna.org/blog/type_annotation_cofree
- https://discuss.ocaml.org/t/is-it-feasible-to-write-parsers-without-using-polymorphic-variants-for-ast-representation/1906
**** Other solutions to the AST typing problem / trees-that-grow problem; using recursion schemes for separation of concern in functional programming
- "Program Reduction: A Win for Recursion Schemes" http://www.newartisans.com/2018/04/win-for-recursion-schemes/
  - Annotated expression trees
    - "The first moment when this recursion scheme went from an interesting idea to a good design decision was when someone created an issue on GitHub, asking to add location information to the expression tree."
  - Abstract Definitional Interpreters?
    - 2017 article "Abstracting Definitional Interpreters" https://arxiv.org/abs/1707.04755
  - boilerplate
  - recommends using recursion schemes

That is an interesting idea, but some important questions remain:

- How do we do that without boilerplate (for the library writer)?
- How do we do that without performance penalty?

** object = lambda + record + mutation?
#+BEGIN_EXAMPLE
let self = {
        prop = 1;
        foo = \ () -> self.prop + 1;
}; in self
#+END_EXAMPLE
** Logic programming with explicit side-effects with force-predicate
The meaning of force(X) is that force(X) succeeds iff it has changed the world such that X will succeed after force(X) returns.
Thus the interpreter has to check for race conditions?
Is this requirement too difficult?
#+BEGIN_EXAMPLE
?- file_content('foo', A). -- unify A with the contents of file 'foo'

?- force(file_content('foo', [1,2,3])). -- replace the content of file 'foo' with [1,2,3]
#+END_EXAMPLE

** Prolog as a term-rewriting meta-interpreter
The Prolog rule "A :- B" can be interpreted in two ways.
The first is the well-known proof-theoretic interpretation "to prove A, prove B".
The second is the /rewriting-system interpretation/ "rewrite A to B".
** Functions as semantics of lambda calculus?
Key idea:
A lambda abstraction is not a function,
but a function can be the semantics of a lambda abstraction.

A semantic of a lambda abstraction is a function, that is,
a triple \((A,B,M)\) where \(A\) is the domain, \(B\) is the codomain, and \(M\) is the mapping.

What is the semantic of \( \lambda x . x x \)?
What is the semantic of \( (\lambda x . x x) (\lambda x . x x) \)?

For every set \(A\):
\begin{align*}
(A,A,I_A) \models \lambda x. x
\end{align*}
where \(I_A = \{ (x,x) ~|~ x \in A \}\).

\begin{align*}
(X,Y,A) \models \lambda x y. x y
\end{align*}

Let \(F = (A,B,f)\) be a function.

Let \(G = (F \times A, B, g)\) be a function where \( g(f,x) = f(x) \).
** How do we know that our language is perfect?
"How to determine your new language is perfect?"
http://lambda-the-ultimate.org/node/4395
* Declarative
** Combining lambda-calculus and first-order logic: combining beta-reduction, unification, and backtracking
Anonymous function: \ x -> x + 1
Anonymous predicate: \ a b c -> f a, g b, h c
fix f = f (fix f)

father_child(dad, kid).
father_child(daddy, kiddo).

:- operator --
father(daddy) -- child(kiddo).

father_child dad kid
father_child daddy kiddo
father dad -- child kid

father_child = \ dad kid
father_child = \ Dad Kid -> Dad = dad, Kid = kid

"First-order logic without equality"
https://math.stackexchange.com/questions/363168/first-order-logic-without-equality

"Differences between logic with and without equality"
https://mathoverflow.net/questions/316648/differences-between-logic-with-and-without-equality


Isn't this Curry language?
Curry's slogan is "A Truly Integrated Functional Logic Language"


Lambda-Prolog, Harrop formula
Why was Harrop formula defined?
What's so special about it?
https://en.wikipedia.org/wiki/Harrop_formula

Lambda-Prolog

https://math.stackexchange.com/questions/2494645/lambda-calculus-combined-with-first-order-logic-notation-quantifiers-propositi

"But languages aren't tools! IDEs are tools. Languages are material. See FallacyOfTheRightTool."
http://wiki.c2.com/?QuestForThePerfectLanguage
** Prolog predicate naming
blue(X)
has(A,B)
can_sing(A)
version(A,B,C)
person_name(P,N)
index_fibonacci
index_list_element

class_field
table_column
column_type

class(Atom) is true iff Atom is a referent.

table(Atom) has different namespace

class_field(Cls, F) :- table_column(T, Col), field_name(F, N), column_name(Col, N).

Metamodel
A thing is modeled as an association list such as [a=b,c=d,e=f]
alist_key_value([K=V|_],K,V).
alist_key_value([_|R],K,V) :- alist_key_value(R,K,V).

alist_empty
alist_tail
alist_head
alist_without_keys
alist_size
alist_merge

thing_prop(T,P)
thing_prop_replaced(T0,P,T1)
Use thing_prop_replaced(T,P,T) to get the property P of T


url_page

There is a difference between dif and \=: dif is coroutining.
https://stackoverflow.com/questions/16560058/difference-between-x-y-and-difx-y
But "coroutine" is an overloaded term.
http://www.swi-prolog.org/pldoc/man?section=delcont


Prolog predicate naming problem when there is a compound word
integer_integer_sum(A, B, C)
basic_block__ssa_block()
** Prolog
How does Mercury do without assert/retract?[fn::https://www.mercurylang.org/information/doc-latest/mercury_trans_guide/AssertRetract.html]

- https://stackoverflow.com/questions/20511060/parsing-an-expression-in-prolog-and-returning-an-abstract-syntax
  - "you did something quite smart [...] That is fine. However, this strategy is inherently very inefficient"
  - "There is a general way how to fix this: Add another pair of arguments to encode the length."

1988, Towards functional programming in Prolog[fn::ftp://obaluae.inf.puc-rio.br/pub/docs/Publications/88_AI_Furtado_SINPLAN.Not.pdf].
It defines several infix operators.
"[...] The problem of evaluating expressions combining functions and predicates is investigated.
Examples are provided to illustrate the discussion.
The paper includes a prototype implementation."

2.7.1 "Axiomatizing Context-Free Grammars"[fn::http://www.mtome.com/Publications/PNLA/prolog-digital.pdf].
See third paragraph: "the general statement made by the context-free rule [...] can be summarized using relations on positions with the following logical statement [...]"

** Reconciling functional and logic programming into declarative programming?

1996 publication "A Note on Declarative Programming Paradigms and the Future of Definitional Programming" [[http://www.cse.chalmers.se/~oloft/Papers/wm96/wm96.html][html]]

*** Example: Representing a predicate in lambda calculus

Lambda calculus with boolean logic extensions:

#+BEGIN_EXAMPLE
p = \ x -> x = "a" OR x = "b"
#+END_EXAMPLE

Prolog:

#+BEGIN_EXAMPLE
p(a).
p(b).
#+END_EXAMPLE

*** Example: Representing a function in logic programming

#+BEGIN_EXAMPLE
inc(X, Y) :- X = Y + 1.
#+END_EXAMPLE

*** The "satisfy" function

The expression "satisfy f" finds all x : a that satisfies f : a -> bool.
Thus the type of "satisfy" is "(a -> bool) -> list a".

It is in principle possible to write such "satisfy" builtin for some lambda expressions.

#+BEGIN_EXAMPLE
satisfy (\ x -> x = "a" OR x = "b")
=> ["a","b"]

satisfy (\ (x : int) -> x >= 10)
=> [10,11,12,...] -- an infinite list

satisfy (\ (x : bool) -> true)
=> [false,true]
#+END_EXAMPLE

*** A function is a relation, a relation is a function, so what?

A function \( (A,B,F) \) is trivially a relation.

A relation \( (A,B,R) \) is a function \( (A,2^B,F) \) where \( F(x) = \{ y ~|~ (x,y) \in R \} \).
* Interoperation
** Foreign function interface: working with C
** Working with existing systems
*** Working with Java
** Interoperability between programming languages
- <2018-10-04> https://www.thestrangeloop.com/2018/all-the-languages-together.html
  - "Unfortunately, most current languages and toolchains were designed with language interoperability as an afterthought [...]"
  - "This talk is about how to change the status quo to make it easier to build multi-language software."
* Functional programming language design
** "Let" introduces sharing?
"Let" determines how the AST (abstract syntax tree) turns into ASG (abstract semantic graph).
** Lambda calculus algebra what?
The algebraicity of the lambda-calculus[fn::http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.311.3514&rep=rep1&type=pdf]
#+BEGIN_QUOTE
an untyped lambda-calculus is a functor LC from sets to sets: to a set V (of free ”variables”) it assigns a set LC(V) of lambda-terms built out from V;
this functor enjoys substitution, which turns it into a monad;

The idea that the notion of monad is suited for modelling substitution concerning
syntax (and semantics) has been retained by many recent contributions
concerned with syntax (see e.g. [BP99] [GU03] [MU04]) although some other
settings have been considered.
#+END_QUOTE
** Algebra of ADT
Somewhat interesting
https://stackoverflow.com/questions/9190352/abusing-the-algebra-of-algebraic-data-types-why-does-this-work
** Lambda calculus
Lambda calculus formalizes binding and substitution.

Follow [[https://crypto.stanford.edu/~blynn/lambda/][Ben Lynn's lambda-calculus tutorial]]:

- why use lambda calculus as theoretical basis (cool reasons!)
*** Beta-reduction
- reduce : E -> E
- reduce ((\ x -> y) p) = reduce (y[x:=p])
  - y[x:=p] means y but with every bound occurence of x replaced with p)
- reduce x = x otherwise
** Let-expressions

The /let-expression/ =let x1 = y1; ...; xn = yn; in z;= desugars to =(\ x1 ... xn -> z) y1 ... yn=.

Let-expressions is for readability by humans.

Do we still need let-expressions if our program is well-factored?

*** let-expressions may recur

I think letrec is ugly.
All let-expression should allow recursion, like Haskell's.

https://stackoverflow.com/questions/28796904/whats-the-reason-of-let-rec-for-impure-functional-language-ocaml/28798040
** Sharing, laziness, full laziness, complete laziness, and optimal reduction

- https://www.reddit.com/r/haskell/comments/3pa5ii/are_optimal_evaluators_actually_optimal/
  - https://cstheory.stackexchange.com/questions/32850/are-optimal-evaluators-actually-optimal

*** Sharing

- Should the programmer care about sharing?
- sigma-calculus?
- Should the programmer decide whether to share or not?
- Is there a best sharing strategy?
- Should the machine guess by heuristics?

Sharing affects performance, but does not change the result.
Should we care?

*** Example of sharing

Consider the expression letexp defined as =let x = y in z;=.

We want x to be shared iff doing so speeds up the reduction of letexp.

This is always the case:

- If x occurs /at most once/ in z, we always want x not shared.

These depend on circumstances:

- If y is expensive, we want x shared.
- If y is cheap, we want x not shared.

How do we define "expensive"?

*** Lazy accumulation problem

#+BEGIN_EXAMPLE
sum a 0 = a
sum a

sum 0 = 0
sum n = n + sum (n - 1)
#+END_EXAMPLE
** Currying is not compatible with vararg and named parameters?

Vararg stands for "variable-length arguments".

Do we want currying?

Currying simplifies language user but complicates compiler writer.

The problems:

- https://softwareengineering.stackexchange.com/questions/286231/is-it-possible-to-have-currying-and-variadic-function-at-the-same-time
- http://tolmasky.com/2016/03/24/generalizing-jsx/

** System F, System F with subtyping, System F-omega

https://en.wikipedia.org/wiki/System_F

"System F is rich enough that the self-application =\x.x x= is typable." https://crypto.stanford.edu/~blynn/lambda/systemf.html

Brown and Palsberg, "Breaking Through the Normalization Barrier: A Self-Interpreter for F-omega"

** Introduction to lambda-calculus?
- unknown-year lecture notes "Lambda Calculus as a Programming Language" [[http://andrei.clubcisco.ro/cursuri/2pp/01.Lambda_prog.pdf][pdf]]

I thought lambda calculus could be summarized in one page, but Henk Barendregt wrote hundreds of pages about it. Is there more to lambda calculus than it seems?

- 1994, 50 pages, [[http://www.nyu.edu/projects/barker/Lambda/barendregt.94.pdf][pdf]]
- 1991, 190 pages, [[https://people.mpi-sws.org/~dreyer/tor/papers/barendregt.pdf][pdf]]
** Extending lambda-calculus with various bells and whistles

- Vectorial lambda-calculus

  - The 2013 article "The Vectorial Lambda-Calculus" [[https://who.rocq.inria.fr/Alejandro.Diaz-Caro/TheVectorialCalculus.pdf][pdf]] adds vectors and matrices and their types to lambda calculus.
  - The 2010 article "Semantics of a Typed Algebraic Lambda-Calculus" [[https://arxiv.org/abs/1006.1433][pdf available]] also mentions "vectorial".

- 2016 article "System F-omega with Equirecursive Types for Datatype-Generic Programming" [[http://ps.informatik.uni-tuebingen.de/research/functors/equirecursion-fomega-popl16.pdf][pdf]]

** Lambda calculus semantics?

- https://en.wikipedia.org/wiki/Lambda_calculus#Semantics

  - "In the 1970s, Dana Scott showed that, if only continuous functions were considered,
    a set or domain D with the required property could be found, thus providing a model for the lambda calculus."

    - 1982, [[https://www.sciencedirect.com/science/article/pii/S0019995882800879]["What is a model of lambda calculus?"]]
    - 2008, PhD thesis, [[https://tel.archives-ouvertes.fr/tel-00715207/document]["Models and theories of lambda calculus"]]

      - 2009, [[https://arxiv.org/abs/0904.4756][summary]]

- Paul Hudak, lecture notes, [[http://www.cs.yale.edu/homes/hudak/CS430F07/LectureSlides/Reynolds-ch10.pdf][The Lambda Calculus]]

  - "The Greatest Thing Since Sliced Bread™, or maybe even before it"

- The operational semantics of lambda calculus depends on the evaluation strategy?

  - What-reduction?

    - Normal-order reduction
    - Applicative-order reduction

  - Call-by-what?

    - Call-by-value
    - Call-by-name

** Optimizing lambda calculus?

- http://thyer.name/lambda-animator/
- http://thyer.name/phd-thesis/
- http://hackage.haskell.org/package/graph-rewriting-lambdascope
- partial evaluation

  - 2010, slides, "O, partial evaluator, where art thou?", Lennart Augustsson, [[http://www.cse.chalmers.se/~palka/Lennarts_talk/PEPM-2010.pdf][pdf]]

    - https://en.wikipedia.org/wiki/Partial_evaluation

      - Futamura projection

  - 1997, article, "Distributed partial evaluation", [[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.134.1238][citeseerx]]

- Lambda calculus

  - might be related to bottom-up beta substitution

    - Abdullah hinted that BUBS (bottom-up beta-substitution [Shivers2004])
      might be used to make a garbage-free or a fast interpreter.
    - https://en.wikipedia.org/wiki/Strict_programming_language
    - https://en.wikipedia.org/wiki/Lazy_evaluation
    - [[https://memo.barrucadu.co.uk/strict-vs-lazy.html][Strict-by-default vs Lazy-by-default]]
    - https://en.wikipedia.org/wiki/Applicative_computing_systems
    - non-strict, beta reduction, normal order, applicative order
    - The terms "lazy" and "strict" imply operational semantics.
      They are two strategies for beta-reduction.
      "Lazy" is normal-order.
      "Strict" is applicative-order.
    - [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.2386&rep=rep1&type=pdf][An Algorithm for Optimal Lambda Calculus Reduction, John Lamping]]
    - [[http://www.lsv.fr/Publis/PAPERS/PDF/sinot-wrs07.pdf][Complete Laziness: a Natural Semantics, François-Régis Sinot]]
    - http://rochel.info/ graph-rewriting-lambdascope (screenshot): An implementation of an optimal evaluator for the λ-calculus, PDFLambdascope

  - How is lambda calculus algebraic?

    - [[https://www.mscs.dal.ca/~selinger/papers/combinatory.pdf]["The lambda calculus is algebraic", Peter Selinger]]

      - "We argue that free variables should not be interpreted as elements in a model, as is usually done, but as indeterminates."

    - [[https://pdfs.semanticscholar.org/055d/69ee4dc95fbf6457419c90338493667478b1.pdf]["On the algebraic models of lambda calculus", Antonino Salibra]]

      - "The variety (equational class) of lambda abstraction algebras was introduced
        to algebraize the untyped lambda calculus in the same way Boolean algebras algebraize the classical propositional calculus."
        Propositional logic is modeled by Boolean algebra.
        First-order logic is modeled by cylindric algebra?
        Lambda calculus is modeled by lambda abstraction algebra.
        Why algebra? Because it is equational?

    - [[https://en.wikipedia.org/wiki/Algebraic_logic][Wikipedia "algebraic logic"]]
    - [[https://pdfs.semanticscholar.org/7596/19f05a42ff3045bcf87fcaa3edbff01e1130.pdf]["The algebraic lambda-calculus", Lionel Vaux]]
    - [[https://pdfs.semanticscholar.org/44c9/2ad00b8ceba78319005db048b24d61a80748.pdf]["Lambda abstraction algebras: representation theorems", Don Pigozzi, Antonino Salibra]]
    - [[http://www.dsi.unive.it/~salibra/mainfinale.pdf]["Applying Universal Algebra to Lambda Calculus", Giulio Manzonetto, Antonino Salibra]]

  - Dana Scott's PCF; also search the Internet for "the language pcf"
    [[http://www.cs.bham.ac.uk/~mhe/papers/RNC3.pdf]["Introduction to Real PCF (Notes)", Mart'in H"otzel Escard'o]]
  - 1993 John Launchbury [[https://pdfs.semanticscholar.org/492b/200419199892857faa6a6956614641ae9464.pdf][Lazy imperative programming]]

- lambda calculus

  - Church-encoding enables lambda calculus to represent conditionals and algebraic data types.
  - Fixed-point combinators enables recursion and looping.
  - https://en.wikipedia.org/wiki/Lambda_cube
  - https://en.wikipedia.org/wiki/Calculus_of_constructions
  - https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus

    - "The simply typed lambda calculus [...], a form of type theory,
      is a typed interpretation of the lambda calculus with only one type constructor: [...] that builds function types."

      - What is an "interpretation of the lambda calculus"?
      - What is "the lambda calculus"? Is there only one lambda calculus?

  - https://www.reddit.com/r/haskell/comments/8els6f/why_are_combinators_as_powerful_as_full/
  - https://math.stackexchange.com/questions/5639/the-power-of-lambda-calculi
  - Implement lambda calculus.

    - Without dynamic allocation / garbage collection.
    - Translate lambda calculus to assembly

      - Basic idea:

        - Every expression translates to a subroutine.
        - Calling the subroutine ~ evaluating the expression.
        - Subroutine return value ~ value obtained by evaluating the expression.

      - A lambda abstraction translates to a subroutine that accepts one parameter.
      - An application translates to a subroutine call.
      - An int value translates to what? Choice:

        - itself
        - a subroutine that returns the int

    - 2012, article, [[https://arxiv.org/abs/1202.2924]["From Mathematics to Abstract Machine: A formal derivation of an executable Krivine machine"]]

      - https://en.wikipedia.org/wiki/Krivine_machine

** Ocaml
- https://ocaml.org/learn/
** Imperative subset
Haskell's ST monad enables us to embed a local imperative program in a functional program.
** Overloadable function application?
** Haskell woes

- [[https://news.ycombinator.com/item?id=5893442][Ask HN: Any downsides of programming in Haskell? | Hacker News]]
- [[https://www.reddit.com/r/haskell/comments/1gknfs/ask_hn_any_downsides_of_programming_in_haskell/][Ask HN: Any downsides of programming in Haskell? : haskell]]

*** Can't import type class instances explicitly

[[https://stackoverflow.com/questions/8728596/explicitly-import-instances][There is a reason]].
** Monads, and Haskell type system limitations

- A monad is a way of /conservatively extending/ all categories. (Abdullah, private correspondence)
- https://www.reddit.com/r/haskell/comments/3h2aqg/can_someone_explain_the_monads_are_generalised/

*** Should Nat (the natural numbers) be a subtype of Int (the integers)?

Intuitively, yes.

*** <2018-10-01> @abdullah Signedness is a monad: conservatively extending naturals to integers

I think this is what we mean when we say "integer is a monad".
I think what we are really trying to say is "signedness is a monad", that is, "we can conservatively extend the naturals to the integers by using the Signed monad".

We can write that in Haskell as follows (with some problems described later).

#+BEGIN_EXAMPLE
data Nat = Zero | Succ Nat
type Int = Signed Nat
data Signed a = Positive a | Negative a

instance Functor Signed ...
instance Applicative Signed ...

instance Monad Signed where
    return = Positive
    m >>= k = join_signed (fmap k m)

join_signed :: Signed (Signed a) -> Signed a
join_signed mm = case mm of
    Positive x -> x
    Negative x -> negate_signed x

negate_signed :: Signed a -> Signed a
negate_signed (Positive x) = Negative x
negate_signed (Negative x) = Positive x

f :: Nat -> Nat
f = ...

f_int :: Int -> Int
f_int = fmap f
#+END_EXAMPLE

We can have Signed Char, Signed String, etc., but those may not make sense.

The problem:
Nat should be a subtype of Int, because everyone who knows arithmetics seems to think that way.
We want f and f_int to be the /same/ function.
We don't want to type fmap, liftM2, and their ilk.
** Abdullah's dream language: Extending System F application beta-reduction rules to automate fmap and extend?
Add these inference rules?
- If =f : a -> b=, and =x : m a=, and =m= is an instance of =Functor=, then =f x= beta-reduces to =fmap f x=.
- If =k : a -> m b=, and =x : m a=, and =m= is an instance of =Monad=, then =k x= beta-reduces to =k =<< x=.

\[
f : a \to b , ~ x : m~a , ~ Functor~m \vdash (f~x \to_\beta fmap~f~x)
\]

Suppose =f : a -> b=, and =x : m (p a)=, and =m= is an instance of =Functor=, and =p= is an instance of =Functor=.

- The rule beta-reduces =f x= to =fmap f x=.
- Problem: The rule interferes with the =Functor= instance of =(->)=.
** Some tentative plans: Create a language that compiles to Haskell?
- [[https://github.com/bennofs/haskell-generate][bennofs/haskell-generate: Type-safe library for generating haskell source code]]
* Functional programming research?
Problem:
This chapter lacks a narrative.

Abbreviations:
- CPS: continuation-passing style
- FP: functional programming
- OS: operating system
- PFP: partial functional programming
- TFP: total functional programming
- TFPL: total functional programming language
- TM: Turing machine
** Why total functional programming?
- Can you sell me some TFP?
  - What is TFP?
    - TFP is functional programming with only total functions.
      - A function is total iff it is defined for every element of its domain.
    - TFP ensures that every function is total by constraining every recursion to be structural recursion.
      - Structural recursion is recursion with the constraint that every recursive call is syntactically smaller.
  - Why TFP?
    - The practical advantage of TFP is that it is easier
      (and therefore faster and less costly)
      to write provably correct programs in TFP
      compared to PFP or imperative programming.
      - This ultimately translates to faster time-to-market,
        lower development cost, fewer errors, fewer customer complaints, and higher customer satisfaction.
        (I know this sounds like bullshit. We should not underestimate the ways that humans can screw up.)
    - The theoretical advantage of TFP
      is that TFP has simpler denotational semantics compared to PFP
      because TFP has less bottoms to consider. [Turner2004]
  - Why not TFP?
    - A disadvantage of TFP is that it is not Turing-complete because all programs must terminate,
      but OSes don't terminate,
      but we can still write an OS in a TFPL using codata and corecursion [Turner2004]
      which are discussed in another section in this document.

[Turner2004] calls TFP "strong functional programming".
** Ramble
*You should not read anything below this point.*
These are the drafts of my drafts.
I think they should be included in this page,
but I haven't worked them enough.

- Why did Simon Peyton-Jones write that the next Haskell will be strict?
  - [[http://www.cs.nott.ac.uk/~gmh/appsem-slides/peytonjones.ppt][Simon Peyton-Jones PPT slides]].
  - [[https://news.ycombinator.com/item?id=1924061][ycombinator comment thread]].

This is a questionnaire, not survey article:
A preliminary survey of functional programming
Caitlin Sadowski
Daan Leijen
https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/paper-67.pdf

- How do these differ: Agda, Coq, Lean, Isabelle, ACL2, and others?
  - [[https://www.reddit.com/r/haskell/comments/3b498l/if_you_could_change_one_thing_about_haskell_what/csk2gvl/][Conor McBride's tangential opinions]]
    on Coq vs Agda vs others
  - [[http://wiki.portal.chalmers.se/agda/pmwiki.php?n=Main.AgdaVsCoq][Agda Wiki: Agda vs Coq]]
  - [[https://www.reddit.com/r/haskell/comments/30j9l6/lean_the_new_open_source_theorem_prover_developed/][/r/haskell: Lean: the new open source theorem prover developed at Microsoft Research]]
*** History of lambda calculus?
Alonzo Church introduced lambda calculus in 1932 in [Church1932].

Why did Church invent lambda calculus?
What was Church trying to do?

Notations have changed.
Church wrote $S_y^x U$ but we write $U[x := y]$ for the same thing:
the expression $U$ but with every occurrence of free variable $x$ replaced by expression $y$.

[Church1932] credits a 1924 publication of Moses Schönfinkel for what we call /currying/:
changing a multi-parameter function to a one-parameter function
returning another one-parameter function returning yet another one-parameter function, and so on.
Currying is changing $f : (a,b) \to c$ to $f' : a \to (b \to c)$ such that $f(x,y) = (f'(x))(y)$.

See: Dana Scott's lambda-calculus timeline[fn::https://turing100.acm.org/lambda_calculus_timeline.pdf].

See also: [[https://en.wikipedia.org/wiki/Lambda_calculus][Wikipedia: Lambda calculus]].
*** might be too old
- [Lof1984]
- 1986 A survey of functional programming language principles https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19870002073.pdf
*** Codata, corecursion, and coinduction
For more about codata, corecursion, and coinduction, see:
- [[http://www.cl.cam.ac.uk/archive/mjcg/plans/Coinduction.html]["Corecursion and coinduction: what they are and how they relate to recursion and induction", Mike Gordon]]:
  "My goal here is to try to understand these things through the activity of creating a simple explanation."
- [[http://blog.sigfpe.com/2007/07/data-and-codata.html]["Data and Codata", Dan Piponi]]:
  "The program might not terminate, but from a mathematical perspective this is a completely well defined function."
  "Note the duality: in structural recursion we 'deconstruct' the argument and then we're allowed to recurse. In guarded recursion we recurse first, and then we're allowed to use the constructor."
- [[https://www.tac-tics.net/blog/data-vs-codata]["Data vs Codata", Michael Maloney]]
*** Lazy, strict
- The Church-Rosser property
  ([[https://en.wikipedia.org/wiki/Church%E2%80%93Rosser_theorem][Wikipedia]],
  [[http://mathworld.wolfram.com/Church-RosserProperty.html][Mathworld]]),
  eliminates the difference between strict and lazy in a TFPL [Turner2004].
*** A type theory is a formal system, not a branch of mathematics
There are at least two type theories:
the Martin-Löf type theory, and the calculus of constructions [Bove2001].
I thought "type theory" was a branch of mathematics,
like "category theory", "graph theory", and "number theory".

"Martin-Löf's type theory is basically a theory about sets in which it is possible to interpret a logic." [Nordstrom1988]
*** Recursion and fixpoint
   :PROPERTIES:
   :CUSTOM_ID: recursion-and-fixpoint
   :END:

We say that $x$ is a /fixpoint/ of $f$ iff $x = f(x)$.

A [[https://www.cs.cornell.edu/courses/cs3110/2013sp/supplemental/lectures/lec29-fixpoints/lec29.html][text lecture]]
describes how to obtain the factorial function as a fixed point of successive /approximations/.

[[https://en.wikipedia.org/wiki/Fixed-point_combinator][Wikipedia: Fixed-point combinator]].
A fixed-point combinator enables /anonymous/ recursive functions.

TFP rejects the definition =fix f = f (fix f)= because this is not a structural recursion.

Recursion is about fixpoint.

*** The Eff language and monad-aware languages
   :PROPERTIES:
   :CUSTOM_ID: the-eff-language-and-monad-aware-languages
   :END:

Consider this passage from [McBride2015]:

#+BEGIN_QUOTE
  [The Eff language lets] us write in direct
  style for whatever effectful interface is locally available, then obtain the computation
  delivered by the appropriate Moggi-style translation into an explicitly monadic
  kernel.
#+END_QUOTE

I think "in direct style"
means that in Eff we can write =f x= to mean what we would write as =x >>= f= in Haskell,
but with the Monad instance automatically inferred based on the locally available effects.

I think that passage suggests that the Eff language [Bauer2012]
is related to the "monad-aware language" that Abdullah is trying to accomplish.
The relation is that Eff infers the monad from the locally available effects.
However, Eff's type system ignores the effects (like ML's type system)
so this is probably not what Abdullah wants.

*** Reading triage
   :PROPERTIES:
   :CUSTOM_ID: reading-triage
   :END:

http://semantic-domain.blogspot.co.id/2016/03/agda-is-not-purely-functional-language.html

https://en.wikipedia.org/wiki/Category:Term-rewriting_programming_languages

In a term-rewriting language such as Pure, we can write program transformation as part of the program.
https://stackoverflow.com/questions/24330902/how-does-term-rewriting-based-evaluation-work

https://www.quora.com/What-are-examples-of-statically-typed-logic-programming-languages-ex-similar-to-Prolog

https://mathoverflow.net/questions/3920/what-does-it-mean-to-discharge-assumptions-or-premises

http://www.cs.nott.ac.uk/~pszvc/g54dtp/inductive_domain.v

https://stackoverflow.com/questions/145263/what-is-total-functional-programming

What is a computational effect?

Does totality really have anything to do with termination?

*** TFP and Turing-completeness
   :PROPERTIES:
   :CUSTOM_ID: tfp-and-turing-completeness
   :END:

We must distinguish between a Turing machine and its execution.

A TM needs a tape to run, but does not come with it.
To run a TM, you have to supply a tape.

A /tape/ is a finite sequence of tape symbols.

A /step/ is a pair of configuration and tape.

A /run/ is a sequence of steps. This sequence may be infinite.

A /run/ of a Turing machine $m$ with initial tape $t$ is ...

Instead of thinking about infinitely long tape with infinitely many blank symbols,
we think that the tape is finite but the TM may at every step
insert, update, or delete a cell.

A TM is finite by definition: a TM is a tuple whose each component is taken from a finite set.
The description of a TM does not include the tape.
The execution trace of a TM may be infinite.
A TFPL can /describe/ every TM just fine.

We can describe a Turing machine in a TFPL?

https://www.reddit.com/r/programming/comments/jvu2w/total_functional_programming_and_the_unimportance/

[[http://lambda-the-ultimate.org/node/2003][LTU: Total functional programming]]

https://news.ycombinator.com/item?id=12646390

https://existentialtype.wordpress.com/2014/03/20/old-neglected-theorems-are-still-theorems/

https://math.stackexchange.com/questions/111773/are-total-recursive-functions-recursively-enumerable

How do we write this "echo" program in TFP? Is it even total?

#+BEGIN_SRC haskell
    main : IO ()
    main = getLine >>= putStrLn >> main
#+END_SRC

We can /describe/ the infinite list of natural numbers =[0,1,2,3,...]= in a TFP.

#+BEGIN_EXAMPLE
    f : Nat -> Nat
    f n = n + 1

    f : Nat -> Nat
    f n = n
#+END_EXAMPLE

[[https://arxiv.org/abs/1610.09254][Partiality, Revisited: The Partiality Monad as a Quotient Inductive-Inductive Type]]

http://www.cl.cam.ac.uk/archive/mjcg/plans/Coinduction.html

https://en.wikipedia.org/wiki/Natural_transformation

https://en.wikipedia.org/wiki/Initial_algebra
endofunctor, F-algebra, initial object

[[https://dtai.cs.kuleuven.be/problog/][probabilistic logic programming]]

*** Metaprogramming
Spoofax vs Xtext vs MPS?
http://www.metaborg.org/en/latest/
http://www.metaborg.org/en/latest/source/overview/examples.html

PEG (parsing expression grammar)

http://ttic.uchicago.edu/~dmcallester/foundations.pdf
https://en.wikipedia.org/wiki/Foundations_of_mathematics
https://web.stanford.edu/class/cs103/notes/Mathematical%20Foundations%20of%20Computing.pdf
https://github.com/hoplon/javelin
https://codon.com/consider-static-typing
*** Structured editor
   :PROPERTIES:
   :CUSTOM_ID: structured-editor
   :END:

https://news.ycombinator.com/item?id=13773813

https://www.reddit.com/r/programming/comments/1tp83j/lamdu_structuralast_editor/

*** Others
   :PROPERTIES:
   :CUSTOM_ID: others
   :END:

[[https://tio.run/#agda][Compile and run Agda programs online]].

*** Positive and negative positions, strict positivity
   :PROPERTIES:
   :CUSTOM_ID: positive-and-negative-positions-strict-positivity
   :END:

In the function type $A \to B$,
we say that $A$ occurs in a /negative/ position
and $B$ occurs in a /positive/ position.
See [[https://cs.stackexchange.com/questions/42150/meaning-of-positive-position-and-negative-position-in-type-theory][CS StackExchange 42150]].

For the /strict positivity/ constraint of a data type definition, see these:
[[https://cs.stackexchange.com/questions/55646/strict-positivity][CS StackExchange 55646]],
[[http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.SimpleInductiveTypes?from=ReferenceManual.Datatypes#Strictpositivity][Agda Wiki: Strict positivity]].

In a TFPL, there is no expression whose type is =forall a. a=.

#+BEGIN_EXAMPLE
    exit : IO a
#+END_EXAMPLE

*** Rewriting systems
   :PROPERTIES:
   :CUSTOM_ID: rewriting-systems
   :END:

A TFPL program is a terminating ARS.
https://en.m.wikipedia.org/wiki/Termination_(term_rewriting)

[[https://softoption.us/content/node/37][SoftOption: normal forms and termination]]

[[https://softoption.us/content/node/654][SoftOption: lambda calculus and combinatory logic]]

There are at least two widely used confluent term-rewriting systems:

- applicative, lambda calculus, beta-reduction
- concatenative, postfix notation, PostScript, Forth

An expression is in normal form iff there is no applicable rewrite rule.
See [[https://en.wikipedia.org/wiki/Normal_form_(abstract_rewriting)][Wikipedia: Normal form (abstract rewriting)]].

The following =hang= function is not total.
Why?

#+BEGIN_SRC haskell
    hang : Nat -> Nat
    hang x => hang x
#+END_SRC

The expression =hang x= can be rewritten to =hang x=, so =hang x= is not a normal form,
but this goes on forever, so =hang x= does not have a normal form, and thus =hang x= is not total.

This =loop= thing is not a function in the mathematical sense. Why is that?

#+BEGIN_EXAMPLE
    loop : a
    loop => loop
#+END_EXAMPLE

Consider this, where =exit= terminates the program.

#+BEGIN_SRC haskell
    what : Nat
    what => exit
#+END_SRC

The function =crash= also does not produce a =Nat=.

- What is Scott continuity?

  - Why is it named "continuity"?

https://cs.stackexchange.com/questions/1371/scott-continuous-functions-an-alternative-definition

Girard's System F
https://people.mpi-sws.org/~skilpat/plerg/papers/harper-system-f-2up.pdf
https://www.reddit.com/r/haskell/comments/2zqtfk/why_isnt_anyone_talking_about_optimal_lambda/

Venanzio Capretta's partiality monad
General recursion via coinductive types
[[http://www.cs.ru.nl/~venanzio/publications/Recursion_Coinductive_LMCS_2005.pdf][Venanzio Capretta 2005]]
"see the work by Barendregt
and Geuvers [5] for a good exposition of technical issues of type-theoretic proof assistants"
Coinductive types were first
introduced in type theory by Hagino [34]

[[https://cs.stackexchange.com/questions/19577/what-can-idris-not-do-by-giving-up-turing-completeness][StackOverflow: What can Idris not do by giving up Turing-completeness?]]:
"Dual to termination: while an inductive definition must terminate (by consuming all of its data) a coinductive definition must be productive - in practice this means, brieflt, that any recursive call must be guarded by a constructor. I've found this explanation to be the clearest (ymmv): adam.chlipala.net/cpdt/html/Coinductive.html" -- Edwin Brady Apr 22 '14 at 17:58

Dependent Types and Multi-monadic Effects in F⋆
https://www.fstar-lang.org/papers/mumon/paper.pdf

Type Systems, Luca Cardelli
http://lucacardelli.name/Papers/TypeSystems.pdf

[[https://www.cs.rit.edu/~mtf/student-resources/20094_voelker_msthesis.pdf][Karl Voelker master thesis: practical programming with total functions]]

[[https://www.cs.york.ac.uk/plasma/wiki/index.php?title=Functional_Programming#Theses][York CS wiki: FP researches]]

- Position papers

  - [[https://www.irif.fr/~mellies/mpri/mpri-ens/articles/hyland-power-lawvere-theories-and-monads.pdf][2007, Hyland & Power: "The Category Theoretic Understanding of
    Universal Algebra: Lawvere Theories and
    Monads"]]

- Should we read these?

  - 2015 Ralf Hinze, Nicolas Wu, Jeremy Gibbons: [[http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/conjugate-hylos.pdf][Conjugate Hylomorphisms Or: The Mother of All Structured Recursion Schemes]]
  - 2007 Colin John Morris Kemp PhD thesis [[https://pdfs.semanticscholar.org/21da/de9b8e96724265f911c90c0ddd935901a0f0.pdf][Theoretical foundations for practical "totally functional programming"]]
** Category theory and programming languages?
The section title needs a verb.
- Category-theoretic model of functional programming languages
  - Every functional programming language L can be modeled by a category C(L) whose objects are the types of L and arrows are the function expressions of L.
- categorical programming (what is this?)
  - 2000, PhD thesis, "Categorical programming with inductive and coinductive types" https://kodu.ut.ee/~varmo/papers/thesis.pdf
  - categorical programming language
    - 1993, article, "Comparing Hagino's categorical programming language and typed lambda-calculi" https://www.sciencedirect.com/science/article/pii/030439759390186W
    - 1987, PhD thesis, "Categorical programming language" http://web.sfc.keio.ac.jp/~hagino/thesis.pdf
      - "An interpreter of Hagino's Categorical Programming Language (CPL)." https://github.com/msakai/cpl
    - aggregators
      - 2009, https://mathoverflow.net/questions/3721/programming-languages-based-on-category-theory
      - https://softwareengineering.stackexchange.com/questions/216635/category-theory-based-language
- category theory applied to programming language theory
  - 2012, "Generic Programming with Adjunctions" http://www.cs.ox.ac.uk/ralf.hinze/LN.pdf
** Foundation of mathematics especially for programming?
- set theories, such as ZF, ZFC, NBG, etc.
  - https://math.stackexchange.com/questions/136215/difference-between-zfc-nbg
- type theories, such as Martin-Löf type theory
- logic?
- category theory?
- lambda calculus?
- https://cstheory.stackexchange.com/questions/27217/are-there-presentations-of-set-theory-in-terms-of-lambda-calculus
  - Grue's map theory, 1992
    - http://hjemmesider.diku.dk/~grue/
      - 1992, Grue, PhD thesis, [[http://hjemmesider.diku.dk/~grue/papers/Grue92/Grue92.pdf]["Map theory"]]
        - p. 130: "Equality is better than truth [...]" (How do we explain the context?)
          - https://en.wikipedia.org/wiki/Equational_logic
    - related?
      - equational programming
    - 2016 reformulation article "A synthetic axiomatization of Map Theory" [[https://hal.archives-ouvertes.fr/hal-00678410v3][pdf available]]
Can we formalize "a program is an executable formal system" using Grue's map theory?
- How is "false" represented?
- How is "true" represented?
- How is "conjunction" represented?
** Haskell strictness checker
- 2018 "Keep your laziness in check" https://dl.acm.org/citation.cfm?doid=3243631.3236797
  - "We introduce StrictCheck: a property-based random testing framework for observing, specifying, and testing the strictness of Haskell functions."
** <2018-09-12> question for Abdullah
Do you know of anything that computes (generates code for) the products/sums of data-types?
Do you know of any libraries that enable us to describe how to transform a data type to a related data type?
Do you know of anything resembling template metaprogramming for Haskell that is not Template Haskell?
For example:

#+BEGIN_EXAMPLE
    data A = A1 | A2
    data B = B1 | B2

    -- <input>
    generate data P = A * B
    generate data S = A + B
    -- </input>

    -- <output>
    data P  = P_A1_B1
            | P_A1_B2
            | P_A2_B1
            | P_A2_B2

    data S  = S_A1 | S_A2
            | S_B1 | S_B2
    -- </output>
#+END_EXAMPLE
** <2017-09-04> Scheme currying
  :PROPERTIES:
  :CUSTOM_ID: scheme-currying
  :END:

*** Abstract
   :PROPERTIES:
   :CUSTOM_ID: abstract
   :END:

We define the macros =lambda/c=, =apply/c=, and =define/c=,
which are curried analogs of =lambda=, =apply=, and =define=, respectively.
This way is simple,
but it uses macros
and it is limited to fixed-arity lambda expressions.

*** The idea
   :PROPERTIES:
   :CUSTOM_ID: the-idea
   :END:

The idea of =lambda/c= is this pattern:

#+BEGIN_EXAMPLE
    (lambda/c (a) z) => (lambda (a) z)
    (lambda/c (a b) z) => (lambda (a) (lambda (b) z))
    (lambda/c (a b c) z) => (lambda (a) (lambda (b) (lambda (c) z)))
    ...
#+END_EXAMPLE

The idea of =apply/c= is this pattern:

#+BEGIN_EXAMPLE
    (apply/c a b) => (a b)
    (apply/c a b c) => ((a b) c)
    (apply/c a b c d) => (((a b) c) d)
    ...
#+END_EXAMPLE

However, there is a difference:
=apply= is an arity-2 procedure taking a procedure and a list,
whereas =apply/c= is a macro that takes one or more arguments.

The idea of =define/c= is this parallel:

#+BEGIN_EXAMPLE
    (define (a b ... y) z) = (define a (lambda (b ... y) z))
    (define/c (a b ... y) z) = (define a (lambda/c (b ... y) z))
#+END_EXAMPLE

*** The code
   :PROPERTIES:
   :CUSTOM_ID: the-code
   :END:

I tried this code on Guile 2.0.9 on Ubuntu 14.04.

#+BEGIN_EXAMPLE
    (define-syntax lambda/c
        (syntax-rules ()
            (
                (_ (x) body ...)
                (lambda (x) body ...)
            )
            (
                (_ (x y ...) body ...)
                (lambda (x) (lambda/c (y ...) body ...))
            )
        )
    )

    (define-syntax apply/c
        (syntax-rules ()
            (
                (_ f)
                (f)
            )
            (
                (_ f x)
                (f x)
            )
            (
                (_ f x y ...)
                (apply/c (f x) y ...)
            )
        )
    )

    (define-syntax define/c
        (syntax-rules ()
            (
                (_ (f) body ...)
                (define f (lambda () body ...))
            )
            (
                (_ (f x ...) body ...)
                (define f (lambda/c (x ...) body ...))
            )
        )
    )
#+END_EXAMPLE

*** Example
   :PROPERTIES:
   :CUSTOM_ID: example
   :END:

After the above macros have been defined
(by copying them to your REPL, for example),
the following fragment should print three threes.

#+BEGIN_EXAMPLE
    (define f (lambda/c (x y) (+ x y)))
    (define g (lambda (x) (lambda (y) (+ x y))))
    (define/c (h x y) (+ x y))
    (apply/c f 1 2)
    (apply/c g 1 2)
    (apply/c h 1 2)
#+END_EXAMPLE
** <2018-04-07> Approximating general recursion in TFP
  :PROPERTIES:
  :CUSTOM_ID: approximating-general-recursion-in-tfp
  :END:

Here we are going to show how to approximate general recursive functions in TFP
with the help of the following =repeat= and =approx=:

#+BEGIN_SRC haskell
    -- The expression `repeat n f x` means
    -- `n` times of the application of `f` to `x`.
    repeat : Nat -> (a -> a) -> a -> a
    repeat 0 f = id
    repeat (n+1) f = repeat n f . f

    approx
        : Nat -- count
        -> (a -> s) -- begin
        -> (s -> s) -- step
        -> (s -> Maybe b) -- end
        -> (a -> Maybe b)

    approx count begin step end =
        end . repeat count step . begin
#+END_SRC

To approximate a general recursive function =f : a -> b=,
we write a data type =S_f= and these three non-recursive total functions:

#+BEGIN_SRC haskell
    begin_f : a -> S_f
    step_f : S_f -> S_f
    end_f : S_f -> Maybe b

    -- A side note:
    -- In PFP, the original `f` can be
    -- recovered from those three functions:
    f input = loop (begin_f input)
        where
            loop s = case end_f s of
                Just output -> output
                _ -> loop (step_f s)
#+END_SRC

Then, we can approximate =f= as =f_approx=:

#+BEGIN_SRC haskell
    f_approx : Nat -> (a -> Maybe b)
    f_approx count =
        approx count begin_f step_f end_f
#+END_SRC

The =count= parameter can be thought of as a time limit or time-out,
the number of iterations,
the number of steps.

Here is an example approximation of the factorial function.

#+BEGIN_SRC haskell
    fac 0 = 1
    fac n = n * fac (n-1)

    data State = Mk { n : Nat, a : Nat }

    fac_approx count =
        end . repeat count step . begin
        where
            begin : Nat -> State
            begin n = Mk n 1

            end : State -> Maybe Nat
            end (Mk 0 a) = Just a
            end _ = Nothing

            step : State -> State
            step (Mk 0 a) = Mk 0 a
            step (Mk (n+1) a) = Mk n (a * (n+1))
#+END_SRC

Here is an example approximation of bottom.

#+BEGIN_SRC haskell
    -- PFP

    hang : a
    hang = hang

    -- TFP approximation

    data State = Mk

    hang_begin _ = Mk
    hang_step s = s
    hang_end _ = Nothing

    hang_approx count =
        hang_end . repeat count hang_step . hang_begin
#+END_SRC

I conjecture that there is an algorithm that can transform every general recursive function into its begin-step-end form.

** what
- 2002, article collection, "Recent advances in Java technology: theory, application, implementation" http://www.cs.nuim.ie/~jpower/Research/Papers/2002/power-raijt-toc.pdf
- 1985, article, "Automatic synthesis of typed Λ-programs on term algebras" https://www.sciencedirect.com/science/article/pii/0304397585901355
- 2015, article, "Dynamically Composing Languages in a Modular Way: Supporting C Extensions for Dynamic Languages", [[https://chrisseaton.com/rubytruffle/modularity15/rubyextensions.pdf][pdf]]
- https://github.com/nim-lang/Nim
- 2016, article, "Towards Ontology-Based Program Analysis", [[http://drops.dagstuhl.de/opus/volltexte/2016/6120/pdf/LIPIcs-ECOOP-2016-26.pdf][pdf]]
  - Interesting conference title: "Conference on very important topics (CVIT)"
    - Is it real?
      Is it a secret society?
      Google doesn't seem to know about it.
- functional languages with explicit memory layout?
  functional languages for systems programming?
  - [[https://github.com/ollef/sixten][Sixten: Functional programming with fewer indirections]]
    - It also deals with representing algebraic data type inhabitants as bit patterns.
    - "Sixten is very related to other functional languages such as Haskell, Agda, and Idris.
      The biggest difference between other languages and Sixten is the way that Sixten allows us to control the memory layout of data."
    - [[https://gitter.im/sixten-lang/General?source=orgpage][Sixten, "General", Gitter, community chat]]
- 2017, article, [[https://arxiv.org/abs/1707.00024][A Formalized General Theory of Syntax with Bindings]]
- [[https://www.cs.cmu.edu/~mleone/language/projects.html][Programming Language and Compiler Research Groups]]
- [[http://www.pl-enthusiast.net/2014/07/10/ieee-posts-its-top-list-of-languages/][IEEE posts its top list of languages - The PL Enthusiast]]
- [[http://www.pl-enthusiast.net/2015/05/27/what-is-pl-research-and-how-is-it-useful/][What is PL research and how is it useful? - The PL Enthusiast]]
- 2014, article, [[https://arxiv.org/abs/1410.1776][Ontology-based Representation and Reasoning on Process Models: A Logic Programming Approach]]
- 1994, article, "Formalizing architectural connection", [[http://web.cs.wpi.edu/~cs562/s98/pdf/wright-icse16.pdf][pdf]]
- [[https://2015.splashcon.org/track/nool2015#event-overview][NOOL 2015 accepted papers - SPLASH 2015]] ("New Object Oriented Languages")
  - "Classes Considered Harmful", [[http://web.cecs.pdx.edu/~black/publications/ClassesHarmful.pdf][pdf]]
  - "Ubiquitous Object Orientation to Foster the Advancement of Programming Languages", [[http://www.cs.cmu.edu/~dkurilov/papers/nool15.pdf][pdf]]
- NOOL 2016 articles
  - "Nomen: A Dynamically Typed OO Programming Language, Transpiled to Java", [[http://www.it.uu.se/workshop/nool16/nool16-paper9.pdf][pdf]]
    - "Nomen is an experimental, dynamically typed OO programming language which compiles to Java source code."
    - "Nomen is designed as a language for experimenting with IDE support generation using the Rascal language workbench."
  - "The essence of subclassing", [[http://www.it.uu.se/workshop/nool16/nool16-paper5.pdf][pdf]]
  - "Towards Automatic Decoration", [[http://www.it.uu.se/workshop/nool16/nool16-paper2.pdf][pdf]]
  - syntax
    - "Polite Programmers, Use Spaces in Identifiers When Needed", [[http://www.it.uu.se/workshop/nool16/nool16-paper10.pdf][pdf]]
- [[https://en.wikipedia.org/wiki/Comparison_of_functional_programming_languages][WP:Comparison of functional programming languages]]
- Great Works in Programming Languages, Collected by Benjamin C. Pierce http://www.cis.upenn.edu/~bcpierce/courses/670Fall04/GreatWorksInPL.shtml
- to read? "theories of programming languages reynolds"
- 2017, book, "Principles of Programming Languages" https://www.cs.bgu.ac.il/~mira/ppl-book-full.pdf
- 2003, article, "Composing Programming Languages by Combining Action-Semantics Modules" http://www.brics.dk/RS/03/53/BRICS-RS-03-53.pdf
- 2001, position paper, "Composition Languages for Black-Box Components" http://scg.unibe.ch/archive/papers/Wuyt01c.pdf
- glue: Make better services. (deprecated) https://hackage.haskell.org/package/glue
- yet another music programming language https://github.com/alda-lang/alda
- linearscan: Linear scan register allocator, formally verified in Coq; 2004, master thesis, https://hackage.haskell.org/package/linearscan
- Lastik: A library for compiling programs in a variety of languages (Java, Scala, C#) https://hackage.haskell.org/package/Lastik
- risc386: Reduced instruction set i386 simulator https://hackage.haskell.org/package/risc386
- 2017, "Theorems for Free for Free", Wadler http://homepages.inf.ed.ac.uk/wadler/topics/blame.html
  - What is "polymorphic blame calculus"?
- https://idris.readthedocs.io/en/v1.3.0/faq/faq.html#what-are-the-differences-between-agda-and-idris
  - "Why does Idris use eager evaluation rather than lazy?"
    - "What is the representation of =thing= at run-time? Is it a bit pattern representing an integer, or is it a pointer to some code which will compute an integer? In Idris, we have decided that we would like to make this distinction precise [...]"
    - Idris has laziness, but you have to be explicit.
- https://en.wikipedia.org/wiki/Automatic_programming
- https://en.wikipedia.org/wiki/Program_synthesis
- https://www.cs.cmu.edu/~mleone/language-research.html
- "Confessions Of A Used Programming Language Salesman: Getting The Masses Hooked On Haskell", Erik Meijer, [[https://pdfs.semanticscholar.org/233a/932b3e94f1f117655e4862995b32f33754be.pdf][pdf]]
  - What are the key points?
- 1966, article, P. J. Landin, "The next 700 programming languages", [[https://www.cs.cmu.edu/~crary/819-f09/Landin66.pdf][pdf]]
  - https://en.wikipedia.org/wiki/Off-side_rule
- http://matt.might.net/articles/best-programming-languages/
- [[http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD641.PDF][EWD641: On the interplay between mathematics and programming]]
- http://hackage.haskell.org/package/Workflow
- https://pchiusano.github.io/2017-01-20/why-not-haskell.html
- http://unisonweb.org/2015-05-07/about.html#post-start
- [[https://github.com/facebook/duckling][facebook/duckling: Language, engine, and tooling for expressing, testing, and evaluating composable language rules on input strings.]]
- [[https://github.com/GaloisInc/crucible][GaloisInc/crucible: Crucible is a library for symbolic simulation of imperative programs]]
- 2009, "Domain-Specific Languages for Composable Editor Plugins"
  - [[https://pdfs.semanticscholar.org/presentation/85d8/bc42122ff5175be1ebc3c7b91e4abff55d22.pdf][2009 slides pdf]]
  - [[http://bora.uib.no/bitstream/handle/1956/9721/1-s2.0-S1571066110001179-main.pdf?sequence=1][2010 article pdf]]
- why not PEG parsing
  - http://jeffreykegler.github.io/Ocean-of-Awareness-blog/individual/2015/03/peg.html
- answer set programming
  - [[http://cs.aalto.fi/en/current/news/2018-07-18/][News: Speed up solving complex problems: be lazy and only work crucial tasks - Aalto University]]
    - 2018, article, "Exploiting Justifications for Lazy Grounding of Answer Set Programs", [[https://www.ijcai.org/proceedings/2018/0240.pdf][pdf]]
- [[https://brianmckenna.org/blog/idris_library][Idris as a Library - BAM Weblog]]
  - Idris as compiler backend
- Prolog ontology?
  - What is the relationship between Prolog, logic programming, ontology, and relational databases?
    - [[https://stackoverflow.com/questions/29062541/what-are-ontology-can-do-but-relational-database-can-not][What are ontology can do, but relational database can not? - Stack Overflow]]
      - [[https://www.slideshare.net/UscholdM/ontologies-and-db-schema-whats-the-difference][Ontologies and DB Schema: What's the Difference?]]
      - 2011, article, "Ontologies versus relational databases: Are they so different? A comparison", [[https://www.researchgate.net/publication/251332115_Ontologies_versus_relational_databases_Are_they_so_different_A_comparison][pdf available]]
      - 2010, article, "Mapping between Relational Databases and OWL Ontologies: an example", [[https://www.lu.lv/materiali/apgads/raksti/756_pp_99-117.pdf][pdf]]
  - [[http://sujitpal.blogspot.com/2009/06/ontology-rules-with-prolog.html][Salmon Run: Ontology Rules with Prolog]]
  - [[http://www.swi-prolog.org/web/][SWI-Prolog for the (semantic) web]]
- [[https://pchiusano.github.io/2017-01-20/why-not-haskell.html][Paul Chiusano: If Haskell is so great, why hasn't it taken over the world? And the curious case of Go.]]
  - Unison programming language
- Elixir has gradual static typing via Erlang Dialyzer.
  - [[https://elixir-lang.org/getting-started/typespecs-and-behaviours.html][Typespecs and behaviours - Elixir]]
  - [Understanding Elixir Types - via @codeship](https://blog.codeship.com/understanding-elixir-types/)
    - "Elixir functions are set up so that they can transparently be called across processes, heaps, or even machines in a cluster."
    - Can BEAM/Erlang/Elixir do live process migration?
  - The catch?
    - [[https://elixirforum.com/t/typed-elixir/1388][Typed Elixir - Elixir Chat - Elixir Forum]]
      - Is Dialyzer slow?
        - "My motivation for this is 95% of my bugs in Elixir/Erlang are due to using types wrong,
          like I may slightly change a tuple format somewhere but do not update it elsewhere
          and dialyzer does not catch it because the prior library state was in its cache that I then need to rebuild,
          in addition to dialyzer can take a long time to run."
- John Hughes, "Deriving combinator implementations", lecture 4, "Designing and using combinators" http://www.cse.chalmers.se/~rjmh/Combinators/DerivingCombinators/sld001.htm
- http://matt.might.net/articles/best-programming-languages/
- http://matt.might.net/articles/compiling-to-java/
- other programming languages
  - https://en.wikipedia.org/wiki/Curry_(programming_language)
  - http://fsl.cs.illinois.edu/images/5/5e/Cayenne.pdf
- [[https://github.com/edom/work/blob/master/meta/doc/extension.md][Extension programming language?]]
- https://en.wikipedia.org/wiki/Higher-order_abstract_syntax
- http://www.stephendiehl.com/posts/haskell_2017.html
- Haskell library: yaml vs HsYaml
  - https://twitter.com/hvrgnu/status/1004136566984503297
    - HsYaml is pure Haskell (doesn't use external libraries)
- [[https://www.cl.cam.ac.uk/~jrh13/slides/manchester-12sep01/slides.pdf][LCF key ideas]]
- closed source?
  - given SQL database, generate HTML user interface http://datanovata.com/
- http://libcello.org
- C HTTP server library?
  - https://kore.io
  - http://facil.io
- Possible user questions
  - How do I write software with this?
  - What are the important types?
- Don't format source code manually.
  - https://github.com/google/google-java-format
- related software
  - refactoring tools
    - https://github.com/RefactoringTools/HaRe
    - https://hackage.haskell.org/package/haskell-tools-refactor
  - parsing without symbol solving
    - Haskell and GHC extensions
      - http://hackage.haskell.org/package/haskell-src-exts
    - Haskell 98 only
      - https://hackage.haskell.org/package/haskell-src
    - Java
      - http://hackage.haskell.org/package/language-java
  - unknown
    - http://hackage.haskell.org/package/haskell-tools-ast
  - multi-database/cross-database query
    - http://www.unityjdbc.com/doc/multiple/multiplequery.php
    - https://www.red-gate.com/simple-talk/dotnet/net-tools/a-unified-approach-to-multi-database-query-templates/
  - similar systems
    - ERP libraries?
      - Meta is similar to Apache Ofbiz.
        - Some differences:
          - To define entities, Meta uses Haskell, Ofbiz uses XML.
          - Meta is written in Haskell, Ofbiz is written in Java.
        - https://cwiki.apache.org/confluence/display/OFBIZ/OFBiz+Tutorial+-+A+Beginners+Development+Guide
    - Web frameworks? Scaffolders?
      - Meta is similar to Laravel.
        - https://www.quora.com/Is-Laravel-a-good-framewok-really
      - Meta is similar to Ruby on Rails.
    - PhD theses
      - [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.422.5683&rep=rep1&type=pdf]["Programming Language Features for Web Application Development", Ezra Cooper]]
        - "Links" programming language
- For JDBC URL see
  - https://jdbc.postgresql.org/documentation/80/connect.html
- similar
  - https://medium.com/airbnb-engineering/react-native-at-airbnb-f95aa460be1c
- some requirement?
  - https://en.wikipedia.org/wiki/Multitenancy
- Name?
  - HUMPS Haskell Universal Meta Programming System ?
  - Hemps: Haskell Meta Programming System
  - EAG: Enterprise Application Generator
  - HAG: Haskell Application Generator
- https://en.wikipedia.org/wiki/Language-independent_specification
- sublanguages?
  - Ontology definition language
  - Data definition language
  - Web application description language
    - View description language
- software design
  - functional programming software design
    - designing combinators
      - Hughes 1995 doc [[http://belle.sourceforge.net/doc/hughes95design.pdf][The design of a pretty-printing library]]
- [[http://lambda-the-ultimate.org/node/5292][LTU:progress on gradual typing]]
- [[https://en.wikipedia.org/wiki/%CE%9BProlog][WP:lambda-prolog]]
- Should we use Haskell or TypeScript for this project? Both? Neither?
  - Killer features
    - IDE: TypeScript wins (VS Code).
    - custom infix operators: Haskell wins.
      - We can go even wilder with Agda, Coq, Idris, Lean, etc.
    - untagged unions: TypeScript wins.
    - software diversity: TypeScript wins.
      - TypeScript works with nodejs and npm. Boatloads of software.
      - I think TypeScript has more developers.
    - laziness
      - Haskell wins.
  - Both have
    - ADTs.
** Programming language theory
https://en.wikipedia.org/wiki/Programming_language_theory
* TODO Fix this incoherent Java ramble; don't read
** What
- Make it work
- Make it maintainable
- Make it efficient (only if needed)
- Make it reusable (only if there is demand)
- You Are Not Gonna Need It until proven otherwise, but this does not mean you do not need to anticipate.
- There are many ways to write code that do the same thing. Prefer the way that is the easiest to read and change and needs the least maintenance.
- Don't write getters and setters. Move the computation into the class, or use public fields.
- Corollary: Use public fields for your DTOs (or move the computation there). http://stackoverflow.com/questions/10240372/jackson-field-based-serialization
- Make value classes have final fields and a constructor.
- Use Java wisely ("Object-assisted procedural programming").
  https://www.quora.com/In-Object-Oriented-design-are-void-methods-bad
- OBPP ("Object-based procedural programming"), term coined by Peter DiSalvo.
- Java is not OOP; Java is OBPP.

The Java language is the C language with automatic memory management and without preprocessor.

C:

#+BEGIN_SRC C
    /* file MyClass.h */

    #ifdef _MyClass_h_INCLUDED_
    #define _MyClass_h_INCLUDED_

    struct _MyClass;
    typedef struct _MyClass MyClass;

    MyClass* MyClass_new ();

    int MyClass_myMethod (MyClass* this, Arg* arg);

    #endif


    /* file MyClass.c */

    #include <MyClass.h>

    static const int ONE = 1;

    struct _MyClass {
        int myField;
    };

    MyClass* MyClass_new () {
        const int size = sizeof(MyClass);
        MyClass* this = malloc(size);
        memset(this, 0, size);
        return this;
    }

    int MyClass_myMethod (MyClass* this, Arg* arg) {
        this->myField = ONE + Arg_getField(arg);
        return ONE;
    }
#+END_SRC

Java:

#+BEGIN_SRC java
    /* file MyClass.java */
    class MyClass {
        private static final int ONE = 1;
        private int myMethod (Arg arg) {
            this.myField = ONE + arg.getField();
            return ONE;
        }
    }
#+END_SRC

The essence is the same, but Java reduces the accidental complexity.

Method chaining vs fluent
Method chaining transforms the dot (method invocation) into semicolon (sequence point).

Fluent is embedded DSL.

- Don't use TestNG's @Test for SomethingExample?
  Write a main method in a SomethingExample class instead?
- Other stuffs https://github.com/jhalterman/failsafe
- http://blog.ploeh.dk/2014/03/10/solid-the-next-step-is-functional/
- http://martinfowler.com/bliki/RoleInterface.html
- http://blog.ploeh.dk/2011/06/07/SOLIDCodeisnt/
- https://www.jetbrains.com/help/idea/2016.2/code-inspection.html
- object is closure; closure is object
- LLVM is procedural core.
** Candidate solution: source-to-source translation
** Candidate solution: binary interoperability
Translate Java class to LLVM IR.

Translate Haskell to LLVM IR.

Translate C to LLVM IR.

Java has JNI.

Constraints:

- ABI-compatible with JNI:
  JNI C libraries works without recompilation.

Foreign.

What's wrong:
I want to edit the syntax tree.
I don't care about spacing.

The name is /structural editor/.
projectional editor.

https://www.facebook.com/notes/kent-beck/prune-a-code-editor-that-is-not-a-text-editor/1012061842160013/

http://www.lamdu.org/

http://projectured.org/
** Improving the Java language
Too much software is written in Java.

Xtend

Kotlin

IDE support

Top-level methods.
** Metaprogramming
#+BEGIN_EXAMPLE java
{% raw %}
    msg = "Hello";
    c = Class.new;
    c += {{ int foo; }};
    c += {{
        void sayHello ()
        {
            System.out.println($msg);
        }
    }};
{% endraw %}
#+END_EXAMPLE
** Old
This is my opinion on how to best use Java.

Java, when used properly, should not be more verbose than C.
*Java should be thought of as enhanced C*.
It adds these features:

- namespacing
- garbage collection
- exception
- limited functional programming
- reflection (should be documented thoroughly when used)

and it removes these features:

- preprocessor
- separate header files

Java sucks least when used as a *mainly procedural* programming language.

Subclassing, public fields, getters, setters, statics,
mutability, and big classes are not evil in and of themselves.
What is evil is /writing code without understanding *why* you write it that way/.
The key to good programming is understanding why the code is the way it is.

With documentation, understanding data is easier than understanding control flow.

*A maintenance engineer translates requirement changes to software changes.*
Software consists of program code, database schema, documentation, and so on.
A software is maintainable iff a reasonable requirement change translates to a reasonable software change.

For example, an application may now have to handle ten times the traffic it was designed for.

If, in 10 years, your application will never handle more than 10 requests per second,
but you split your application into 10 JVMs communicating with JSON-RPC,
you're wasting too many resources.
** Example of namespacing
This is a module in C.
Note that each procedure name is prefixed with =point_=.

#+BEGIN_SRC C
    #include <math.h>

    typedef struct
    {
        double x;
        double y;
    }
    Point;

    void point_init (Point* self, double x, double y)
    {
        self->x = x;
        self->y = y;
    }

    double point_distance (Point* a, Point* b)
    {
        return sqrt(square(b->x - a->x) + square(b->y - a->y));
    }

    static double square (double x)
    {
        return x * x;
    }
#+END_SRC

This is the module in Java.
Note that now you don't have to prefix your method names with =point_=
because it already lives in the class =Point=.

#+BEGIN_SRC java
    package com.example;

    final class Point
    {
        final double x;
        final double y;

        Point (double x, double y)
        {
            this.x = x;
            this.y = y;
        }

        double distance (Point that)
        {
            return distance(this, that);
        }

        static double distance (Point a, Point b)
        {
            return Math.sqrt(square(b.x - a.x) + square(b.y - a.y));
        }

        private static double square (double x)
        {
            return x * x;
        }
    }
#+END_SRC
** Another example
#+BEGIN_SRC java
    class Exchange
    {
        final HttpServletRequest request;
        final HttpServletResponse response;
    }
#+END_SRC
** Mixin
Use extend or mixin if and only if
you want all subclasses to benefit from enhancements of the base class.

A tradeoff is that =unsafeSetHp= is public.

#+BEGIN_SRC java
    interface GameObject
    {
        long getId ();
    }

    interface Health
    {
        int getMaxHp ();
        int getHp ();
        void unsafeSetHp (int x);
        default void setHp (int x)
        {
            final int maxHp = getMaxHp();
            if (x < 0) { setHp(0); return; }
            if (x >= maxHp) { setHp(maxHp); return; }
            setHp(x);
        }
        default boolean isDead ()
        {
            return getHp() <= 0;
        }
        default void addHp (int x)
        {
            setHp(getHp() + x);
        }
    }

    class Chara implements GameObject, Health
    {
        final long id;

        int maxHp;
        int hp;

        Chara (long id, int maxHp)
        {
            this.id = id;
            this.maxHp = maxHp;
            this.hp = maxHp;
        }

        @Override public long getId () { return id; }
        @Override public int getMaxHp () { return maxHp; }
        @Override public int getHp () { return hp; }
        @Override public void unsafeSetHp (int x) { this.hp = x; }
    }
#+END_SRC
** Unrelated
Field stores data.
Method does work.
Classes groups fields and methods.

/A class groups methods that share parameters./
The fields are those shared parameters.

A Java class is equivalent to a C struct and the functions whose first parameter is that struct.
In C, those things are usually grouped into one C file,
so a Java class is practically equivalent to a C file.
Static field in Java is global variable in C,
but without the name conflict.

C =#include= translates to Java =import=, =extends=, and =implements=.
=implements X= imports X's default methods into this module.
=extends X= imports X's fields and methods into this module.
=import static= imports X's static methods into this module.

Java 8 interfaces can be used as mixins.
Use default methods.

A mixin is a contract
"if you give me X, I'll give you Y."

Every method is a contract:
If you give me X, I'll give you Y.

Getters and setters provide "lazy fields" and "computed fields".

Java can be used with edit-compile-reload-refresh.
Java can hotswap.

IDE makes navigation easy.

A class is an instantiable module.

The aim is to maximize understandability and minimize duplication.
Sometimes, reducing duplication makes the code incomprehensible.

=a.b(c)= is a syntactic sugar for =b(a,c)=.
Implicit first argument.

Exception is structured goto.

https://www.reddit.com/r/learnprogramming/comments/1f0g2b/eli5_the_main_differences_between_oop_and/

https://www.reddit.com/r/learnprogramming/comments/tocjf/procedural_programmer_me_needs_help_making_the_oo/
** Can process fix incompetent people?
** Java-Haskell interoperation
https://wiki.haskell.org/GHC/FAQ

https://wiki.haskell.org/HaskellImplementorsWorkshop/2016
*** State of the art
LLJVM?

https://github.com/Frege/frege
Haskell-like language

http://eta-lang.org/
port GHC primitives to Java?

Sorted from the most desirable (highest level):

- Source-to-source translation.

  - Write a Java source interpreter in Haskell.
  - Map Haskell code to Java.

Write a JVM in Haskell.

Translate both Java and Haskell to a common lower-level language such as LLVM.

Core-to-bytecode.

JNI-to-FFI.
** Haskell-to-Java
http://mmhelloworld.github.io/blog/2013/07/10/frege-hello-java/

The Frege language.
The Eta language.

Haskell => Java?

Core => Java?

Module => Class

Data type => Static inner class

Value => instance of =Thunk=

Data constructor => Class extending the class corresponding to the data type

A value definition in a module => a static final Thunk field in the class

A class => A class

A member of a class => An instance field of the Class; the type of the field is =Thunk=

A class constraint => A dictionary argument whose type is the class

Case match => if instanceof

#+BEGIN_SRC java
    interface Thunk
    {
        Object force ();
        Thunk apply (Thunk x);
    }

    class Atom
    {
        Object value;
        Supplier x;
        Atom (Supplier x) { this.x = x; }
        Object force ()
        {
            if (value == null) { value = x.get(); }
            return value;
        }
    }
#+END_SRC

#+BEGIN_SRC haskell
    module M where

    a :: Int
    a = 1

    f :: Int -> Int
    f x = x + 1

    g :: (a -> b) -> a -> b
    g f x = f x
#+END_SRC

Map =Int= and =Int32= to a =Thunk= producing a =java.lang.Integer=.
A Haskell program assumes that =Int= is a two's complement signed integer
/at least/ 30 bits wide.

#+BEGIN_SRC haskell
    class M
    {
        static final Thunk a = new Atom(() -> 1);
        static final Thunk f = new Lambda(x -> (Integer) x + 1);
        static final Thunk g = new Lambda(f -> new Lambda(x -> f.apply(x)));
    }
#+END_SRC
*** Java-to-Haskell
https://github.com/Frege/frege/wiki/Calling-Frege-Code-from-Java

Java method -> foreign import

#+BEGIN_SRC haskell
    -- Foreign.Java

    data JByte
    data JInt
    data JShort
    data JLong
    data JObject

    foreign import java package.Class Method :: ArgType0 ArgType1 ... as haskellName

    foreign import java java.lang.Integer parseInt :: String -> Int32 as jParseInt
#+END_SRC

Message-passing view of Java objects

#+BEGIN_SRC haskell
    s <- call object "toString" []

    ...

    jls <- getClass "java.lang.System"
    out <- getField jls "out"
    call out "println" ["Hello world"]
#+END_SRC
** Architecture
Every Java program is a sequence of statements.

Every Java program is equivalent to one long main class?

A block is a sequence of statements.

#+BEGIN_EXAMPLE
    class Name
        int prop
        // Generates:
        // int prop
        // int getProp ()
        // void setProp (int)
    end
#+END_EXAMPLE
** Understanding factoring
Imagine writing your program as one long main method.
It is almost certain that you will find duplicate blocks.

Two duplicate blocks can be factored into a method.
Two methods with the same parameters can be factored into a class.

What is an optimal factoring of that program?
The factoring is wrong iff the same change needs to be performed more than once.
A program can also suffer from modification anomaly.

There are prime fragments:
fragments that cannot be factored into smaller parts.
** OOP as a special case of FP
Object and closure are equivalent.

=o.m(a0,a1,...) -> m o a0 a1 ...=
** Functional multimethod
Statically checked.

#+BEGIN_EXAMPLE
    collide (a : Asteroid) (b : Asteroid) = ...
    collide (a : Asteroid) (s : Spaceship) = ...
    collide (s : Spaceship) (a : Asteroid) = collide a s
    collide (s : Spaceship) (t : Spaceship) = ...

    True : Bool.

    False : Bool.

    Ord Bool.

    Bool x, Bool y |-
        Equal x y =
            match x y in
                False False -> True;;
                True True -> True;;
                _ _ -> False.

    LessThan False False = False.
    LessThan False True = True.
    LessThan True False = False.
    LessThan True True = False.

    IfElse False t f = f.
    IfElse True t f = t.

    And False x = False.
    And True x = x.

    Or False x = x.
    Or True x = True.

    Not False = True.
    Not True = False.

    Min x y = IfElse (LessThan x y) x y.
    Max x y = IfElse (LessThan x y) y x.

    Table Employee.

    Column Id Employee |- Bigint Id.
    Column Name Employee |- String Name.

    Column name Employee, type name |- Read name From resultSet = Get type name From resultSet.

    Column name Employee |-
        Member
            (Tuple name (Read name From resultSet))
            (Read Employee From resultSet).

    Main |-
        source = Connect "jdbc:postgresql://127.0.0.1/test",
        resultSet = ExecuteQuery source "SELECT * FROM employee",
        Member tuple (Read Employee From resultSet),
        Print tuple.

    ?- Main.

    Ord a, Ord b |- min a b = if lt a b then a else b

    a : Asteroid, b : Asteroid |- collide a b = ...
    IF
        a, b : Asteroid
        AND
        s, t : Spaceship
    THEN
        collide a b = ...
        collide a s = ...
        collide s t = ...

    define multimethod collide with parameters
        a, b : Asteroid
        s, t : Spaceship
    where case parameters matching
        a b -> ...
        a s -> ...
        s a -> ...
        s t -> ...
#+END_EXAMPLE
** Java
=a.m(b)= and =m(a,b)= are equivalent.
The dot is a syntactic sugar for implicit first argument, plus virtual dispatch.

The changes that must be made to implement a feature.
The program is well-factored if no change is duplicated.

A maintainable software does not have to be object-oriented, but it has to be well-factored.
A well-factored program /prevents the same modification from being duplicated./

Factorization reduces information duplication.

Depending on dependable things simplify your program.
I know someone who used a SQL database but didn't want to depend on it,
so he wrote application-level joins everywhere.

A software is maintainable iff it is simple to change.
Being able to start, stop, and restart quickly (in just a few seconds) also helps.
*** SQL
Mutable fields.

#+BEGIN_EXAMPLE
    Column a
        name : String
        read : a -> ResultSet -> ()
        write : ResultSet -> a -> ()

    Table a = [Column a]

    read : Table a -> a -> ResultSet -> ()
    write : Table a -> ResultSet -> a -> ()

    interface SqlCallable2<A, B>
    {
        void call (A a, B b) throws SQLException;
    }

    class Column<E>
    {
        String name;
        SqlCallable2<E, ResultSet> read;
        SqlCallable2<ResultSet, E> write;
    }
#+END_EXAMPLE
*** Annoyances of local variables
- Java can't infer the type of local variables
- Local variables aren't final by default

#+BEGIN_SRC java
    final Something something = new Something();
#+END_SRC
*** Example of under-factored program
#+BEGIN_SRC java
    class Employee
    {
        List<A> getById (long id)
        {
            ... "SELECT * FROM my_schema.employee WHERE id = ?" ...
        }

        List<A> getByName (String name)
        {
            ... "SELECT * FROM my_schema.employee WHERE name = ?" ...
        }
    }
#+END_SRC

What if =my_schema= or =employee= change?

#+BEGIN_SRC java
    class Employee
    {
        private static String TABLE = "my_schema.employee";

        List<A> getById (long id)
        {
            ... "SELECT * FROM " + TABLE + " WHERE id = ?" ...
        }

        List<A> getByName (String name)
        {
            ... "SELECT * FROM " + TABLE + " WHERE name = ?" ...
        }
    }
#+END_SRC

What if SQL syntax changes; for example, what if a committee decides to change SQL =SELECT= to =CHOOSE=?
We assume it's unlikely,
so we don't design our program to anticipate that.
** Extract covariant expressions into variables
#+BEGIN_SRC java
    System.out.println("John's salary is " + employee.computeSalary());
    if (employee.computeSalary() >= 1000)
    {
        System.out.println("It's over one thousand");
    }
#+END_SRC

What if =employee.computeSalary= changes?

#+BEGIN_SRC java
    final long salary = employee.computeSalary();
    System.out.println("John's salary is " + salary);
    if (salary >= 1000)
    {
        System.out.println("It's over one thousand");
    }
#+END_SRC

What if we want to print to =aPrintStream= instead of =System.out=?

#+BEGIN_SRC java
    final long salary = employee.computeSalary();
    final StringBuilder message = new StringBuilder();
    message.append("John's salary is ").append(salary).append('\n')
        .append(salary >= 1000 ? "It's over one thousand" : "");
    aPrintStream.println(message);
#+END_SRC

What if =salary= type changes from =long= to =BigInteger=?
We assume it's unlikely.
** Extract covariant blocks into method
Two blocks that must change together.

#+BEGIN_SRC java
    static Y m (A a, B b, ...);
#+END_SRC

#+BEGIN_SRC java
    static Y m0 (X0 x0, X1 x1, ...);
    static Y m1 (X0 x0, X2 x2, ...);
#+END_SRC

becomes

#+BEGIN_SRC java
    class C
    {
        X0 x0;
        Y m0 (X1 x1, ...);
        Y m1 (X2 x2, ...);
    }
#+END_SRC

Things that change together should be grouped together.

Constructors are methods too.

If two methods share a common parameter, the parameter can be extracted into a field.

If two classes share a common field, a class can be extracted.

Static methods are reusable.

Instance methods force you to instantiate the class.
** Implications of architecture on security
A popular trend: split front-end and back-end.
Write front-end in NodeJS, write back-end in Java, front-end calls back-end via JSON HTTP API.
Front-end runs on visitors' browsers.
Back-end is open to public.

You cannot secure the application.
If you cannot secure the hardware running the software,
all bets are off.
*** Foo
Java is a procedural programming language.

The only reason we don't write everything in one big method is maintainability.

A code is easier to understand if it doesn't mix abstraction levels.

Names relate to things the reader already knows.

Java does not have C#'s extension methods.

Java as procedural programming with implicit first argument.

#+BEGIN_EXAMPLE
    object.method(arg1, ...) = method(object, arg1, ...)
#+END_EXAMPLE

Principles make decision-making easy (not necessarily correct).
Principles are heuristics.

/Cohesion/ is the most important characteristic of a class.
The purpose of a class is to group a /working set/ (variables that often change together),
and the methods that use those variables.

The risk of modifying code?

The larger the change, the bigger the risk.

If you are using object mapper like Jackson,
changing a field to final can break your code.
(You must annotate.)
That's why I avoid reflection.

Microrefactoring.
Small steps.

Abstraction is not a mere indirection. yegor256???
Abstraction allows you to say a lot with a little code.
** Mitigating the risk of changing code
Don't just change old code.

Write new code that works with the old code.
Deprecate the old code.
Delete the old code.

#+BEGIN_SRC java
    class CustomList<T>
    {
        private final List<T> inner;

        public CustomList (List<T> inner)
        {
            this.inner = inner;
        }

        public static <T> CustomList<T> fromArray (T[] array)
        {
            final List<T> list = new ArrayList<>();
            list.addAll(Arrays.asList(array));
            return new CustomList<>(list);
        }

        public List<T> toList ()
        {
            return inner;
        }

        // Implement your primitives like size, map, whatever.
    }
#+END_SRC
** Maintainable code
The problem is working with too many details at once.

Mixing HTTP-handling code (such as the Servlet API 3.0)
with your business logic will cause readability problem.
If a method contains getCookie and business logic,
you're in for maintenance problems.

Java is more verbose than Haskell,
but it doesn't mean that you can't create maintainable Java programs;
it doesn't mean that your Haskell programs will automatically be more maintainable.
If you suck, your code will be just as bad.

Java is a /procedural/ language.
Problems begin when people try to force object-oriented paradigm to Java.

#+BEGIN_SRC java
    interface Log
    {
        void info (String message);
        void warn (String message);
        void error (String message);
    }
#+END_SRC

#+BEGIN_SRC java
    class Log_log4j implements Log
    {
        private final Logger log;
        public Log_log4j (Logger log)
        {
            this.log = log;
        }
        @Override public void error (String message) { log.error(message); }
    }
#+END_SRC
** Writing program backwards
If you're a shop, you can try putting all your pricing logic into one class:

- Every buyer whose age is 60 years or greater gets a 10% elder discount.
- Every buyer (unique phone number) is a first-time buyer (who has not bought anything) gets 10% newcomer discount.
- For simplicity, discount percentages are added before applied to the original price.

#+BEGIN_SRC java
    double percent_discount ()
    {
        double percentage = 0;
        if (buyer_age >= 60) { percentage += 10; }
        if (buyer_is_first_time) { percentage += 10; }
        return percentage;
    }
#+END_SRC

At this point you don't care about how to compute buyer_age and buyer_is_first_time.
You simply want to express the pricing rules as a simple Java code that a programmer can easily understand.

To compute the buyer's age, we need his/her date of birth and today's date.
Use JodaTime.

#+BEGIN_SRC java
    buyer_age = today.subtract(buyer_birth_date);
#+END_SRC

Then we need to figure out how to get today's date, and so on, and then you arrive at this method:

If you need something in a method,
but it's not that method's responsibility to compute it,
then it should be a parameter of that method.

#+BEGIN_SRC java
    class Pricing
    {

        void rule ()
        {
            // XXX dont use double for your prices?

            entry(item.name, item.price);

            if (event.is_giveaway)
            {
                discount(s.giveaway(), item.price);
                return;
            }

            if (buyer.age >= 60) { discount(s.elder(), 1); }
            if (buyer.is_first_time) { discount(s.first_timer(), 1); }
            if (buyer.wants_insurance) { surcharge(s.insurance(), 1); }

            if (event.is_new_year) { discount(s.new_year(), 1); }
            if (event.is_christmas) { discount(s.christmas(), 2); }
            if (event.is_online_shopping_day) { discount(s.online_shopping_day(), 0.25 * item.price); }

            if (item.is_rare) { surcharge(s.rare(), 10); }
            if (item.is_luxury) { surcharge(s.luxury(), 5); }
            if (item.is_from_lion_air) { surcharge(s.lion_air_admin_fee(), 10); }
            if (item.is_from_telkomsel) { surcharge(s.telkomsel_admin_fee(), 0.15); }

            if (payment.uses_credit_card) { surcharge(s.credit_card_fee(), 0.03 * item.price); }

            surcharge(s.surcharge_vat(), 0.1 * item.price);
        }

        class Buyer
        {
            final int age;
            final boolean is_first_time;
            final boolean wants_insurance;
        }

        class Entry
        {
            final String label;
            final double amount;
        }

        private final Strings.I s;
        private final List<Entry> entries = new ArrayList<>();

        private void entry (String label, double amount)
        {
            entries.add(new Entry(label, amount));
        }

        private void surcharge (String label, double amount)
        {
            entry(label, amount);
        }

        private void discount (String label, double amount)
        {
            entry(label, -amount);
        }

    }
#+END_SRC

There you have it: a straightforward, readable, maintainable, easily changeable pricing rule for your online business.
A straightforward translation.

Filling the fields is someone else's problem.

Internationalization:

#+BEGIN_SRC java
    class Strings
    {
        interface I
        {
            /** Value-added tax. */
            String elder ();
            String vat ();
        }
        class English implements I
        {
            @Override public String elder () { return "elder"; }
            @Override public String vat () { return "VAT"; }
        }
        class Indonesia implements I
        {
            @Override public String elder () { return "lansia"; }
            @Override public String vat () { return "PPn"; }
        }
        static load (String path) throws IOException
        {
            // use Proxy to lookup table
        }
    }
#+END_SRC

Do you need to be able to change the discounts without recompiling the program?
You don't.
Instead of making it configurable, make compilation and deployment fast, easy, and automatic, and just recompile.
There is less room for mistakes if you keep it in one place that is easy to see: the source code.
The compiler will also help catch mistakes.

Now you figure out how to compute buyer_age.

The name of a class doesn't have to be a noun.

A constructor parameter states that the class depends on a feature.

A class describes a feature.

#+BEGIN_SRC java
    interface Storage
    {
        void save_user (???) throws IOException;
    }
#+END_SRC

#+BEGIN_SRC java
    interface Handler?
    {
        void get_cookie ();
        Handler set_cookie ();
        Handler set_cookie ();
    }
#+END_SRC

A Java class corresponds to a C source file.
This is as if you could put multiple C source files inside a Java class.
And you can put many Java classes inside a Java class.
Think of a class like a folder for C source files;
it groups things to help programmers understand the code,
not as something that corresponds to an object.
** Crucial question
If there are many ways of writing programs that do the same thing,
why choose a particular way?

More maintainable.
** Use snake case
Class name: =My_class_name=

Field, method, and variable name: =my_method_name=

Maintainability is done by limiting ugliness inside a class.

It is possible to write maintainable Java code. It will only be a bit more verbose.
** Making a Java virtual machine
- https://en.wikipedia.org/wiki/Java_Class_Library
- https://en.wikipedia.org/wiki/Java_Native_Interface
  - https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/functions.html
* Programming language design mistakes?
What is a design mistake?
Does a design mistake exist?
Or all that exists is trade-offs/compromises?

Assembly is not fun to use, but is it a design mistake?
How else could it be done in the 20th century, other than wishfully thinking of telepathic machines?
** Justifying the creation of yet another programming language
A new programming language should fix unforeseen design mistakes in existing programming languages.
It should not repeat their design mistakes.
Therefore we should collect the design mistakes so that we can avoid repeating them.

What is a mistake?
How do we know it's a mistake?

We realize something is a mistake when we find a better way.

Mistakes are always discovered by hindsight.
We don't know it's a mistake until long after we have done it.
** Common design mistakes
*** Ignoring programming language theory and research
Some mistakes are because the language designer is ignorant, lazy, or in a hurry.
*** Dynamic typing
Dynamic typing speeds up prototyping but precludes translation to code that is as fast as statically-typed codes.

Static typing is about allowing the compiler to make simplifying assumptions to emit faster code.
We can work faster with simplifying assumptions.
For example, if we can assume that people don't mind being killed, we can kill all people,
but that assumption is like the assumption that user input is always valid.

Dynamic typing is a design mistake?
Type inference goes back to 1958.
ML has type inference since 1973.
It's 2018.
There is no excuse for ignoring 60 years of research.
See [[https://en.wikipedia.org/wiki/Type_inference#Hindley%E2%80%93Milner_type_inference_algorithm][WP1]],
[[https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system#History_of_type_inference][WP2]].
*** Lack of metaprogramming support?
*** Lack of symbol overloading (ad-hoc polymorphism)
    :PROPERTIES:
    :CUSTOM_ID: lack-of-symbol-overloading-ad-hoc-polymorphism
    :END:

Scheme and Haskell lack convenient symbol overloading.
Haskell requires you to make a type class for ad-hoc polymorphism.

Without overloading, clashing names need to be prefixed manually.

*** Mutable by default?
*** Non-first-class constructs
Object-oriented programming is a design mistake?

- =a.b()= should not mean "call method b of object a"
- =a.b()= should mean "get the function a.b, then call it".
- =a.b()= should mean =(a.b)()=.

  - =m = a.b; m();= should mean the same as =a.b()=.
  - Functions should be first-class.
    Methods should not exist.
    Fields are enough (with function types).
    It should be possible to assign to methods.

Statements are a design mistake.
They should not exist.
Only expressions should.
[[https://www.eclipse.org/xtend/documentation/203_xtend_expressions.html][Xtend]]
and
[[https://code.haxe.org/category/principles/everything-is-an-expression.html][Haxe]]
do this right. - Can we replace statements with expressions in existing imperative languages without breaking backward compatibility? - But C has [[https://en.wikipedia.org/wiki/Comma_operator][WP:Comma operator]]? - We can use lambda calculus for imperative programming. - Treat the statement separator (here we use semicolon =;=)
as an operator (function with infix syntax)
that sequences the effects of two expressions. - For example: - Let =a= be an expression. - Let =b= be an expression. - Thus =a;b= is an expression. - The value of =a;b= is the value of =b=. - The effect of =a;b= is the effect of =a= followed by the effect of =b=. - Semicolon is associative: =(a;b);c = a;(b;c)=. This also holds for the effects.
*** Virtual machines
Virtual machines are a design mistake.
Instead, do semantic mapping: map a program in language A to an equivalent program in language B while preserving the meaning.
*** More than one way to do something
[[https://en.wikipedia.org/wiki/There%27s_more_than_one_way_to_do_it]["There is more than one way to do it"]] is a design mistake.
*** Disallowing multi-line string literals
Languages should allow CR/LF in string literals.
*** Not allowing extra leading or trailing commas
Allowing extra commas make Git diffs less noisy.
*** Not separating names and referents
Example: C functions, Java classes, Haskell modules.

JavaScript does not make this mistake.
** Java
   :PROPERTIES:
   :CUSTOM_ID: java
   :END:

- Checked exceptions don't play nice with java.util.Stream.
  Either checked exception or java.util.Stream is a design mistake.

  - https://en.wikipedia.org/wiki/Effect_system

- What others think Java gets wrong

  - http://tech.jonathangardner.net/wiki/Why_Java_Sucks

*** Overcomplicated Java Virtual Machine
    :PROPERTIES:
    :CUSTOM_ID: overcomplicated-java-virtual-machine
    :END:

JVM does too much.
JVM bytecode verification is the compiler's job, not the VM's.
Does JVM bytecode verification even add any security?
Isn't JNI a bigger security hole?

*** Working against programmers
    :PROPERTIES:
    :CUSTOM_ID: working-against-programmers
    :END:

Java presumes that the programmer is not only untrustworthy but also an idiot.

Programmers make mistakes, but they aren't idiots.

- [[https://www.reddit.com/r/programming/comments/utqb/ask_reddit_why_do_so_many_reddit_users_hate_java/cutv1/][Ask Reddit: Why do so many reddit users hate java? : programming]]

  - "Java's solution to the problem of C++ allowing you to blow your foot off was to chop off your legs."

*** Throwing away the good parts of C++
    :PROPERTIES:
    :CUSTOM_ID: throwing-away-the-good-parts-of-c
    :END:

- Forbidding multiple inheritance is a design mistake.
- Java interfaces are a design mistake.
  See 2015 Robert C. Martin article [[http://blog.cleancoder.com/uncle-bob/2015/01/08/InterfaceConsideredHarmful.html][Java interface considered harmful]].
- Implementing generics too late with type erasure.
  [[https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history][C# 2.0 introduced]]
  generics, without type erasure, while maintaining backward compatibility,
  by duplicating everything in System.Collections to System.Collections.Generic.
  This is ugly, but less ugly than type erasure.

  - [[https://stackoverflow.com/questions/11436802/how-are-c-sharp-generics-implemented][SO:How are C# generics implemented?]]

    - [[https://blogs.msdn.microsoft.com/ericlippert/2009/07/30/whats-the-difference-part-one-generics-are-not-templates/][Generics are not templates]]

*** Weak functional programming (allowing partial functions)
    :PROPERTIES:
    :CUSTOM_ID: weak-functional-programming-allowing-partial-functions
    :END:

Allowing partial functions is a design mistake.

** C and C++
   :PROPERTIES:
   :CUSTOM_ID: c-and-c
   :END:

In the 1970s these were tolerable: memory was limited, tools didn't exist.
In 2018 these aren't tolerable.

- Unattainable standard.
  - [[https://stackoverflow.com/questions/5574469/are-there-any-fully-conforming-c-implementations][SO:Are there any fully conforming C++ implementations?]]
- Pile of workarounds.
- C++ compilation is abysmally slow. =#include <iostream>= expands to 10000 lines.
- C pointer declaration syntax for pointers and arrays is a design mistake.
- Conflating pointers and arrays.
- Leaving a lot of things undefined.
- Zero-terminated string is a design mistake.
- Parsing requires symbol resolution and type checking.
- Header files. They should be automatically generated from C files instead.
- Preprocessor works on text, not on C/C++ AST.
** Haskell
- Template Haskell is a mistake.
  - Instead, we should have a metaprogramming library, and generate hs files.
- Haskell compilation is slow.
- Haskell module system is a design mistake.
- GHC: If A depends on B, and B changes without changing API, then A still requires recompilation.
- Bottom inhabits every type including the supposedly empty type =data Void=.
*** Not leveraging user-defined isomorphisms
    :PROPERTIES:
    :CUSTOM_ID: not-leveraging-user-defined-isomorphisms
    :END:

I want this:

#+BEGIN_EXAMPLE
    data A = A0 | A1
    data B = B0 | B1

    isomorphism "iso" between A and B is
        A0 ~ B0
        A1 ~ B1
#+END_EXAMPLE

instead of this:

#+BEGIN_SRC haskell
    data Iso a b = MkIso {
            fwd :: a -> b
            , rev :: b -> a
        }

    iso :: Iso a b
    iso = MkIso ab ba where

        ab :: A -> B
        ab A0 = B0
        ab A1 = B1

        ba :: B -> A
        ba B0 = A0
        ba B1 = A1
#+END_SRC

Explicit isomorphism may help reduce newtype boilerplate.
** Prolog
Difference between rules and queries.
Files contain rules.
Interpreters accept queries.
This is a mistake that prevents local contexts.

Instead of assert and retract, Prolog should have scopes: with(Rules,Query).

Instead of Prolog modules, Prolog should have dictionaries and JavaScript-like require(Path).
** what
A problem with current programming methodologies is that they don't capture the higher-level properties of software, such as the architecture.
For example, how do we write, in a way that the computer can exploit, this statement:
"The fields of class C correspond one-to-one with the columns of database table T."?

- Other people's experiences

  - https://www.quora.com/If-you-were-to-design-a-programming-language-what-other-programming-language-would-it-evolve-from-and-what-aspect-of-that-language-would-you-do-differently
  - [[http://beza1e1.tuxen.de/articles/proglang_mistakes.html][5 Mistakes in Programming Language Design ― Andreas Zwinkau]]

    - [[https://news.ycombinator.com/item?id=1500665][Mistakes in programming language design | Hacker News]]

  - [[https://softwareengineering.stackexchange.com/questions/55047/what-is-the-greatest-design-flaw-you-have-faced-in-any-programming-language][What is the greatest design flaw you have faced in any programming language? - Software Engineering Stack Exchange]]
  - [[http://www.inquisition.ca/en/info/gepsypl/rules.htm][Programming Language Design Rules]]
  - 1999 Steele article "Growing a language" [[http://www.catonmat.net/blog/growing-a-language-by-guy-steele/][html]]

https://www.drmaciver.com/2009/01/criticizing-programming-languages/

Lua design mistakes

Picking different syntax for the sake of being different

for elem in table surprisingly doesn't work, but this is for greater cause; the for syntax is surprisingly consistent (iterators, which are coroutines)

Distinguishing statements and expressions

Why do new language designers still repeat design mistakes?
** Lisp design mistake: having separate data and function cell
* Total mess
** Catching mistakes; checking; proving; reasoning; type systems
*** Curry-style extrinsic typing instead of Church-style intrinsic typing
Types help, but they are not the essence.
Types are a means of writing better programs, not an end to be achieved for its own sake.
Type should not be a property of an expression.
Prefer Curry-style (domain-free) type system to Church-style (domainful) type system.

"Domain-Free Pure Type Systems"
https://pdfs.semanticscholar.org/e638/74519839d4f2baf27f95078fc50ed0540fed.pdf

But, if we don't have types, how do we resolve overloading?
We can't resolve overloading without context.
The only context we have is what variable has what type.

For example, this is an example essence of a business logic:
#+BEGIN_EXAMPLE
discount_percent P = 0
  + (if old P then 10 else 0)
  + (if student P then 10 else 0)
  + (if pregnant P then 10 else 0)
#+END_EXAMPLE

The meaning is as in mathematics: all numbers are real numbers.
Realization then produces a restricted subset of that description that works for all numbers whose magnitude is smaller than 2^63.
A program is a restricted (realized, finitized) mathematical description.
Example:
The mathematical description f x = x + 1 works with all real numbers.
The program works with all natural numbers from 0 to 2^64-1.
The realization of a mathematical function (A,B,F) is simply a finite subset of it: (A',B',F'), where A', B', and F' are finite.
Even if you use arbitrary-precision arithmetic, you are still limited to the memory of the machine. For example, if the machine only has 1000 bytes of memory, then it can only realize number smaller than 2^(1000 * 8).
*** What is a type? Understanding what a type is from how it is used
Mathematically, A type is a set whose membership is syntactically decidable.

Engineeringly, A type gives meaning to bit patterns.

A type encodes meaning into bit patterns.
    - For example, consider the bit pattern 11111111.
        - It means -1 as an int8.
        - It means 127 as an uint8.
    - Types help translate programs.

Type system helps machines help us.
We shouldn't focus on type systems.
We should focus on logic.
We should focus on making machines help us.
The question is not how to make a good type system.
The question is how to offload the job as much as possible from humans to machines.

A programming language is a formal system.
A type system is a formal system.
Therefore a type system is a formal system embedded in a bigger formal system that is a programming language.

Programming languages have semantics, even if it is implicit.

A type defines the memory layout (bit pattern) of its values.

A type constrains values and expressions.

A type determines what values a function can take/give.

There are also other uses of types.

The question is: What is a type?
What principles should we follow when we design a language?

- https://news.ycombinator.com/item?id=8045115
    - [[https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/][Dynamic Languages are Static Languages | Existential Type]]
*** Church types and Curry types
Things to read:
- 2008, article, "Church and Curry: Combining Intrinsic and Extrinsic Typing", Frank Pfenning https://www.cs.cmu.edu/~fp/papers/andrews08.pdf
- Basic comparison between Church types and Curry types
  - https://lispcast.com/church-vs-curry-types/
  - [[https://www.reddit.com/r/programming/comments/2cavea/church_vs_curry_types_two_conflicting_perspectives/][Church vs Curry Types -- Two conflicting perspectives : programming]]
*** Row polymorphism
Why is it called row polymorphism?
Where is the row?
See "Objects and Aspects: Row Polymorphism", Neel Krishnaswami [[https://www.cs.cmu.edu/~neelk/rows.pdf][pdf]]

In the following, the function =set_name_r=  is row-polymorphic.
The function =set_name_n= is not row-polymorphic.
#+BEGIN_EXAMPLE
type Person = { name : String; age : Int; };
type Company = { name : String; location : String; };

set_name_r : String -> {name:String; r;} -> {name:String; r;};
set_name_r new_name {name=n; r;} = {name=new_name; r;};

set_name_n : String -> {name:String;} -> {name:String;};
set_name_n new_name {name=n;} = {name=new_name;};

john : Person;
john = { name="John"; age = 20; }

joe : Person;
joe = set_name_r "Joe" john;

not_person : {name:String};
not_person = set_name_n "What" john;

abc = { name="ABC"; location="1 ABC Way"; };
def = set_name_r "DEF" abc;
#+END_EXAMPLE
Without row polymorphism, we would have to write set_name twice: once for each type.
**** Row polymorphism vs subtyping
https://cs.stackexchange.com/questions/53998/what-are-the-major-differences-between-row-polymorphism-and-subtyping
**** Row polymorphism vs structural subtyping
https://news.ycombinator.com/item?id=13047934
*** what
- Liquid Haskell https://ucsd-progsys.github.io/liquidhaskell-blog/
- [[https://brianmckenna.org/blog/row_polymorphism_isnt_subtyping][Row Polymorphism Isn't Subtyping - BAM Weblog]]
- recursive types http://ecee.colorado.edu/~siek/ecen5013/spring10/lecture15.pdf
- http://tomasp.net/coeffects/
- From Wadler home page
  - [[http://groups.inf.ed.ac.uk/abcd/][From Data Types to Session Types: A Basis for Concurrency and Distribution]]
- [[https://www.reddit.com/r/dependent_types/comments/8qig0u/vectors_are_records_too_pdf/][Vectors are records, too (pdf) : dependent_types]]
- https://wiki.haskell.org/Untypechecking is "converting from a type to a term".
- NOOL 2016 article "Static Typing Without Static Types — Typing Inheritance from the Bottom Up" [[http://www.it.uu.se/workshop/nool16/nool16-paper4.pdf][pdf]]
- https://en.wikipedia.org/wiki/Literate_programming
*** Parametricity
- Every recursive type can be written as `mu a. F a` where F is the associated free functor?
    - Example: `List a = Fix (F a)` where `F a b = 1 + a * b`.
    - `Fix F = F (Fix F)` is the least fixed point of F.
- Why should we care about parametricity?
    - [[https://bartoszmilewski.com/2014/09/22/parametricity-money-for-nothing-and-theorems-for-free/][Parametricity: Money for Nothing and Theorems for Free - Bartosz Milewski's Programming Cafe]]
*** Subtyping
A subtyping relation is an ordering of types.

So what? That is technically correct but that doesn't give any insights.

A subtype is an ordering that follows the Liskov substitution principle?

*** Type-checking
- Every type checking algorithm is unification (logic programming).
    - If the programmer annotates a term, use that annotation.
    - If the a term is not annotated, annotate that term with a freshly generated variable.
    - Unify everything according to the typing rules.
    - See Algorithm W in [[https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system][WP:Hindley–Milner type system]].
*** Algebraic subtyping?
- subtyping
    - algebraic subtyping
        - 2016, PhD thesis, "Algebraic subtyping", Stephen Dolan https://www.cl.cam.ac.uk/~sd601/thesis.pdf
        - "Polymorphism, subtyping and type inference in MLsub" http://www.cl.cam.ac.uk/~sd601/papers/mlsub-preprint.pdf
            - from http://lambda-the-ultimate.org/node/5393
                    - from https://contributors.scala-lang.org/t/algebraic-subtyping/577
- http://www.cl.cam.ac.uk/~sd601/papers/mlsub-preprint.pdf
- https://www.cl.cam.ac.uk/~sd601/thesis.pdf
- https://cs.stackexchange.com/questions/53998/what-are-the-major-differences-between-row-polymorphism-and-subtyping
- https://www.cl.cam.ac.uk/teaching/1415/L28/rows.pdf
- 2017, "Introduction to homotopy type theory", http://www.cs.nott.ac.uk/~psztxa/ss-types-17/notes-summer17.pdf
- http://www.cs.nott.ac.uk/~psztxa/ss-types-17/
- https://homotopytypetheory.org/book/
- https://en.wikipedia.org/wiki/Subtyping
- https://en.wikipedia.org/wiki/Circle-ellipse_problem
- What does "X is a Y" mean?
It means P(X) => P(Y) for every predicate P.
Liskov substitution principle.
Does it mean "X is a subclass of Y" or "X is an instance of Y"?
** What
#+TOC: headlines 2 local
*** Introduction
**** Goal
The goal is to build a usable formal language up from lambda calculus.

A /formal human language/ is a formal language that humans use to precisely (unambiguously) communicate technicalities to other humans
in a way that is also feasible to machine translation using classical compiler techniques.
**** Examples of extending lambda calculus
- [[https://sites.ualberta.ca/~jhoover/325/CourseNotes/section/UntypedLambda.htm][Functional Programming - 12. The Extended Untyped lambda Calculus]]
- STLC = simply-typed lambda calculus
- [[https://softwarefoundations.cis.upenn.edu/plf-current/MoreStlc.html][Extending STLC]]
- 1982 article "A consistent extension of the lambda-calculus as a base for functional programming languages", https://www.sciencedirect.com/science/article/pii/S0019995882904582
- "Extending the Lambda Calculus: An Eager Functional Language", [[http://www.cs.yale.edu/homes/hudak/CS430F07/LectureSlides/Reynolds-ch11.pdf][pdf slides]]
***** TODO Study OCaml
Caml begets Caml Light begets OCaml.
- https://ocaml.org/
- [[https://caml.inria.fr/pub/docs/manual-ocaml/coreexamples.html]]
- https://caml.inria.fr/resources/doc/faq/core.en.html
**** Principles
***** Refer to mathematics, logic, and English.
***** Solve the root cause; don't hack.
***** Interoperate with existing systems. Improve existing systems. Enable replacement, but don't require it.

*** Functional programming

Every functional programming language is lambda calculus plus plus.

Functional programming is lambda calculus plus plus.
*** What we do when we understand programs
When we are trying to understand a program, what we actually do is we run an /abstract interpretation/ of the program in our head.
We /model/ the program in our internal language of thought: logic, most likely first-order logic.
"Abstract interpretation" has a specific meaning; see [[https://en.wikipedia.org/wiki/Abstract_interpretation][Wikipedia]].
*** Modeling
#+TOC: headlines 1 local
**** Prolog meta-thinking: logic, language, query, and modeling: how many parameters should we use?
Consider these models:
#+BEGIN_EXAMPLE
0 john_loves_mary
1 john_loves(mary)
2 loves(john,mary)
3 subject_verb_object(john,love,mary)
#+END_EXAMPLE

If we want to pattern match on it, or quantify it (existentially or universally), then it should be a parameter.
Example:
- "Who does John love" can not be answered by 0.
- "Who loves who" can not be answered by 1.
- "Who does what to whom" can not be answered by 2.
- "Who does what to whom at what time" can not be answered by 3.

Thus the number of parameters in our model depends on the complexity of the queries that we anticipate.
Thus when designing a logic program, we should begin with the /queries/ that we want to anticipate.
**** Modeling everything = name-property-value + subject-verb-object + time
Model of everything
Entity-attribute-value
I call it "name-property-value" to get in line with the terms used in philosophy
https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model

name-property-value

"The color of mycar is black."
:- multifile name_property_value/3.
name_property_value(mycar, color, black).
name_property_value(mydb, type, database).
name_property_value(mydb, subtype, postgresql).
name_property_value(mydb, is_a, database).

I think, if the knowledge base is big, it will be very confusing to trace which rule causes which name to have which property.

name_property_value(N, host, V) :-
    name_property_value(N, type, database),
    name_property_value(N, spec, Spec),
    member(host(V), Spec).

"Show me all databases."
?- name_property_value(E, type, database).
% press semicolon repeatedly

"X is a database" vs "The type of X is database" (The attribute "type" of X has the value "database")
*** Ramble: What is programming language expressivity?
- Hierarchy of programming language semantics?
  - https://en.wikipedia.org/wiki/Semantic_spectrum ?
- Hierarchy of formal languages
  - https://en.wikipedia.org/wiki/Chomsky_hierarchy
  - Hierarchy of machines recognizing those languages?
    - https://www.reddit.com/r/compsci/comments/35w0du/a_question_about_formal_language_and_automata/
  - https://en.wikipedia.org/wiki/Expressive_power_(computer_science)
  - 1991, Felleisen, "On the expressiveness of programming languages"
    - 1989, Hoare, "The varieties of programming languages"
    - 1988, Williams, "On the formalization of semantic conventions"
- Unread
  - http://fsl.cs.illinois.edu/index.php/Programming_Language_Design_and_Semantics
  - zig is better than go?
    - [[https://news.ycombinator.com/item?id=12378922][HN: Zig: a system language which prioritizes optimality, safety, and readability]]

What if we define language expressivity this way?

"J-expressive" means "expressive with respect to language J (judge)"

Language S (strong) is more J-expressive than language W (weak) iff the shortest interpreter for J in S is shorter than the shortest interpreter for J in W, without caring about speed.

Language A is more complex than language B iff A is more B-expressive than B is A-expressive.

Prolog is simple to reason but hard to implement?
Java is hard to reason but simple to implement?
It is easier to write Prolog interpreter in Java than to write Java interpreter in Prolog.
But how does Prolog's simplicity enables us to write better programs?
If a language is more complex, shouldn't it be more expressive/powerful?
What is the relationship between complexity, expressivity, and power?
What is expressivity?

I can make a language more complex without adding expressivity, by adding features that don't fit with the language?

*** Present in ACM SIGPLAN conferences?
ACM SIGPLAN POPL/PLDI/SLE https://www.sigplan.org/Conferences/
seem to be the right conferences to disseminate this idea,
but I should clean up this article first.
*** SWI-Prolog stuff?
**** What should SWI-Prolog modules be?
We want these to separate names and referents:
- anonymous modules
- anonymous predicates
- load file content into an anonymous module

consult(++FilePath, --Module)

SWI-Prolog module/1 option of load_files/2 enables the caller to separate a name and a module.
A module still has to be named, but now the module user decides the name.

A module is a dictionary.

SWI-Prolog dynamic module may be saving grace.

Prolog has dynamic scoping.
Dynamic scoping is a mistake.
Prolog should have lexical scoping.

Explicit linking directive
modulename_filepath(foo, library(mylib/foo))

**** Prolog module clash = game over? Can logtalk save the day?
https://logtalk.org/rationale.html
- comparison of the module systems of various Prolog implementations
*** Ideas?
The problem of C++ is that it tries to do too much.
*** Proglang mess
A Logic Programming Language with Lambda-Abstraction, Function Variables, and Simple Unification

https://pdfs.semanticscholar.org/8935/8a00317f9e380abe02b9f0d04536a6cd3121.pdf

https://www.google.co.id/amp/s/amp.reddit.com/r/ProgrammingLanguages/comments/6gsacs/any_info_on_compiling_lambda_calculus_to_other/
Compiling without continuations


Prolog dcg vs Haskell happy vs parsec
https://www.quora.com/Is-Prolog-still-the-best-logic-programming-language-as-of-2016

https://www.mercurylang.org/documentation/papers.html
http://www.cse.chalmers.se/~oloft/Papers/wm96/node2.html
Google search pure log. pro.

Purifying prolog IO using state threading
Sequential
print(W0,M0,W1), print(W1,M1,W2)
Parallel
print(W0,M0,W1), print(W0,M1,W2), join(W1,W2,W3)


http://batsov.com/articles/2012/02/19/package-management-in-emacs-the-good-the-bad-and-the-ugly/
http://milkbox.net/



Transforming AST to ASG by hashing every syntax element.


The one devops tool to rule them all

DADL is what we want for devops?

Extracting Instruction Semantics via Symbolic Execution of Code
https://github.com/trailofbits/codereason
"CodeReason is a semantic binary code analysis framework and toolset."

Opalang's database support is interesting.

https://opensource.com/tools/supply-chain-management


2006 article "Poitín: Distilling Theorems From Conjectures"
https://www.sciencedirect.com/science/article/pii/S1571066106001149

1984 publication "A Logic for the Russell Programming Language"
https://ecommons.cornell.edu/handle/1813/6433

ICSE 1982 article "Capturing more world knowledge in the requirements specification"
https://dl.acm.org/citation.cfm?id=800254.807765

ICSE 1987 article "Process models, process programs, programming support"
https://dl.acm.org/citation.cfm?id=41765.41767

On the power-series expansion of a rational function
http://matwbn.icm.edu.pl/ksiazki/aa/aa62/aa6233.pdf


- Example of ontology for accomodation; related to data modeling:
http://ontologies.sti-innsbruck.at/acco/ns.html#overview





Should we just use Opa or Ur/Web?
Which should we use, Opa or Ur/Web?
https://en.wikipedia.org/wiki/Opa_(programming_language)
"It can be used for both client-side and server-side scripting, where complete programs are written in Opa and subsequently compiled to Node.js on the server and JavaScript on the client, *with the compiler automating all communication between the two*." (emphasis mine)
https://en.wikipedia.org/wiki/Ur_(programming_language)
"[...] from a single program produces server code, browser client code and SQL code specific for the chosen database backend."

Inspired by English, XQuery, and ML.

Use Landin offside rule to infer closing tags:

#+BEGIN_EXAMPLE
let page title body =
  <html>
    <head>
      <title>{title}</title>
    </head>
    <body>{body}</body>
  </html>
in
if subpath begins with /url1/url2 {
  if subpath begins with /url3 {
    if request method is GET { (* This handles GET /url1/url2/url3 *)
      let strong text = <strong>{text}</strong> in
      page "Hello" <div>{strong "Hello"}</div>
      <html>
        <body>
          {strong Hello}
    }
  }
}

<html>
  <body>
    {strong Hello}

+ GET /url1/url2/url3 {page "title" <strong>hello</strong>}
+ GET /url1/url2/url4 {page "url4" <strong>what</strong>}
#+END_EXAMPLE

We don't need to create a new surface syntax. We can shallow-embed the DSL in Ocaml.

We need a new surface syntax if we want to generate routing data structure at compile time. The choice for the data structures are:
- We can use a hash table.
- We can use a prefix tree.

#+BEGIN_EXAMPLE
match-criteria { what-to-do-if-match }

expr returning node

Program ::= if Condition { Program } | serve PageExp
Condition ::= true | subpath begins with String | client accepts Accept | request method is String
String ::= <non-space>+ | Quote <non-quote>+ Quote
PageExp ::= Node | { MLNodeExp }
#+END_EXAMPLE


- https://stackoverflow.com/questions/26379582/difference-between-munch-and-many-satisfy-p

- https://github.com/jozefg/learn-tt


- "Scala by example" online book


I think most people believe "I don't really understand what my coworkers do but I believe they're doing it well."

- Stages of academic productivity:
    - You don't build on any past work. You start things and abandon them soon after. You redo your own work. You redo others' work without knowing it.
    - You know other people' work, but pride prevents you from even considering to study that work. You want to reinvent everything.
    - You learn to build on your past work.
    - You study other people's work, but you think you can do better.
    - You learn to build on other people's work.
    - You look for others who might share your interests.
    - You don't care whether it's you or someone else who solves the research problem. All you want is to see it solved.

You write a parser in C.
You rewrite the parser in Scheme.
You rewrite the parser again in Haskell.
Then you search for the essence of programming.
Then you stop writing parsers.
Now you write the grammar instead, and find a way to generate the parser from the grammar.
You also look for a way to generate the pretty printer from the grammar.
You find Prolog.

- citizen researcher, "academic spelunker"


https://lptk.github.io/programming/2018/10/04/comprehending-monoids-with-class.html

http://hazel.org/
"Hazel is a live functional programming environment featuring typed holes."

http://tomasp.net/blog/2018/programming-interaction/


1999 article "Essence—An LR Parser Generator for Scheme"
http://s48.org/essence/doc/essence.pdf
"The generated parsers result from the general parser by an automatic program transformation called /partial evaluation/." Holy shit.

https://mortoray.com/2012/07/20/why-i-dont-use-a-parser-generator/
- "One key aspect that bothers me with many of the tools is the requirement to have a distinct first lexing phase." I agree. That requirement is an unnecessary restriction for 2018 computers.



2018 article "SweetPea: A Language for Designing Experiments"


polymorphism
2018 article "A Principled approach to Ornamentation in ML"

POPL 2018 talk "Formal Methods and the Law": formalizing code-based law
"[...] computational analysis of these formalizations may discover previously overlooked tax avoidance techniques."

can ocaml polymorphic variants be used for row-polymorphic record types?

2015 article "A Crash Course on ML Modules"
https://jozefg.bitbucket.io/posts/2015-01-08-modules.html

mapping between Haskell type classes and ML modules
2006 article "Modular Type Classes":
- "We present a smooth integration of type classes and modules that provides a foundation for future work on incorporating type classes into ML and a proper module system into Haskell"
https://people.mpi-sws.org/~dreyer/papers/mtc/main-long.pdf


- "Introduction" http://maude.cs.illinois.edu/maude2-manual/html/maude-manualch1.html
- "Maude is a high-performance reflective language and system supporting both equational and rewriting logic specification and programming for a wide range of applications." http://maude.cs.illinois.edu/w/index.php/Maude_Overview
- "Functional Modules" http://maude.cs.illinois.edu/maude2-manual/html/maude-manualch4.html

"Code of ethics doesn't influence decisions of software developers"
https://www.reddit.com/r/programming/comments/9myr6a/code_of_ethics_doesnt_influence_decisions_of/


miniKanren for compilers?
Relational programming for compiler writing/

2013 article Spoofax vs Xtext
http://msdl.cs.mcgill.ca/people/hv/teaching/MSBDesign/201314/projects/Leonard.Elezi/report/reading_report.pdf

http://flint.cs.yale.edu/cs421/case-for-ml.html
http://troydm.github.io/blog/2014/03/29/writing-micro-compiler-in-ocaml/
https://stackoverflow.com/questions/14632870/creating-a-compiler-learn-ocaml-or-stick-with-java-c-c

https://people.mpi-sws.org/~rossberg/sml-vs-ocaml.html#exceptions

OCaml looks good
ML language family: Why 'a tree instead of tree a?

Spoofax vs Xtext vs MPS?

https://www.metaborg.org/en/latest/
- What you give Spoofax: language definitions.
- What Spoofax gives you: the IDE for the languages.

!!!
Write program transformation systems in Prolog or Mercury.

Clear
https://www.metalevel.at/prolog/data



Logic programming is natural match for program checking.

Transform

entity(Name, Fields)
entity(what,[ [id,int32,nullable], [name,varchar(byte(60))] ]).
each(sql_java_type_eqv, [(int32,int), (int64,long)]).
let(F = long_pred_name, F(int32,int)).

into

field(Entity_name, Field_name, Sql_type,

https://stackoverflow.com/questions/50512673/prolog-variable-as-functor

entity_field(Entity, [Name, Type | Opts])
one_to_many(A, B)
relation_1_n_entity_entity(Rel, A, B)

We can change Prolog's search strategy by using metapredicates? Cite?

Prolog record type?
Prolog beta reduction?
SWI-Prolog has IDEs

"The power of Prolog"
https://www.metalevel.at/prolog
Timeline: Prolog, miniKanren, Godel, Mercury?


https://www.researchgate.net/publication/221266897_A_Compiler_Written_in_Prolog_The_Veda_Experience
http://faculty.cooper.edu/smyth/cs225/ch7/prolog.htm
https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/compiler2.html
https://docs.racket-lang.org/reference/match.html
http://esumii.github.io/min-caml/index-e.html
http://adam.chlipala.net/mlcomp/



External type checking in the style of Erlang Dialyzer.

A type checker is a function from AST to Extended AST.

Resource should be freed as soon as it is not used.

How should we think of compile-time checking?
- Compile-time errors /predicts/ runtime errors.
- Compile-time errors /preclude/ runtime errors.

Type checking is a special case of program checking.

https://medium.com/@daveford/what-i-want-in-a-type-system-1316a78365b


Compile-time is a model of runtime. We don't model hardware errors.

Using DCG to parse CST

The principle: the rules must incorporate the parsed input. Don't remove information.

I changed my mind.
Write a DCG metainterpreter that adds location data to the token stream.
Separate the concerns.

"Separating concerns with metainterpreters" may be a worthy talk.

"Separating cross-cutting concerns with Prolog metainterpreters"

A CST node is either F(Code) or F(Child1, ..., ChildN) where
F is a functor and each ChildK is a CST node
and Code is a character code
An error node is error(Message, A, B)
It means that the parser encounters an error and resyncs to B
A is the offending subinput

exp(plus(M, N)) :- ...
exp(number(F,R)) :- ...
exp(digit(D)) :- ...

Use [plus,M,N] instead of plus(M,N)
Comments

data CST = Space Char | Digit Char | Number CST CST | Plus CST CST | Error Msg CST CST

exp :: String -> CST

It is possible to reconstruct the input string from the CST.


What is the difference between Scheme match library and ML pattern matching?

Experiment

A=[1,2],append(A,B,C) infinite
B=[1,2],append(A,B,C) infinite
C=[1,2],append(A,B,C) infinite
In order for C to be length-ground when append/3 exits:
- A and B are length-ground, or
- C is length-ground.
append(A,B,C)

S ::= <empty> | S a
s(A) :- append([S0,[0'a],S1],A), s(S0), s(S1).



- A terminal cannot be empty.
- Each right-hand side must contain at least one terminal.
  We require that every rule consume at least one character.
  This is so that the recursion is always decreasing.
- The generated parser requires that the input be length-ground.
  If the input is not length-ground, the parser may not terminate.

number ::=
    digit
;   digit, number.

expression ::=
    number
;   expression, "+", expression.

% Preprocessing.

% Terminal.
translate(STRING, t(CODES)) :-
    string(STRING),
    string_codes(STRING, CODES).

% Sequence.
translate((A, B), s(TA, TB)) :-
    translate(A, TA),
    translate(B, TB).

% Choice.
translate((A; B), c(TA, TB)) :-
    translate(A, TA),
    translate(B, TB).

% Nonterminal.
translate(CALL, n(CALL)) :-
    callable(CALL),
    functor(CALL, Name, _),
    \+ member(Name, [',', ';']).

% TODO


% Terminal.

translate(Input, Before, After, STRING, append([Before, CODES, After], Input)) :-
    string(STRING),
    string_codes(STRING, CODES).

translate(V_Input, V_Before, V_After, Call, Phrase) :-
    compound_name_arguments(Call, Functor, Args),
    compound_name_arguments(Phrase, Functor, Args_1),

rule_body__clause_body(Var_Input, Rule_body, Phrase) :- true
    , compound_name_arguments(Rule_body, Functor, Args)
    ,

TODO handle newline
code_location_effect(Code, A, B) :-
location_right(A, B).

node(Loc_before, Loc_after, Input, Remain)

The location can be inferred from the difference list.

node(Input, Remain) :- ..., append(Parsed, Remain, Input). // codes_location(Parsed, Loc0, Loc1)


Embed P in H
Embed H in P
op let 1200
op val 1200

let x = 1.
x(1).
let f(X) = X + 1.
f(X, X + 1).




Extend SWI Prolog checker library
Erlang-Dialyzer-style checker for Prolog



Prolog for computing taxes.
- https://github.com/cbbrowne/canadiantaxes
  - It uses dynamic predicates.


http://www.swi-prolog.org/pack/list?p=func

https://github.com/SWI-Prolog/issues/issues/14

"Prolog's Control Constructs in a Functional Setting — Axioms and Implementation"
https://www.cs.ox.ac.uk/publications/publication1149-abstract.html


Example of using Xtext, MPS, Spoofax
http://voelter.de/dslbook/markusvoelter-dslengineering-1.0.pdf



Software requirement does not change?
It is we who failed to discover the requirement?
It is we who failed to discover the underlying reality?
But how do we distinguish between design and overengineering?


Functional query expression language
all_rows_of(Table)
all(Table)
from(Table)
Table (just Table)
project(Columns, InTable) = OutTable
join(T1,T2)

Relational query formula language
table_row(Table, R)
table_columns_projected(T,C,R)



https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/exts/monad.html


Prolog gui in logtalk?

https://stackoverflow.com/questions/19832464/what-are-the-minimum-maximum-integers-in-gprolog
http://www.swi-prolog.org/pack/list?p=plgi
http://lambda-the-ultimate.org/node/3813

Picat language?


Dbpure similar to plspec


"(Parnas, Shore & Weiss 1976) identified five definitions of a 'type'"
https://en.wikipedia.org/wiki/Data_type

- Old content to be reorganized
  - Functional programming research
    - Functional programming in the real world
      - Philip Wadler's list [[http://homepages.inf.ed.ac.uk/wadler/realworld/][Functional Programming in the Real World]]
*** How many arguments does id have?
Iceland_jack asked:
https://twitter.com/ErikDominikus/status/1074009681553707008

0 in SKI combinator calculus

1 in Haskell / ML / Ocaml / F# / Scheme / JavaScript / untyped lambda-calculus

2 in Idris / Lean / GHC Core / System F / Coq
* Bibliography
