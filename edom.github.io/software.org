#+TITLE: Towards a philosophy of software
#+DATE: 2019-08-14 00:00 +0700
#+OPTIONS: ^:nil toc:nil
#+PERMALINK: /software.html
#+MATHJAX: true
* Introduction
What do we mean by "software"?

What is the essence of "software"?

The dictionary definitions of "software"
 [fn::https://en.wiktionary.org/wiki/software]
 [fn::https://www.dictionary.com/browse/software]
are too narrow and do not capture the essence of software.

We need an ontology;
we need to define and relate these terms:
hardware, software, computer, machine, calculator, program, code, language, programmable, error, mistake, bug, fault, malfunction.

\cite{gruner2011problems}
* The word "software"
What can we infer from the etymology and syntax of "software"?

The word "software" appeared no later than Tukey 1958,[fn::http://www.historyofinformation.com/detail.php?entryid=936]
and by it he meant the same thing that most people mean by "software" in 2019,
that is, the intangible-but-vital part of computers.
Thus, in order for a computer to be useful,
both its hardware and its software must be useful.

What is the difference between a softwareless computer and an empty box?

The word "hardware" appeared no later than the 15th century in which it meant "small metal goods".
The phrase "hardware store" appeared no later than 1789.[fn::https://www.etymonline.com/word/hardware?ref=etymonline_crossreference]

The word "software" is a mass noun, which is uncountable.

When a non-native speaker writes "a software", he usually means to write "a program" instead.

Uncountable nouns do not have to be abstract nouns.
If we can list something, then it is described by a countable noun.
There are abstract countable nouns,
such as "invitation", "friend", "failure", and "achievement".
There are concrete uncountable nouns, such as "water".

Some abstract things are countable, and some concrete things are uncountable.
By "uncountable", we mean "impractical to count".

What can we infer from how "software" is used in English?

Semantics of mass nouns \cite{sep-logic-massexpress}.

English sometimes hampers thought.
We simply accept this syntactic idiosyncrasy as the cost of using English.
Let us move on to more important semantic issues.
* Software from Platonism perspective
Software is to hardware as choreography is to dancers.
Indeed choreographies /are/ software.
Choreographies without dancers are dead ideas.
Dancers without choreographies are useless matter.

The dancers are the hardware,
the choreography is the software,
and the entire performance is the running computer.

I'll be a Platonist here.

A drawing in dance notation[fn::https://en.wikipedia.org/wiki/Dance_notation] on a sheet of paper
is a /representation/ of several closely-related choreographies.
The drawing is not itself a choreography.
The choreographies described by that notation are abstract objects with eternal existence in idea space.
If the sheet is destroyed, the choreographies persist;
for example, the choreographies may be represented in the memories of dancers.
Even if there are no people to discover them, the choreographies still exists in idea space.

A drawing cannot practically describe exactly one choreography,
because there will always be a slightly different choreography
in which the practical means of drawing does not have sufficient fidelity/resolution to describe the difference.
For example, suppose that choreography Y is the same as choreography X but with the hand shifted 1 micrometer to the right.
It is practically impossible to distinguish X and Y,
because it is practically impossible to perceptibly move the hand with micrometer precision.

Thus there be the question: Are ideas discovered or invented?
If I invent a word to mean something new, the concept that I mean with that word already exists in idea space.
Thus, a Platonist would say that words are invented and concepts are discovered.
Thus, for example, when Newton invented calculus,
he invented words and notations
for concepts that have always existed but not yet known by many people.
The concept of derivatives has always existed,
but the word "derivative" did not exist before humans existed.

/How do we test Platonism?/
Is it even falsifiable?

(old content)

The choreography is the software.
The dancer is the hardware.

The recipe is the software.
The paper is a representation of the recipe, but not the recipe itself.
You can tell the recipe to your friend, without paper.
The cook is the hardware.

The music score is the software.
The performers are the hardware.

The law is the software.
People in government is the hardware.

Software is choreography of hardware.
Software is an arrangement.
* The teleology of software
What is software for?
What is the purpose of software?

The definition of "chair" is a mixture of ontology and teleology:
Ontologically, a chair is something with a back rest.
Teleologically, a chair is for humans to sit.
Thus, a chair is something that has a back rest and can be used by humans to sit.
All those aspects are essential:
If any of those aspects is missing, then the object is not a chair.
* The mereology of computers: hardware and software
"Software" and "hardware" are /disjoint/ categories:
If something is software, it is not hardware;
if something is hardware, it is not software.

A computer is the sum of its hardware and its software.
A computer consists of its hardware, its software, and nothing else.

Thus, by the lone unqualified word "software" on its own,
we actually mean "the /software part/ of all computers".
Thus "software" is like "water":
By saying "water exists",
we actually mean "there exists an object that has the properties of water".

But software is not purely abstract:
It is stored in hardware as an arrangement of materials.
But is that software or a /representation/ of software?

What other things can be analyzed as a sum of hardware and software?
Laws, choreographies, recipes.

A /software house/ is a company that makes software.

Why "hardware /store/" but "software /house/"?
A software house is more like a blacksmith's workshop than a hardware store:
Things can be /made-to-order/ in a blacksmith's workshop but not in a hardware store.
Like "production house" for movies.

/Hardware bridges software and reality./

A piece of hardware is a concrete object that can be controlled by an abstract object (a piece of software).

Software is an arrangement of matter (hardware) that makes the hardware useful.
But must software have any purpose?

Examples of programming:
Designing mechanical linkages.
We arrange matter so that it does something we want.
* What can/cannot be done to software?
Software can be copied, but not moved like a concrete object such as a car.
* What is software?
Software is an arrangement of matter (hardware).

Software is executable abstract object?

Software is program, documents, configuration, and so on.

Software is abstract object.

Software is executable mathematics.

Software is an idea.

- Which ICSE paper said this?
  - Law is software.
  - Process is software.
  - Recipe is software.
- What is software?

The source code is not the software.
Don't commit reification fallacy.

Examples of software?

Programs, laws, choreographies, and recipes are software.

Minds are software?

Software has existed for millenniums, although not called "software".[fn::https://en.wikipedia.org/wiki/History_of_software]
* The dualistic nature of machines; the machine-program dualism; the hardware-software dualism
The hardware is the body.
The software is the mind.

Are bits software /itself/, or are bits a /representation/ (embodiment) of software?

A running machine embodies the software it is running?
* Programs and programmability
Programs used to mean "public notice".[fn::https://www.etymonline.com/search?q=program]
Authorities wrote programs to inform the public so that people behave accordingly.

From [fn::https://www.etymonline.com/search?q=program]:

#+BEGIN_QUOTE
General sense of "a definite plan or scheme" is recorded from 1837.
Meaning "list of pieces at a concert, playbill" first recorded 1805 and retains the original sense.
That of "objects or events suggested by music" is from 1854.
Sense of "broadcasting presentation" is from 1923.
Computer sense (noun and verb) is from 1945.
#+END_QUOTE

There is a confusion.
Program can mean both an individual show[fn::https://simple.wikipedia.org/wiki/Television_program]
and the entire plan for a television station[fn::https://en.wikipedia.org/wiki/Broadcast_programming].

To program something is to write a plan to be executed by that thing.

To run a program is to execute the plan.

What is programming?
Programming is forcing.
X programs Y to do Z iff X forces Y to do Z.

What can be programmed?
People are programmable to some extent.
We program people when we ask them to do something.
Software development process itself is also programmable to some extent.

What do we mean by "programmable"?

An unprogrammable machine computes only one mathematical function.
A programmable machine computes many functions.
However, we can see a programmable machine as computing one function,
that is a higher function from programs to functions.

Combine several mechanical calculators,
and add a mechanism to select which calculator to use.

Calculator vs programmable calculator.

Software does not have to be changeable. An example of practically unchangeable software is a program stored in a read-only memory (ROM) chip.

Is training a dog programming?
I say yes.
I'd even say that teaching a person is programming.
* Computer vs running computer
A computer has software, but is the computer running?

Software and electricity; running computers vs non-running computers

The operation of a computer requires an energy source.

A computer that is not turned has the /potential/ to compute, in the same way a seed has the potential to grow.

An /assignment statement/ can be modeled by a /state endofunction/.
* Philosophy?
https://www.perforce.com/blog/modern-software-engineering-meets-philosophy

https://mystudentvoices.com/is-the-programmer-the-new-philosopher-or-software-the-new-philosophy-6c0cbea5b8d2

https://conferences.oreilly.com/software-architecture/sa-ny-2016/public/schedule/detail/50859

https://www.sws.cs.ru.nl/
* Hardness: pure hardware, pure software, and mixtures
If a computer is a mixture of hardware and software,
then it makes sense to ask next:
/How much/ of it is hardware,
and how much of it is software?

We define the /hardness/ of a system as the proportion of it that is hardware.

An example of a pure-hardware system is a mechanical linkage or a salt crystal.

An example of a pure-software system is a mathematical equation or an algorithm.

An example of a mixed hardware-software system is a computer running a program.

If 2 unit of pure hardware is mixed with 8 unit of pure software,
then the result should be a 10-unit 20%-hardness system.

The question is: What is that /unit/?

Does upgrading the hardware of a computer increase its hardness,
because upgrading hardware implies adding hardware mass?

Mass is a unit of hardware.

Formula length is a unit of software.
* Computer science terms?
** Tools and machines
(I need to find the words to say this, and rewrite this more clearly.)

A /machine/ is an /automatic tool/:
it is a tool that runs by itself; it has its own behavior.

A hammer doesn't have its own behaviors.
A car has its own behaviors.
A computer has its own behaviors.
** What does it mean for a machine to compute a real number?
Computation is approximate expression normalization.
To /compute/ a real number is to calculate some of its digits.
To /compute/ an arithmetic /expression/ is to /evaluate/ it (to reduce it into a /value/), often approximately.
For example: 1/7 is an /expression/, and .142 is a /value/ that is the 3 most significant digits of the result of /evaluating/ that expression.

Why do we feel that 1.412 is /more evaluated/ than \(\sqrt{2}\)?
Why do we feel that 1.412 is a /normal form/?
Because it is /physically easier/ for us to locate 1.412 on the real number line than to locate \(\sqrt{2}\).
Thus to compute a real number is to /locate it/ on the real number line.
This justifies the geometric interpretation of real numbers.

We can /partially evaluate/ an expression, such as from 1+2-1 to 3-1.

See also:
- https://en.wikipedia.org/wiki/Human_computer

Don't conflate a /real-number expression/ and a /real number/.
A real-number expression /evaluates/ to a real number.
A real-number expression /is not/ a real number.

Let \(E(\Real)\) be the set of all real-number expressions.

Let \(f:E(\Real)\to\Real\) be the evaluation function.

Questions:
- What is the machine computing when I'm typing this document?
- There are several ways of defining the real numbers.
  Which one should we use for the philosophy of mind and computation, and why?

Algebraic-geometric definition:
A /real number/ is a /point/ in the /totally-ordered/ set of points in /one-dimensional/ Euclidean geometry;
the real numbers form a /field/.

Addition also has a geometric meaning: it is the set of points on the plane \(\{(x,y,z) ~\vert~ x+y=z\}\).
** Algorithm, machine, describability, computability
We assume that these are primitive concepts: algorithm, machine.
By "machine", we mean a computing machine.

An algorithm /describes/ what a machine /computes/.

An /algorithm/ is an /executable description/: a string in a formal language in a formal system.
A description has /finite/ length.
By "executable", we mean that an algorithm has a /machine model/.
We always define an algorithm with respect to a machine.

Thus not every real number is /describable/,
because there are fewer strings in that formal language than there are real numbers.

Thus not every real number is /computable/,
because computability requires describability.

Remember that a /formal system/ is a /formal language/ and a set of /inference rules/.
- https://cs.stackexchange.com/questions/42443/relationship-between-formal-system-and-formal-languages

An algorithm is a string in a formal language \(L\).
We /model/ a /machine/ as a /formal system/ whose language is \(L\).
The machine is not the formal system.
The thing is not the model.

*What does it mean for a machine to /compute/ a real number?*

Suppose that \(Y(T) \in \Real\) is the /output/ of the algorithm \(A\) if we let the algorithm run for duration \(T \in \Nat\).

The algorithm \(A\) /computes/ the /limit/ of the approximation sequence \( \langle Y(t) \rangle_{t \in \Nat} \).
Thus "\(A\) computes real number \(R\)" means that the limit of that sequence is \(R\).

More explicitly, we say "the algorithm \(A\) /computes/ the real number \(R\)" to mean:
for every approximation error \(E > 0\) that we are willing to have,
there exists a duration \(T \in \Nat\) such that \(\abs{Y(T) - R} < E\).
Informally, the algorithm can always take more time to satisfy ever-diminishing (but still positive) approximation error.

A real number \(R\) is /computable/ iff there is an algorithm that computes \(R\).

There are as many natural numbers as there are algorithms.
Therefore /not every real number is computable/, because there are fewer natural numbers than real numbers.

See also:
- https://en.wikipedia.org/wiki/Limit_of_a_sequence
** What it means for an algorithm to compute a function
The algorithm \(A\) /computes/ the function \(f : A \to B\) iff for every input \(x \in A\), the algorithm outputs \(f(x)\).
** Machine, algorithm, embodiment, computation
A machine /embodies/ an algorithm.
A machine /computes/ what the algorithm computes.

"To /program/ a machine to compute X" is to /arrange/ the machine to compute X,
for example: rewire the machine, load another set of punch cards, write a program in a text editor, etc.
** TODO Move this somewhere else: Hierarchy of machines
- An FA (/finite automaton/) is ...
- An FSM (/finite-state machine/) is ...
- A /Turing-machine/ is an FSM with infinite memory.
  - [[https://en.wikipedia.org/wiki/Turing_machine#Formal_definition][WP:Turing machine, formal definition]]
  - Turing-completeness
    - [[https://en.wikipedia.org/wiki/Turing_completeness][WP:Turing-completeness]]
    - A formal system is /Turing-complete/ iff it can simulate every TM (Turing machine).
      - What does it mean to /simulate/ a TM?
    - [[https://cstheory.stackexchange.com/questions/36863/formal-definition-of-turing-completeness][StackExchange CS theory 36863 formal definition of Turing-completeness]]:
      - Kaveh suggested:
        - [[https://www.sciencedirect.com/science/article/pii/S0049237X08712576][Robin Gandy: Church's Thesis and Principles for Mechanisms]]
        - Classical recursion theory volume 1
  - Partial Turing machine, total Turing machine
    - What is the significance of the theorem in [[https://en.wikipedia.org/wiki/Total_Turing_machine][WP:Total Turing machine]]?
    - What is the relationship between total function and total Turing machine?
** What is a tool?
Philosophically, a tool is something that extends the user's self (the set of all things that the user can control).
But this raises the question:
Where is the boundary between two selves?

Economically, a tool is something that increases productivity (output per input).

Teleologically, a tool is something made by man for a specific purpose: A tool makes something easier (or even possible at all).
** Should we define one's "self" as the set of all things he can control?
There are lots of parts of one's own body that one cannot fully control, such as his heart, his breathing muscles, his reflexes, etc.
* Language issues in philosophy
Language is more about communication/utility than truth.
** The common conflation of something and its representation
Draw a car, and ask someone what it is, and he will probably answer "a car", although, pedantically, it is incorrect, and the correct answer is "the drawing of a car".
However, we communicate not to be correct, but to be useful.
Thus, in everyday communication, we /conflate/ things and their /representations/: we often say "X" to mean "a representation of X".

The positions of levers and switches are not software, but a /representation/ of software.
The magnetic fields in a hard disk is not data, but a /representation/ of data.
Changing the concrete representation of an abstract object affects the represented abstract object.
** Words: Invented or discovered?
/Neologisms/[fn::https://en.wikipedia.org/wiki/Neologism]
prove that words can be /invented/, such as "grok", "quark", "bromance", and "brexit".
But words can also be /discovered/.
For example, Heinlein invented "grok"[fn::https://www.etymonline.com/search?q=grok],
but I discovered it through someone who has read his writing.

But what do we mean by saying that /a word exists/?
If we say that words are invented, then words are not abstract objects in idea space?
But a word is not a concrete object, and thus it must be an abstract object.
But must it?
What if we declare three categories of being instead:
concrete objects, abstract objects, and names?
Or, can abstract objects be invented?

Plato's Forms are abstract objects, but they are eternal.

Can abstract objects be non-eternal?

Does an idea exist if there is no one to think of it?

But a concept has to be named before it can be thought about and communicated.
The name is invented, but the concept is discovered.
Thus one job of philosophers is to /pick names/ for concepts that may be important
but cannot yet be communicated.

* Bibliography
