#+TITLE: Computation
#+DATE: 2017-06-29 22:40 +0700
#+PERMALINK: /compute.html
#+MATHJAX: yes
* Suggested learning sequence
We study computation before machine because the replacement of human by machine is irrelevant to the essence of computation.

While defining computation, we have difficulty defining what a /reasonable encoding/ is.
Why do we assume that numbers are encoded in positional notation[fn::https://en.wikipedia.org/wiki/Positional_notation], not unary notation[fn::https://en.wikipedia.org/wiki/Unary_numeral_system]?

We see that encoding affects complexity.
Adding two natural numbers \(m\) and \(n\) takes \(O(m+n)\) steps in unary notation,
but \(O(\log(\max(m,n)))\) steps in positional notation.
Therefore, why don't encode a number as its prime factorization,
to simplify multiplication while complicating addition?

...

In the end, we hope to solve the P vs NP problem.
** Algorithm, computation
An /algorithm/ is a /finite description/ of /computation/.

An /algorithm/ is a /finite description/ of how something is /computed/.

An algorithm is a /representation/ (/encoding/) of a computation.
** Logic, model
See [[file:logic.html]].
** Computation
** Programmability
Some machines are /programmable/. Such machine implements several functions
that can be chosen by a /program/ which is a part of the machine's input.
A program chooses which function the machine shall compute.
** Problem, formula, input, output, model, relation
"Problem" comes from Greek "problema" which means "a task, that which is proposed, a question".[fn::https://www.etymonline.com/word/problem]
Therefore, a problem /is/ a question, or, formally, a /logical formula/.

/A problem is a formula./
For example, the problem "Given an \(x\), what is \(x+x\)?" is the formula
\( x+x = y \) in first-order logic with equality and some arithmetics.
Note that some logic is embedded in English.[fn::English is at least second-order, as demonstrated by the Geach--Kaplan sentence "Some critics admire only one another" https://en.wikipedia.org/wiki/Nonfirstorderizability].

#+CAPTION: Some common problem shapes
| name             | shape          | input | output |
|------------------+----------------+-------+--------|
| decision problem | \( p(x) \)     | \(x\) |        |
| search problem   | \( p(x) \)     |       | \(x\)  |
| function problem | \( f(x) = y \) | \(x\) | \(y\)  |

A problem may have /inputs/ and /outputs/.
An /input/ of a problem is a free variable in the formula.
An /output/ of a problem is a free variable in the formula.

Another example: the problem "Is the sum of two even numbers even?" is the formula \( E(x) \wedge E(y) \to E(x+y) \).

What does it mean to solve a problem (answer a question)?
Solving a problem is answering a question.
Answering a question corresponds to /proving a formula/.
Answering a question corresponds to /finding a model/ of a formula?

A /problem/ may be /modeled/ by a /relation/ between questions and answers.
For example, the problem \( \forall x \exists y : x+x = y \)
is modeled by the relation \( \{ (0,0), (1,2), (2,4), \ldots \} \)
and is also modeled by the relation \( \{ (\epsilon,\epsilon), (1,11), (11,1111), \ldots \} \).

Do not conflate a problem and a model of it.
A problem is a formula, /not/ a relation.

Compare various definitions of "problem"
 [fn::https://en.wikipedia.org/wiki/Computational_complexity_theory]
 [fn::https://plato.stanford.edu/entries/computational-complexity/].

A problem is \cite{sep-computational-complexity}

Problem can be /composed/ as formulas can be composed.
** Machine, computation, reasonable encoding
A /machine/ is a tool that /computes/ what the machine is designed for.
A machine has material existence.
It is a physical implement.

A machine /computes/ the function problem \(y = f(x)\) with input \(x\) and output \(y\), iff,
starting with \(\hat{x}\), the machine eventually arrives at \(\hat{y}\),
in such a way that there is a /reasonable encoding/ between \(x\) and \(\hat{x}\) and between \(y\) and \(\hat{y}\).
We cannot see a natural number, but we can see patterns on a computer screen, and it is trivial for us to understand the number represented by which pattern.

The encoding has to be made explicit.
"Cheating" in the encoding is a common source of error in P vs NP "proofs".

Problem:
What do we formally mean by "reasonable encoding"?

Digression:
In [[file:philo.html]], I write that a machine is a tool, that is something that we use to extend our self (what we control).
** Computable, algorithm, finite description
Function $f$ is /computable/ by formal system $S$ iff $S$ has a /finite description/ of $f$.

An /algorithm/ solves a /problem/.
A problem can be solved by many algorithms with different resource usage characteristics.

An algorithm is a finite description of what a machine is supposed to do.
** Machine abstraction, formal system
An /machine abstraction/ is a mathematical abstraction of a machine.
Such abstraction is usually a formal system.
** Complexity
The worst-case time complexity[fn::https://en.wikipedia.org/wiki/Worst-case_complexity]
of machine $m$ for input $x$ is $t(m,x)$,
the number of steps $m$ makes between the beginning and the halting.
The /worst-case time complexity/ of $m$ for input /size/ $n$ is
$T(m,n) = \left\vert \max_{|x| = n} t(m,x) \right\vert$.
We can also write asymptotic statements such as $T(m,n) \in O(f(n))$.

An algorithm implies a machine.

The complexity class of a problem is the worst-case time complexity of the most efficient algorithm solving that problem.

A /machine/ $M$ is a /transition relation/ $T$
(an /acyclic/ binary relation).
$$
T(x,y) = \text{\(M\) can state-transition from \(x\) to \(y\).}
$$

$M$ /computes/ $P$ iff
a subgraph of the shortcut of $T$ is isomorphic to $P$.
(If $T$ were cyclic, this definition would fail.)

Related:
[[https://en.wikipedia.org/wiki/Graph_isomorphism][graph isomorphism]],
[[https://en.wikipedia.org/wiki/Subgraph_isomorphism_problem][subgraph isomorphism problem]].

/Deterministic/ machine equals /functional/ relation.

$G$ /accepts/ $v$ iff $F^\infty(\{v\}) = \emptyset$ where $F$ is the graph's fringe function.
The /language/ recognized by $G$ is the largest $L \subseteq V$ such that $F^\infty(L) = \emptyset$.

A Turing machine is $(C,I,f)$
where $C$ is countable
and $f$ is recursive.

https://en.wikipedia.org/wiki/Register_machine

Example: a state of a Turing machine is $(c,l,h,r)$
where $c$ is a configuration,
$l$ is the tape content to the left of the head,
$h$ is the tape content at the head,
and $r$ is the tape content to the right of the head.
** Problem, reduction
Sometimes we can /reduce/ a problem into another problem?
* Computation
** Etymology, history, and calculation
Etymonline[fn::https://www.etymonline.com/word/computer]

CCIW's take on the origin of the word[fn::http://www.cciw.com/content/computer_etymology.html]

According to dictionary.com[fn::http://www.dictionary.com/browse/compute],
the word 'compute' comes from the Latin word 'computare'
that comes from the prefix 'com-' (together) and the word 'putare' (think),
so 'compute' roughly means 'think together'.

Wikipedia[fn::https://en.wikipedia.org/wiki/Computer#Etymology]

A computer used to mean a person that does a lot of calculations as his/her daily job.
The calculations are arithmetics and looking up values in tables.

Replacing humans with machines does not change the essence of computation.

Common usage in 2016 suggests that calculation is numerical computation,
in the same way that a [[https://www.google.co.id/search?q=calculator&tbm=isch][calculator]]
is a specialized computer for solving numerical problems.

/Calculate/ has a numerical connotation.

Leibniz used the term 'calculation'?
Turing used 'effective calculability' to mean [[https://en.wikipedia.org/wiki/Algorithm][algorithmic]]?
Computation is calculation? It's just following rules?
** Genus-differentia definition of computation?
A computation is (what) that (what)?

Process? Activity? Mechanism?

A program describes the computation performed by a machine.
A program modulates the machine.
Manipulates computational resources to compute something.
** Computation as sequence of steps
In a Turing machine, a step is a state transition
that consists of reading the tape cell,
writing the tape cell,
moving the tape head,
and changing the internal state.
In $\lambda$-calculus,
a step is a $\beta$-reduction
of an expression composed from more primitive subexpressions.
These examples suggest that we can define computation as a /sequence/ of steps.

Each of those models is a special case of [[file:decider][deciders]],
the most abstract and general theoretical machine I could think of.
** Computation as information transformation
Computation is answering a question.

What is the relationship between computation and answering questions?

A computer reduces information?
Transforms information?

Computation is transformation of information?
** Computation as model/concretion?
Computation is running a program on a machine.

It seems that the defining feature of computation is conditional and repetition.

Program is a model.
** Misconception of computing programs
A program does not compute; it is the machine that does.
When we informally say that a program computes a function,
we actually mean that running the program on the machine causes
the machine to compute that function.
A program is not capable of doing anything on its own;
a machine has to execute it.
Asking what a program does does not make sense;
a program does nothing.
However, for everyday practical reason, we conflate a program
and the result of executing it on the machine we have.

** Diving into philosophy of computation
Ian Horswill wrote an introductory article "What is computation?"[fn::http://www.cs.northwestern.edu/~ian/What%20is%20computation.pdf].

\cite{sep-computation-physicalsystems}
* More?
** Venue?
http://www.computationalcomplexity.org/
** Rant: The sad state of computational complexity texts
It is philosophically appaling that most computational complexity texts readily show what a problem is /represented/ as,
but never clearly and /formally define/ what a problem /is/.
It is appaling that they spend hundreds of pages discussing something undefined.
