---
title: Making the only programming language we will ever need
permalink: /plres.html
date: 2018-07-22 02:45 +0700
---

- The goal is to make *the* programming language.
- What are the criteria?
    - The language must be suitable for systems programming.
        - System programming is hardware-aware programming.
        Application programming assumes abstract machine, infinite memory, and all convenience provided by the operating system.
            - Why do we make this distinction?
    - In order for a language to be adopted, people must perceive its risk as low.
        - The language must work with existing codebases.
            - The language designer must think from the language user's point of view.
                - Let's say I have 100,000 lines of Java that I've been writing and testing for the past 5 years.
                Are you expecting me throw away all of them?
            - Thus the language must work with C, C++, C#, Java, Go, JavaScript, Python, Ruby, and everything else.
            This should be possible because the essence of all programming languages is the same: every programming language is a formal system.
            It should be possible to translate a program P1 in language L1 to program P2 in language L2 with the same semantics.
            - Improve/enhance, not supersede.
        - Mixing the old and new languages should be easy.
        - 2013, article, "Empirical analysis of programming language adoption", [pdf](http://sns.cs.princeton.edu/docs/asr-oopsla13.pdf)
- ontology and programming
    - "ontoprog: Ontology-based Programming: Extended Semantics for OOP languages", [github](https://github.com/andreasBihlmaier/ontoprog)
    - 2012, article, "Modeling the Knowledge Domain of the Java Programming Language as an Ontology", [pdf](http://eeyem.eap.gr/wp-content/uploads/2017/06/11_ICWL2012.pdf)
    - 2007, article, "Towards a programming language ontology", [pdf](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.82.194&rep=rep1&type=pdf)
- A goal of programming language research is to make a better programming language?
    - Do more with less.
    - *The* ultimate best programming language?
- The [Sixten](https://github.com/ollef/sixten) language might be a good starting point.
- Computer (machine) is embodied formal system.
    - Assume no hardware fault.
- Software is executable mathematics.
- Every functional programming language is lambda calculus plus plus.
    - Every functional programming language L can be modeled by a category C(L) whose objects are the types of L and arrows are the function expressions of L.
    - I thought lambda calculus could be summarized in one page, but Henk Barendregt wrote hundreds of pages about it. Is there more to lambda calculus than it seems?
        - 1994, 50 pages, http://www.nyu.edu/projects/barker/Lambda/barendregt.94.pdf
        - 1991, 190 pages, https://people.mpi-sws.org/~dreyer/tor/papers/barendregt.pdf
- where to find more
    - recent programming language research
        - meetings, conferences, symposiums
            - POPL ("ACM SIGPLAN Symposium on Principles of Programming Languages")
                - its twitter https://twitter.com/poplconf?lang=en
    - collections, links, aggregators
        - https://www.cs.cmu.edu/~mleone/language-research.html
    - software engineering
        - enterprise application development
            - It's 2018. CRUD should be generated.
                - https://news.ycombinator.com/item?id=15429616
                - http://isis.apache.org/
                - other tools?
            - feature-oriented software development
                - https://en.wikipedia.org/wiki/FOSD_program_cubes
- category theory and programming languages
    - categorical programming (what is this?)
        - 2000, PhD thesis, "Categorical programming with inductive and coinductive types" https://kodu.ut.ee/~varmo/papers/thesis.pdf
        - categorical programming language
            - 1993, article, "Comparing Hagino's categorical programming language and typed lambda-calculi" https://www.sciencedirect.com/science/article/pii/030439759390186W
            - 1987, PhD thesis, "Categorical programming language" http://web.sfc.keio.ac.jp/~hagino/thesis.pdf
                - "An interpreter of Hagino's Categorical Programming Language (CPL)." https://github.com/msakai/cpl
            - aggregators
                - 2009, https://mathoverflow.net/questions/3721/programming-languages-based-on-category-theory
                - https://softwareengineering.stackexchange.com/questions/216635/category-theory-based-language
    - category theory applied to programming language theory
        - 2012, "Generic Programming with Adjunctions" http://www.cs.ox.ac.uk/ralf.hinze/LN.pdf
- compiler construction
    - Every compiler does name resolution / symbol table.
        - Is there a compiler that doesn't do that? https://www.reddit.com/r/Forth/comments/695oik/advances_in_forth_language_design/dh454oq/
- 2018, "Collapsing towers of interpreters" http://lampwww.epfl.ch/~amin/pub/collapsing-towers.pdf
    - "It is well known that *staging* an interpreter – making it generate code whenever it would normally interpret an expression – yields a compiler [...]"
- semantics-aware software engineering?
    - compiler toolkit?
        - Stratego/XT
        - TXL
        - Eclipse Xtext, Eclipse Xtend
        - ANTLR
        - YACC, Bison
        - Lex, Flex
        - Eclipse Modeling Framework
- programming language design
    - https://tomassetti.me/resources-create-programming-languages/
    - 2004, book, "Programming language design concepts"
    - https://en.wikipedia.org/wiki/Expression_problem
- don't repeat yourself
    - https://en.wikipedia.org/wiki/Generic_programming
        - parametric polymorphism
- Safely Composable Type-Specific Languages https://www.cs.cmu.edu/~aldrich/papers/ecoop14-tsls.pdf
- A program is an executable formal system.
    - Can we formalize this using Grue's map theory?
        - Could this be as revolutionary as types-as-propositions (Curry-Howard correspondence) that enables proof assistants?
        - How is "false" represented?
        - How is "true" represented?
        - How is "conjunction" represented?
- interoperation between proof assistants?
    - Lem ("lightweight executable mathematics")
        - https://www.openhub.net/p/lightweight-executable-mathematics
        - http://www.cl.cam.ac.uk/~pes20/lem/
- foundation of mathematics
    - set theories, such as ZF, ZFC, NBG, etc.
        - https://math.stackexchange.com/questions/136215/difference-between-zfc-nbg
    - type theories, such as Martin-Löf type theory
    - logic?
    - category theory?
    - lambda calculus?
    - https://cstheory.stackexchange.com/questions/27217/are-there-presentations-of-set-theory-in-terms-of-lambda-calculus
        - Grue's map theory, 1992
            - http://hjemmesider.diku.dk/~grue/
                - 1992, Grue, PhD thesis, ["Map theory"](http://hjemmesider.diku.dk/~grue/papers/Grue92/Grue92.pdf)
                    - p. 130: "Equality is better than truth [...]" (How do we explain the context?)
                        - https://en.wikipedia.org/wiki/Equational_logic
            - related?
                - equational programming
- Composition, composable systems
    - https://en.wikipedia.org/wiki/Software_transactional_memory#Composable_operations
- Lambda calculus semantics
    - https://en.wikipedia.org/wiki/Lambda_calculus#Semantics
        - "In the 1970s, Dana Scott showed that, if only continuous functions were considered,
        a set or domain D with the required property could be found, thus providing a model for the lambda calculus."
            - 1982, ["What is a model of lambda calculus?"](https://www.sciencedirect.com/science/article/pii/S0019995882800879)
            - 2008, PhD thesis, ["Models and theories of lambda calculus"](https://tel.archives-ouvertes.fr/tel-00715207/document)
                - 2009, [summary](https://arxiv.org/abs/0904.4756)
    - Paul Hudak, lecture notes, [The Lambda Calculus](http://www.cs.yale.edu/homes/hudak/CS430F07/LectureSlides/Reynolds-ch10.pdf)
        - "The Greatest Thing Since Sliced Bread™, or maybe even before it"
    - The operational semantics of lambda calculus depends on the evaluation strategy?
        - What-reduction?
            - Normal-order reduction
            - Applicative-order reduction
        - Call-by-what?
            - Call-by-value
            - Call-by-name
- syntax, grammar, parsing, pretty-printing
    - Parsing is the act of modifying the *state* of the parser.
        - 2017, ["A Typed, Algebraic Approach to Parsing"](https://www.cl.cam.ac.uk/~nk480/parsing.pdf)
            - "[...] we extend the notion of Brzozowski derivative from regular expressions to the typed context-free expressions."
    - Unparsing is the linearization (serialization) of a tree.
    - Parsing is the treeization (delinearization, deserialization) of a line.
    - Parsing is String -> Maybe Tree.
    - Unparsing is Tree -> String.
    - Can we make parsing truly one-to-one? String -> Tree. CST = AST. Very rigid syntax. Forbid whitespace freedom.
    - Why lex (lexical analysis / tokenization)?
        - Cleaner grammar (no need to mention whitespaces in the grammar).
            - Example:
                - With lexing: `exp ::= exp "+" exp`
                - Without lexing: `exp ::= exp white "+" white exp`.
        - https://en.wikibooks.org/wiki/Compiler_Construction/Lexical_analysis
            - "Strictly speaking, tokenization may be handled by the parser. The reason why we tend to bother with tokenising in practice is that it makes the parser simpler,
            and decouples it from the character encoding used for the source code."
    - given grammar, generate both parser and unparser/pretty-printer
        - http://www.semdesigns.com/Products/DMS/DMSPrettyPrinters.html?Home=DMSToolkit
        - https://hackage.haskell.org/package/invertible-syntax-0.2.1/src/Example.lhs
        - https://hackage.haskell.org/package/invertible-syntax
        - [Tillmann Rendel and Klaus Ostermann. "Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing". In Proc. of Haskell Symposium, 2010.](http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf)
        - http://jssst.or.jp/files/user/taikai/2016/PPL/ppl1-1.pdf
    - Parsing Expression Grammar (PEG)
        - https://github.com/harc/ohm/
            - https://ohmlang.github.io/
                - https://harc.ycr.org/project/ohm/
        - Packrat
    - 2015, [Nez: practical open grammar language](https://arxiv.org/abs/1511.08307)
    - algebra of pretty-printing
        - 1995, Hughes, "The design of a pretty-printing library"
        - 1998, Wadler, "A prettier printer"
        - Hughes, Peyton-Jones, et al., http://hackage.haskell.org/package/pretty-1.1.3.6/docs/Text-PrettyPrint-HughesPJ.html
    - [Efficient simple pretty printing combinators](https://www.cs.kent.ac.uk/people/staff/oc/pretty.html)
    - Earley parser
        - https://en.wikipedia.org/wiki/Earley_parser
        - https://hackage.haskell.org/package/Earley
    - https://github.com/Gabriel439/post-rfc/blob/master/sotu.md#parsing--pretty-printing
        - https://hackage.haskell.org/package/trifecta
        - https://hackage.haskell.org/package/parsers
- Big names in programming language research, and their contributions
    - This list is incomplete.
    - See also:
        - https://en.wikipedia.org/wiki/Programming_language_theory
    - https://en.wikipedia.org/wiki/John_C._Reynolds
        - 2014, [The essence of Reynolds](http://www.cs.bham.ac.uk/~udr/papers/EssenceOfReynolds.pdf)
            - 1998, Reynolds, "Theories of programming languages"
    - Henk Barendregt, wrote books on lambda calculus
    - Thierry Coquand, invented calculus of constructions, Coq
    - Philip Wadler
    - Jean-Yves Girard
    - Steele, Sussman, Felleisen, Barzilay, etc. (Scheme guys, PLT Scheme guys)
        - 1999, Steele, "Growing a language"
            - http://www.catonmat.net/blog/growing-a-language-by-guy-steele/
    - Simon Peyton-Jones, etc. (Haskell guys)
    - Oleg Kiselyov
    - Edward Kmett
    - Adam Chlipala
    - a list http://www.angelfire.com/tx4/cus/people/index.html
- paradigm, approach, viewpoint, worldview
    - graph programming languages
        - https://cstheory.stackexchange.com/questions/3906/what-are-theoretically-sound-programming-languages-for-graph-problems
            - https://www.cs.york.ac.uk/plasma/wiki/index.php?title=GP_%28Graph_Programs%29
            - 2007, PhD thesis, Steinert, ["The graph programming language GP"](https://www.cs.york.ac.uk/ftpdir/reports/2007/YCST/15/YCST-2007-15.pdf)
            - a short visual example of "conditional rule schemata"
                - 2010, article, ["Hoare Logic for Graph Programs"](https://www.cs.york.ac.uk/plasma/publications/pdf/PoskittPlump.VS-Theory.10.pdf)
            - https://markorodriguez.com/2013/01/09/on-graph-computing/
            - https://en.wikipedia.org/wiki/Gremlin_(programming_language)
    - equational programming?
        - 2017-2018, https://www.cs.vu.nl/~tcs/ep/
        - term-rewriting
            - retired, [Q language](http://q-lang.sourceforge.net/)
                - http://q-lang.sourceforge.net/examples.html
                - superseded by Pure
                    - https://agraef.github.io/pure-lang/
                    - https://en.wikipedia.org/wiki/Pure_(programming_language)
                    - https://github.com/agraef/pure-lang/wiki/Rewriting
            - Joy
    - 2002, article, ["Stochastic Lambda Calculus and Monads of Probability Distributions"](http://www.cs.tufts.edu/comp/150PP/archive/norman-ramsey/pmonad.pdf)
- books
    - books recommended by courses related to programming language research
        - http://plus.kaist.ac.kr/~han/courses/cs520/
        - https://www.cl.cam.ac.uk/teaching/1516/ConceptsPL/
        - https://en.wikipedia.org/wiki/Programming_language_theory#Further_reading
    - 1995, book, "Syntax and semantics of programming languages", Slonneger & Kurtz http://homepage.divms.uiowa.edu/~slonnegr/plf/Book/
- towards a language with first-class syntax
    - composable grammars?
        - 2013, article, Viera & Swierstra, "First Class Syntax, Semantics, and Their Composition" http://www.cs.ru.nl/P.Achten/IFL2013/symposium_proceedings_IFL2013/ifl2013_submission_21.pdf
            - 2013, PhD thesis, Viera, "First Class Syntax, Semantics, and Their Composition" file:///home/erik/Downloads/viera.pdf
        - 1990, ["A Primer for Program Composition Notation"](https://authors.library.caltech.edu/26726/)
        - https://stackoverflow.com/questions/953185/composable-grammars
        - OMeta
        - Programming languages with programmable syntax
            - [Katahdin](http://chrisseaton.com/katahdin/)
        - parsing expression grammar, packrat
            - "Parsing ought to be easier"
                - https://news.ycombinator.com/item?id=2330830
                    - "PEGs are one class of cleanly composable grammars."?
        - http://www.cs.cmu.edu/~Compose/
        - cryptographic protocol analysis
            - https://en.wikipedia.org/wiki/Universal_composability
    - Programming languages with macros
        - Common Lisp
        - Scheme
        - Kotlin?
        - Clojure?
        - Scala? https://www.scala-lang.org/blog/2017/11/27/macros.html
- Other people's experiences
    - https://www.quora.com/If-you-were-to-design-a-programming-language-what-other-programming-language-would-it-evolve-from-and-what-aspect-of-that-language-would-you-do-differently
- 2017, PhD thesis, ["Context-aware programming languages"](http://tomasp.net/academic/theses/coeffects/)
    - [amazingly empathic considerate presentation that has the audience in mind](http://tomasp.net/coeffects/)
        - if only all PhD theses are presented that way
            - if only everybody writes that way
- 2014, book, Odersky, "Scala by example"
    - perhaps the best way to learn Scala for non-Scala programmers
- refactoring
    - [github.com/PyCQA/baron](https://github.com/PyCQA/baron): "IDE allow you to refactor code, Baron allows you to write refactoring code."
    - HaRe Haskell refactoring tool https://github.com/alanz/HaRe
- ungrouped
    - https://medium.com/generative-design/introduction-to-computational-design-6c0fdfb3f1
    - magic?
        - http://conal.net/blog/posts/semantic-editor-combinators
    - [Salon des Refusés 2017](https://2017.programmingconference.org/track/refuses-2017)
- Commentary on existing programming languages.
Things that I think are wrong in 2018.
    - Java
        - What I think Java gets wrong
            - JVM does too much.
                - JVM bytecode verification
                    - It's the compiler's job, not the VM's.
                    - Does it even add any security?
                        - Isn't JNI a bigger security hole?
        - What others think Java gets wrong
            - http://tech.jonathangardner.net/wiki/Why_Java_Sucks
        - What I'm not sure about Java
            - Why type erasure?
                - C# 2.0 introduced generics, without type erasure, while maintaining backward compatibility.
                    - Duplicating everything in System.Collections to System.Collections.Generic is ugly, but it's less ugly than type erasure.
                    - https://docs.microsoft.com/en-us/dotnet/csharp/whats-new/csharp-version-history
                    - https://stackoverflow.com/questions/11436802/how-are-c-sharp-generics-implemented
                        - https://blogs.msdn.microsoft.com/ericlippert/2009/07/30/whats-the-difference-part-one-generics-are-not-templates/
    - What I think every procedural programming language (Java, C, C++, Go, Python, Ruby) gets wrong, except JavaScript
        - Functions should be first-class. Methods should not exist. Fields are enough.
        - It should be possible to assign to methods.
        - `a.b()` should not mean "call method b of object a"
        - `a.b()` should mean "get the function a.b, then call it".
        - `a.b()` should mean `(a.b)()`.
            - `m = a.b; m();` should mean the same as `a.b()`.
        - JavaScript does this right.
        - What JavaScript does wrong, TypeScript does right.
    - What I think C and C++ got right but get wrong
        - In the 1970s these were tolerable (memory was limited; tools didn't exist). In 2018 these aren't tolerable.
            - Writing header files manually (should be generated from C files instead)
            - Preprocessor that works on text, not on C/C++ AST
    - What I think Haskell gets wrong
        - Template Haskell
            - Instead, we should have a metaprogramming library, and generate hs files.
        - Build is too slow.
            - Where should we fix this? GHC? Cabal?
    - What I think every imperative programming language gets wrong
        - Statements vs expressions
            - Statement should not exist. Only expressions should.
                - Xtend and Haxe do this right.
                    - https://www.eclipse.org/xtend/documentation/203_xtend_expressions.html
                    - https://code.haxe.org/category/principles/everything-is-an-expression.html
                - We can use lambda calculus for imperative programming.
                    - Treat the statement separator (here we use semicolon `;`)
                    as an operator (function with infix syntax)
                    that sequences the effects of two expressions.
                        - For example:
                            - Let `a` be an expression.
                            - Let `b` be an expression.
                            - Thus `a;b` is an expression.
                            - The value of `a;b` is the value of `b`.
                            - The effect of `a;b` is the effect of `a` followed by the effect of `b`.
                        - Semicolon is associative: `(a;b);c = a;(b;c)`. This also holds for the effects.
                - Can we replace statements with expressions in existing imperative languages without breaking backward compatibility?
            - But C has https://en.wikipedia.org/wiki/Comma_operator
- obscure
    - VPRI, Alan Kay et al., archived (stopped operating in 2018), computing for the masses?
        - "Improve 'powerful ideas education' for the world's children and to advance the state of systems research and personal computing"
            - https://harc.ycr.org/
                - https://www.ycr.org/
        - https://en.wikipedia.org/wiki/Viewpoints_Research_Institute
        - https://en.wikipedia.org/wiki/COLA_(software_architecture)
        - https://news.ycombinator.com/item?id=11686325
        - FONC = fundamentals of new computing
        - http://www.vpri.org/index.html
    - YCR
        - visual programming language
            - blocks language
                - https://harc.ycr.org/project/gp/
- 2002, article collection, "Recent advances in Java technology: theory, application, implementation" http://www.cs.nuim.ie/~jpower/Research/Papers/2002/power-raijt-toc.pdf
- other people's collections
    - https://github.com/steshaw/plt
- 1985, article, "Automatic synthesis of typed Λ-programs on term algebras" https://www.sciencedirect.com/science/article/pii/0304397585901355
- type systems and type theory
    - https://cs.stackexchange.com/questions/53998/what-are-the-major-differences-between-row-polymorphism-and-subtyping
    - row polymorphism vs structural subtyping https://news.ycombinator.com/item?id=13047934
        - Why is it called row polymorphism?
        Where is the row?
            - See "Objects and Aspects: Row Polymorphism", Neel Krishnaswami https://www.cs.cmu.edu/~neelk/rows.pdf
    - subtyping
        - algebraic subtyping
            - 2016, PhD thesis, "Algebraic subtyping", Stephen Dolan https://www.cl.cam.ac.uk/~sd601/thesis.pdf
            - "Polymorphism, subtyping and type inference in MLsub" http://www.cl.cam.ac.uk/~sd601/papers/mlsub-preprint.pdf
                - from http://lambda-the-ultimate.org/node/5393
                     - from https://contributors.scala-lang.org/t/algebraic-subtyping/577
- [Class-based programming]({% link cbp.md %})
- Making compilers
    - From grammar description, the machine should generate both a parser and a pretty-printer.
        - [LTU: Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing](http://lambda-the-ultimate.org/node/4191)
        - [Invertible Syntax Descriptions: Unifying Parsing and Pretty Printing](http://www.informatik.uni-marburg.de/~rendel/unparse/rendel10invertible.pdf)
    - Syntax analysis (parsing)
        - Brzozowski quotients.
            - [Yacc is dead](https://arxiv.org/abs/1010.5023)
            - "Parsing with derivatives"
        - What is an/the inverse of parsing?
            - Inverse of parsing is generation? From grammar, generate all possible strings and their syntax trees.
            - Inverse of analytical grammar is generative grammar?
            - Parser is syntax analyzer.
            - Analysis is the opposite of synthesis?
            - What is syntax synthesizer?
            - Inverse of parsing is pretty-printing?
            - If matching is analogous to subtraction, then what is analogous to multiplication? Generation?
- Supercompilation
    - [LTU: Ongoing work on Supercompilation of Java code (or supercompilation in general)?](http://lambda-the-ultimate.org/node/2739)
- Metaprogramming
    - http://kaitai.io/
        - from description, generate parsers for binary data (as opposed to text data)
- 2015, article, "Dynamically Composing Languages in a Modular Way: Supporting C Extensions for Dynamic Languages", [pdf](https://chrisseaton.com/rubytruffle/modularity15/rubyextensions.pdf)
- https://github.com/nim-lang/Nim
- 2016, article, "Towards Ontology-Based Program Analysis", [pdf](http://drops.dagstuhl.de/opus/volltexte/2016/6120/pdf/LIPIcs-ECOOP-2016-26.pdf)
    - Interesting conference title: "Conference on very important topics (CVIT)"
        - Is it real?
        Is it a secret society?
        Google doesn't seem to know about it.
- functional languages with explicit memory layout?
functional languages for systems programming?
    - [Sixten: Functional programming with fewer indirections](https://github.com/ollef/sixten)
        - It also deals with representing algebraic data type inhabitants as bit patterns.
        - "Sixten is very related to other functional languages such as Haskell, Agda, and Idris.
        The biggest difference between other languages and Sixten is the way that Sixten allows us to control the memory layout of data."
        - [Sixten, "General", Gitter, community chat](https://gitter.im/sixten-lang/General?source=orgpage)
- compiling with continuations
    - Why use CPS (continuation passing style) as intermediate form?
        - http://matt.might.net/articles/cps-conversion/
        - https://www.microsoft.com/en-us/research/publication/compiling-with-continuations-continued/
        - https://news.ycombinator.com/item?id=7150095
    - 2003, retrospective: the essence of compiling with continuations https://users.soe.ucsc.edu/~cormac/papers/best-pldi.pdf
        - https://en.wikipedia.org/wiki/A-normal_form
- What are Prolog alternatives?
    - 2011, article, [[1107.5408] A structured alternative to Prolog with simple compositional semantics](https://arxiv.org/abs/1107.5408)
- [Row Polymorphism Isn't Subtyping - BAM Weblog](https://brianmckenna.org/blog/row_polymorphism_isnt_subtyping)
- People who share the vision for *the* programming language
    - [Polymorphic Programming - BAM Weblog](https://brianmckenna.org/blog/polymorphic_programming)
        - has some links
        - 2017, article, "Compiling to Categories", Conal Elliott, [pdf](http://conal.net/papers/compiling-to-categories/compiling-to-categories.pdf)
        - Is this 1969 article related? Can't be found online.
            - https://en.wikipedia.org/wiki/Polymorphic_Programming_Language
        - Are these related?
            - 1989, article, "Database Programming in Machiavelli – a Polymorphic Language with Static Type Inference", [pdf](http://homepages.inf.ed.ac.uk/opb/papers/SIGMOD89.pdf)
    - Can we use Description Logic (the theoretical foundations of Web Ontology Language OWL) to generate software, especially enterprise applications?
        - 2015, article, [[1503.01723] Modelling the Semantic Web using a Type System](https://arxiv.org/abs/1503.01723)
        - 2005, article, "Software engineering ontologies and their implementation", [pdf](https://espace.curtin.edu.au/bitstream/handle/20.500.11937/9549/19598_downloaded_stream_116.pdf), [pdf copy](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.86.5585&rep=rep1&type=pdf)
    - People who share a subset of the vision; they don't go far enough
        - XForms
            - 2016, article, [Leveraging declarative languages in web application development - SpringerLink](https://link.springer.com/article/10.1007/s11280-015-0339-z)
            - 2014, slides, advocacy, [Declarative Web Applications](https://homepages.cwi.nl/~steven/Talks/2014/01-31-declarative/)
        - 2007, workshop, [Declarative Models of Distributed Web Applications](https://www.w3.org/2007/02/dmdwa-ws/)
        - IDE (integrated development environment), editor
            - Given a grammar, the computer should generate an IDE for us.
            Syntax highlighting.
            Refactoring.
            - https://hackage.haskell.org/package/treersec "Build a structure editor for a programming language from combinators following the grammar."
            - http://www.lamdu.org/
            - cirru https://news.ycombinator.com/item?id=13773813
                - lots of similar things https://news.ycombinator.com/item?id=13774864
            - isomorf: find code fragment popularity by structure (not-only-text) comparison https://isomorf.io/#!/tours/of/overview/7/haskell
        - supercompilation, specialization, partial evaluation
            - Haskell supercompilation?
                - GHC
                - Supero
                - Morte
                    - https://github.com/Gabriel439/Haskell-Morte-Library
                        - "Morte is a super-optimizing intermediate language for functional languages."
                    - http://www.haskellforall.com/2014/09/morte-intermediate-language-for-super.html
            - [Thyer's PhD thesis "Lazy specialization"](http://thyer.name/phd-thesis/thesis-thyer.pdf) has an accessible introduction to lambda calculus in Chapter 2.
            - 1991, "A partial evaluator for the untyped lambda-calculus", [paywall](https://www.cambridge.org/core/journals/journal-of-functional-programming/article/a-partial-evaluator-for-the-untyped-lambda-calculus/EE324F936F0A009B6766B13FF6755DFC)
                - related: semantic-directed code generation?
            - Gabriel Gonzales stuff: Morte, Dhall.
        - [A Treatise on Cosmos —the New Programming Language](https://medium.com/@McCosmos/a-treatise-on-cosmos-the-new-programming-language-905be69eb4af)
            - procedural-looking logic programming language
        - syntax
            - [WP:Off-side rule](https://en.wikipedia.org/wiki/Off-side_rule), indentation as block delimiter
    - Turn an interpreter into a compiler for free!
- 2017, article, [[1707.00024] A Formalized General Theory of Syntax with Bindings](https://arxiv.org/abs/1707.00024)
- [Vectors are records, too (pdf) : dependent_types](https://www.reddit.com/r/dependent_types/comments/8qig0u/vectors_are_records_too_pdf/)
- https://wiki.haskell.org/Untypechecking is "converting from a type to a term".
- Functional programming in the large
    - Key idea: A module is just a record (tuple whose components are named), in a dependently-typed language.
        - Module = lambda-calculus + dictionary
        - This idea is similar to Nix modules.
        - A module is just a lambda expression.
        - `type Module = Map Name Decl -> Map Name Decl`
        - A module translates into a lambda-calculus expression.
        - An import translates to an entry in the input kvm.
            - kvm = key-value map, look-up table, dictionary
        - An export translates to an entry in the output kvm.
        - Example:

        ```
        module {
            import add mul Int32;
            export f g T;
            f = add;
            g = mul;
            T = Int32;
        };

        \ {add; mul; Int32; ...} -> let {
            f = add;
            g = mul;
            T = Int32;
        } in {f; g; T;};
        ```

        - Key ideas of that example:
            - Dictionary pattern matching simulates row polymorphism.
            - `{a;b;c;}` is shorthand for `{a:a; b:b; c:c;}`.
    - Hypothesis: Lazy evaluation solves the partial query problem elegantly.
    - Cool thing: Dhall can import from IPFS.
        - http://www.haskellforall.com/2016/12/dhall-non-turing-complete-configuration.html
    - Untyped functional programming languages
        - Tulip
- [Argument for static typing]({% link statyp.md %})
- Old content to be reorganized
    - [Functional programming research]({% link functional_programming.md %})
        - [Optimizing lambda calculus]({% link optlam.md %})
        - Philip Wadler's list [Functional Programming in the Real World](http://homepages.inf.ed.ac.uk/wadler/realworld/)
    - [Joint research with Abdullah]({% link abdullah.md %})
    - [Programming]({% link programming.md %})
- [Programming Language and Compiler Research Groups](https://www.cs.cmu.edu/~mleone/language/projects.html)
- [IEEE posts its top list of languages - The PL Enthusiast](http://www.pl-enthusiast.net/2014/07/10/ieee-posts-its-top-list-of-languages/)
- [What is PL research and how is it useful? - The PL Enthusiast](http://www.pl-enthusiast.net/2015/05/27/what-is-pl-research-and-how-is-it-useful/)
- 2014, article, [Ontology-based Representation and Reasoning on Process Models: A Logic Programming Approach](https://arxiv.org/abs/1410.1776)
- 1994, article, "Formalizing architectural connection", [pdf](http://web.cs.wpi.edu/~cs562/s98/pdf/wright-icse16.pdf)
- relationship between Aspect-Oriented Programming and Functional Programming
    - 2009, article, "What Does Aspect-Oriented Programming Mean for Functional Programmers?", [pdf](https://www.cs.ox.ac.uk/files/2282/wgp14-wang.pdf)
    - 2008, article, "On Feature Orientation and Functional Programming", [pdf](https://pdfs.semanticscholar.org/522e/b6c2ea910ed074a13fe21767c9fa070fb685.pdf)
    - 2016, article, "Realtime collaborative editor. Algebraic properties of the problem.", [html](http://blog.haskell-exists.com/yuras/posts/realtime-collaborative-editor.html)
        - see also Darcs patch theory
    - 2008, PhD thesis, "An Integrated System to Manage Crosscutting Concerns in Source Code", [pdf](http://wwwtmp.st.ewi.tudelft.nl/arie/phds/Marin.pdf)
    - 2003, article, "Language-independent aspect-oriented programming", [pdf available](http://www.tara.tcd.ie/handle/2262/32627)
- [NOOL 2015 accepted papers - SPLASH 2015](https://2015.splashcon.org/track/nool2015#event-overview) ("New Object Oriented Languages")
    - "Classes Considered Harmful", [pdf](http://web.cecs.pdx.edu/~black/publications/ClassesHarmful.pdf)
    - "Ubiquitous Object Orientation to Foster the Advancement of Programming Languages", [pdf](http://www.cs.cmu.edu/~dkurilov/papers/nool15.pdf)
- NOOL 2016 articles
    - "Nomen: A Dynamically Typed OO Programming Language, Transpiled to Java", [pdf](http://www.it.uu.se/workshop/nool16/nool16-paper9.pdf)
        - "Nomen is an experimental, dynamically typed OO programming language which compiles to Java source code."
        - "Nomen is designed as a language for experimenting with IDE support generation using the Rascal language workbench."
    - "The essence of subclassing", [pdf](http://www.it.uu.se/workshop/nool16/nool16-paper5.pdf)
    - "Towards Automatic Decoration", [pdf](http://www.it.uu.se/workshop/nool16/nool16-paper2.pdf)
    - "Static Typing Without Static Types — Typing Inheritance from the Bottom Up", [pdf](http://www.it.uu.se/workshop/nool16/nool16-paper4.pdf)
    - syntax
        - "Polite Programmers, Use Spaces in Identifiers When Needed", [pdf](http://www.it.uu.se/workshop/nool16/nool16-paper10.pdf)
- [WP:Comparison of functional programming languages](https://en.wikipedia.org/wiki/Comparison_of_functional_programming_languages)
- Designing APIs
    - [An API Ontology - Literate Programming](http://blog.steveklabnik.com/posts/2012-02-13-an-api-ontology)
