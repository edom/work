#+TITLE: Trying to prove P neq. NP
#+DATE: 2018-04-28 22:30 +0700
#+PERMALINK: /pnptry.html
#+MATHJAX: yes
* Note
This is a proof /attempt/, not a proof.

Last update was 2018-04-28.
** Note: The conversion of this page from Markdown to Org Mode using Pandoc may introduce some errors, beside my errors that are already in the page before conversion.
* Finding an search problem that forces a DTM to traverse the search space
Let \(
\newcommand\SetOutcome{\mathbb{F}}
\newcommand\SetBit{\mathbb{B}}
\newcommand\SetPred{\mathbb{P}}
\newcommand\FunSat{\text{sat}}
\newcommand\FunMinTime{\text{MinTime}}
\newcommand\FunLen{\text{Len}}
\mathbb{B}= { 0, 1 } \)
be the set of /bits/.

Let $\mathbb{B}^*$ be the /Kleene closure/ of $\mathbb{B}$.

Let \( \mathbb{F} = \{ \text{accept}, \text{reject} \} \) be the set of /final states/.

A /predicate/ is a function in $\mathbb{B}^* \to \mathbb{B}$.

Let $\mathbb{P}$ be the set of all /computable predicates/.

Let $p \in \mathbb{P}$ be a computable predicate.

Let $\text{Len}(x)$ be the /length/ of the string $x \in \mathbb{B}^*$.

Let the function $\text{sat}: \mathbb{P}\times \Nat \to \mathbb{F}$ be

\begin{equation*}
\text{sat}(p,n) =
\begin{cases}
    \text{accept} & \text{if \( \exists x \in \mathbb{B}^n : p(x) = 1 \);}
    \\
    \text{reject} & \text{otherwise.}
\end{cases}
\end{equation*}

Let $\text{MinTime}_M(p,x)$ be the /shortest time/ (the minimum number of steps)
required by machine $M$
to compute $p(x)$ (to compute the predicate $p$ with input $x$).

Let $N$ be an NTM (non-deterministic Turing machine).

Let $D$ be a DTM (deterministic Turing machine).

Such NTM $N$ can compute $\text{sat}(p,n)$ in $O(n + \max_{x \in \mathbb{B}^n} \text{MinTime}_N(p,x))$ steps.
This is such algorithm:

#+BEGIN_EXAMPLE
    function sat (p, n) {
        var x: array [1..n] of bit
        for i := 1 to n {
            x[i] := guess
        }
        if p(x) { accept }
        else { reject }
    }
#+END_EXAMPLE

Such DTM $D$ can compute $\text{sat}(p,n)$ in $O(\sum_{x \in \mathbb{B}^n} \text{MinTime}_D(p,x))$ steps.
This is such algorithm:

#+BEGIN_EXAMPLE
    function sat (p, n) {
        for x in B^n {
            if p(x) { accept }
        }
        reject
    }
#+END_EXAMPLE

*Conjecture:* There exists a computable predicate $p \in \mathbb{P}$ such that
1. \( \text{MinTime}_D(p,x) = \text{MinTime}_N(p,x) \),
1. $\text{MinTime}_D(p,x) \in O([\text{Len}(x)]^k)$ where $k > 1$,
1. $N$ optimally computes $\text{sat}(p,n)$ in $O(n^k)$ time, and
1. $D$ optimally computes $\text{sat}(p,n)$ in $O(2^n \cdot n^k)$ time.

If that conjecture is true, then $\TimeP \neq \TimeNP$.
** Equivalent question: Is there a problem whose optimal solution is exhaustive search?
- [[https://www.cs.cmu.edu/~ryanw/improved-algs-lbs2.pdf][2010 Ryan Williams "Improving Exhaustive Search Implies Superpolynomial Lower Bounds"]]:
  "The P vs NP problem arose from the question of whether exhaustive search is necessary for problems
  with short verifiable solutions."
* Questions
Can we apply pigeonhole principle to the computation graph?

What problems are equivalent to the P vs NP problem?
* Plan
   :PROPERTIES:
   :CUSTOM_ID: plan
   :END:

- Reading list

  - [[https://en.wikipedia.org/wiki/Natural_proof][WP: Natural proof]]
  - approaches:

    - Fagin, Immerman, ...: descriptive complexity theory
    - Mulmuley, Sohoni, ...: geometric complexity theory

      - [[https://arxiv.org/abs/0709.0746][2007 Mulmuley and Sohoni, "Geometric Complexity Theory: Introduction"]]
      - [[https://arxiv.org/abs/1305.7387][2013 Landsberg "Geometric Complexity Theory: an introduction for geometers"]]
      - [[https://arxiv.org/abs/1509.02503][2015 Landsberg "An introduction to geometric complexity theory"]]
      - [[https://www.cse.buffalo.edu//~regan/papers/pdf/Reg02MSFD.pdf][Kenneth W. Regan's "Understanding the Mulmuley-Sohoni Approach to P vs.Â NP"]]
      - [[https://people.mpi-inf.mpg.de/~cikenmey/teaching/summer18/firstintrotogct/index.html][Christian Ikenmeyer's 2018 course]]

  - [[http://michaelnielsen.org/polymath1/index.php?title=Deolalikar_P_vs_NP_paper][A clearing house for Deolalikar P vs NP paper]]

- Undigested

  - One-way function implies something about P vs NP?

* Meta-research
   :PROPERTIES:
   :CUSTOM_ID: meta-research
   :END:

- Where are progress tracked?

  - [[https://rjlipton.wordpress.com/2017/02/05/a-panel-on-p-vs-np/][2017 Richard J. Lipton and Kenneth W. Regan]]
  - [[http://www.win.tue.nl/~gwoegi/P-versus-NP.htm][2016 Gerhard J. Woeginger]]
  - [[http://blog.computationalcomplexity.org/2015/08/have-we-made-progress-on-p-vs-np.html][2015 Lance Fortnow and Bill Gasarch]]
  - [[https://www.reddit.com/r/math/comments/1krrkx/what_progress_has_been_made_on_the_p_vs_np/][2014 reddit]]
  - [[http://www.ncmis.cas.cn/kxcb/jclyzs/201204/W020120424627425387644.pdf][2009 Lance Fortnow "The status of the P versus NP problem"]]

- What is the P vs NP problem?

  - Official problem description: [[http://www.claymath.org/sites/default/files/pvsnp.pdf][The P versus NP problem, by Stephen Cook, for the Clay Millennium Prize Problems]]

* Another attempt?
   :PROPERTIES:
   :CUSTOM_ID: another-attempt
   :END:

- This is an older attempt.
- This should be merged to the attempt above.
- Let:

  - $f$ be a predicate
  - $k$ be a natural number
  - $Sat(f,k)$ be the problem of finding a string $x$ of length $k$ such that $f(x) = 1$

- Lemma: If $f \in \TimeP$ then $Sat(f,k) \in \TimeNP$.
  (This should be obvious and simple to prove?)
- Conjecture: There exists a predicate whose search cannot be faster than brute force.

  - Formally: There exists $f \in \TimeP$ such that $Sat(f,k) \not \in \TimeP$.

- That lemma and that conjecture, if proven true, would imply $\TimeP \subset \TimeNP$.
- We try to prove that conjecture by diagonalization/pigeonholing?
  The set \( {0,1}^k \to {0,1} \) has $2^{2^k}$ elements,
  because by combinatorics, in the truth table, there are $2^k$ rows, and each row has $2$ possibilities.
  There are $2^{2^k}$ possible $k$-letter-string predicates.
  Suppose that a deterministic machine can solve $Sat(f,k)$ for all $f$ in $O(poly(k))$ time.
  (Can we apply pigeonhole principle to the configuration graph?)
- Every predicate can be stated in disjunctive normal form.

* Other people's works that may be related
   :PROPERTIES:
   :CUSTOM_ID: other-peoples-works-that-may-be-related
   :END:

- 2017-11-22 news about NEXP and ACC https://news.mit.edu/2017/faculty-profile-ryan-williams-1122
- an explanation in English https://danielmiessler.com/study/pvsnp/
* Circuit complexity
- [[https://en.wikipedia.org/wiki/Circuit_complexity][WP:Circuit complexity]]
** The shortest $n$-parameter boolean predicate equivalence class representative problem
- Let $E_n$ be the set of all /Boolean $n$-expressions/.

  - An /$n$-expression/ is an expression that has at most $n$ variables.
  - Formally, the syntax of $E_n$ is:

    - Constant expressions:

      - $0 \in E_n$.
      - $1 \in E_n$.

    - Variable expressions:

      - If $k \in \Nat$ and $0 \le k < n$, then $x_k \in E_n$.

        - The expression $x_k$ is purely symbolic.

          - The $x$ does not mean anything.

    - If $\alpha \in E_n$, then $(\neg \alpha) \in E_n$.
    - If $\alpha \in E_n$ and $\beta \in E_n$, then $(\alpha \wedge \beta) \in E_n$.
    - If $\alpha \in E_n$ and $\beta \in E_n$, then $(\alpha \vee \beta) \in E_n$.
    - Nothing else is in $E_n$.

- Let the /size/ of a formula be the number of operators in it.

  - We write $C(\phi)$ for the size of the formula $\phi$.
  - We say that $\alpha$ is /smaller/ than $\beta$ iff $C(\alpha) < C(\beta)$.
  - Formally we define $C(\phi)$ as:
    \begin{align*}
    C(\neg \alpha) &= 1 + C(\alpha),
    \\
    C(\alpha \wedge \beta) &= 1 + C(\alpha) + C(\beta),
    \\
    C(\alpha \vee \beta) &= 1 + C(\alpha) + C(\beta),
    \\
    C(\alpha) &= 0 \text{ otherwise}.
    \end{align*}

- Given a formula $\phi \in E_n$ and an /assignment/ $a : \{0,1\}^n$,
  we can /interpret/ the formula $\phi$.

  - The result of interpreting $\phi$ with assignment $a$ is written $\phi|_a$,
    and is obtained by replacing each $x_k$ with $a_k$
    and evaluating the expression to either zero or one.
  - This interpretation enables us to define /equivalence/,

    - Formally, we say that two formulas $\alpha, \beta \in E_n$ are /equivalent/, written $\alpha \equiv \beta$, iff
      for every assignment $a \in \{0,1\}^n$, it holds that $\alpha|_a = \beta|_a$.
      Then, we define the /equivalence class/ of a formula $\phi \in E_n$ as
      $[\phi] = \{ \alpha ~|~ \alpha \equiv \phi, ~ \alpha \in E_n \}$.

      - Every element of that equivalence class is called a /representative/ of that class.
        Note that equivalence is not equality: $x_0 \wedge x_0$ and $x_0$
        are equivalent but not equal.

    - Two formulas are equivalent iff they always give matching results for all assignments.
    - Two formulas are equal iff they look the same.
    - Equivalence is the comparison of meaning,
      whereas equality is the comparison of form.

- The set $E_n$ has exactly $2^{2^n}$ equivalence classes.

  - We label those classes $K(n,0), K(n,1), \ldots K(n,2^{2^n}-1)$.
  - Define $Q(n,k)$ as the shortest representative of $K(n,k)$.

    - Here are some examples of the shortest representatives
      that can be verified by hand:
      \begin{align*}
      Q(0,0) &= 0
      \\ Q(0,1) &= 1
      \\ Q(1,0) &= 0
      \\ Q(1,1) &= x_0
      \\ Q(1,2) &= \neg x_0
      \\ Q(1,3) &= 1
      \\ Q(2,1) &= x_0 \wedge x_1
      \\ Q(2,2) &= \neg x_0 \wedge x_1
      \\ Q(2,3) &= x_0
      \\ Q(2,6) &= \neg (x_0 \wedge x_1) \wedge (x_0 \vee x_1)
      \\ Q(2,7) &= x_0 \vee x_1
      \\ Q(2,9) &= (x_0 \wedge x_1) \vee \neg (x_0 \vee x_1)
      \end{align*}

- It should be apparent that $Q(n,2^{2^n}-1-k) = \neg Q(n,k)$.
  It should be apparent that $Q(2,6)$ is XOR and $Q(2,9)$ is bi-implication.
  It should be apparent that $Q(2,6)$ and $Q(2,9)$ are the longest expressions for $n = 2$,
  and both of them have size $4$.
- *Problem statement*:
  For each $n$,
  find $k$
  such that $Q(n,k)$ is the longest among all possible $k$.
- [[https://en.wikipedia.org/wiki/Parity_function][WP:Parity function]]?
  "The $n$-variable parity function and its negation are the only Boolean functions for which
  all disjunctive normal forms have the maximal number of $2^{n - 1}$ monomials of length $n$
  and all conjunctive normal forms have the maximal number of $2^{n - 1}$ clauses of length $n$.
  (Ingo Wegener, Randall J. Pruim, /Complexity Theory/, 2005, ISBN 3-540-21045-8, p.Â 260)"
- Relationship between $n$-expressions and $n$-cubes

  - Here we imagine what it is like to apply geometric operations to Boolean expressions.
  - Draw

    - Draw the outline of a square on a white paper.
    - Draw two lines that divide the square into four smaller subsquares.
    - Color the top right subsquare red.

      - The resulting picture represents $x_0 \wedge x_1$.

  - The result of rotating $x_0 \wedge x_1$ 90 degrees counterclockwise is $\neg x_0 \wedge x_1$.

    - Rotated once again, it becomes $\neg x_0 \wedge \neg x_1$.
    - Rotated once again, it becomes $x_0 \wedge \neg x_1$.
      _ Rotated once again, it comes back to $x_0 \wedge x_1$.

  - Define $R_2(\phi)$ as the counterclockwise-rotated $\phi$ where $\phi \in E_2$.

    - Then $R(x_0) = x_1$ and $R(x_1) = \neg x_0$.

  - Other operations:
    horizontal flip,
    vertical flip,
    negation.
  - $(R_2)^4(\phi) = \phi$.
  - On the 3-cube, there are 3 counterclockwise rotations.
  - Each $n$-expression of the form $x_k$ divides the $n$-cube into two region.

- Unnecessary

  - We define the shorthand $\alpha < \beta$ to mean that $\alpha$ is shorter than $\beta$.
    Now we can /order/ the equivalence classes in $E_n$ by their sizes.
    For every $E_n$, there exists at least one /infimum/ (greatest lower bound).
    For every $A \subseteq E_n$,
    we say that $\alpha \in \inf(A)$ iff $\alpha \le \phi$ for every $\phi \in E_n$.
  - A /bit/ is either zero or one.
  - We define the mapping $N_n : \{0,1\}^n \to \Nat$
    as a mapping from the $n$-dimensional bit vector $x = (x_0,\ldots,x_{n-1})$
    to the natural number $N_n(x) = \sum_{k=0}^{n-1} x_k 2^k$.

    - $N_n(x)$ is the number whose
      $n$-bit binary right-to-left encoding is the $n$-dimensional bit vector $x$.

  - We define the bit vector identifying the predicate as
    \begin{align*}
      B_n(\phi) = N_{2^n}( \phi(N_n^{-1}(0)), \ldots, \phi(N_n^{-1}(2^n-1)))
      \end{align*}

- Shannon 1949 proved that almost all $n$-argument boolean functions
  require circuits of size $\Theta(2^n/n)$. (citation?)
- For small numbers, we can enumerate the answers by hand.
- A formula is /canonical/ iff it cannot be shortened.

What is the longest possible canonical description length of a predicate that takes $k$ arguments?

#+BEGIN_EXAMPLE
    0000 | 0
    0001 | a \wedge b
    0010 | a \wedge \neg b
    0011 | a
    0100 | \neg a \wedge b
    0101 | b
    0110 | (a \wedge \neg b) \vee (\neg a \wedge b)
    0111 | a \vee b
    1000 | \neg (a \vee b)
    1001 | (a \wedge b) \vee \neg (a \vee b)
    1010 | \neg b
    1011 | a \vee \neg b
    1100 | \neg a
    1101 | \neg a \vee b
    1110 | \neg (a \wedge b)
    1111 | 1
#+END_EXAMPLE

Conjecture: The longest 2-argument predicate is 0110.

Conjecture: $(a \wedge \neg b) \vee (\neg a \wedge b)$ is the shortest description of 0110.

What we are asking here is Sipser 1997's /circuit-size complexity/?

- How are circuit complexity and proof complexity related?
- Simplification rewrite rules:
  \begin{align*}
  \neg (\neg \alpha) = \alpha
  \\
  \alpha \wedge \neg \alpha = 0
  \\
  \alpha \vee \neg \alpha = 1
  \\
  \alpha \vee 1 = 1
  \\
  \alpha \wedge 0 = 0
  \\
  \neg 0 = 1
  \\
  \neg 1 = 0
  \\
  \neg \alpha \wedge \neg \beta = \neg (\alpha \vee \beta)
  \\
  \neg \alpha \vee \neg \beta = \neg (\alpha \wedge \beta)
  \\
  (\alpha \wedge \beta) \vee (\alpha \wedge \gamma) = \alpha \wedge (\beta \vee \gamma)
  \end{align*}
- Is this the problem we're talking about?

  - [[https://en.wikipedia.org/wiki/Circuit_minimization_for_Boolean_functions][WP:Circuit minimization for Boolean functions]]
  - [[http://www.cs.sfu.ca/~kabanets/papers/mincircuit.pdf][Circuit Minimization Problem]], 1999, Valentine Kabanets and Jin-Yi Cai
  - [[http://www.cs.yale.edu/homes/peralta/CircuitStuff/CMT.html][Yale CS Circuit Minimization Team Work]]
  - what?

    - [[https://en.wikipedia.org/wiki/Infimum_and_supremum#Formal_definition][WP:Infimum and supremum]]
