#+TITLE: Enterprise software engineering with ontologies, models, meta-models, and Prolog
#+DATE: 2019-03-19 00:00 +0700
#+OPTIONS: ^:nil toc:nil
#+PERMALINK: /enterprise.html
#+MATHJAX: true
* Motivation
I think I may have a way to be a /30x engineer/,
or this might just be another manic episode of mine.
The idea is to use /Prolog/ to /model/ enterprise software systems and to /transform/ those models into complete /full-stack/ working code.
In my dream, the programmer writes many lines of Prolog and zero lines of Java,
which is now like Assembly: translated from a higher-level language.
Software engineering labor is now specialized into /infrastructure/ engineer (language designer, software architect)
and /suprastructure/ engineer (language user, business programmer, system analyst),
instead of /back-end/ engineer and /front-end/ engineer.
Software architect now designs formal models and formal ontologies
instead of drawing fragile charts ignored by machines.

What is an enterprise application?
Mostly information systems[fn::https://en.wikipedia.org/wiki/Information_system].

I see some similarities among enterprise applications.

What is the problem with our current approaches of building enterprise applications?
Java is too low level.
Java's ontology is not how we think about abstract objects.
Methods are not philosophically sound abstractions.
One problem is that Java doesn't know SQL:
Every SQL query is just a Java string.
SQL queries have a structure.
They have syntax and semantics.
They are not mere strings.

Brooks 1987 \cite{brooks1987no}?

Now, I need to get down to reality, and see how much of that dream can be realized.

Using Prolog to extract data and logic from legacy systems?

Using Prolog to specify refactoring?
* What does a software engineer do?
** Slave drivers
/Programmers play the same role as ancient slave drivers./
They translate and impose the master's will into the slaves.

Do programmers have god complex?[fn::https://www.reddit.com/r/java/comments/2jona4/why_does_everyone_hate_eclipse/clea9ok/]
** Formalization
One job of the programmer is to formalize the end-user's implicit ontology
into the corresponding formal ontology that can be manipulated by machines.
The programmer's job is to formalize the end-users' mental model into a formal ontology.

Requirement gathering and analysis.

Semantic-preserving translation from user syntax (natural language) to computer syntax (programming language).

Will controlled natural languages enable everyone to program the computer?
** Programming as progressive relaxation of simplifying assumptions
Programming is progressive relaxation of simplifying assumptions.

But has that activity already has another name: /modeling/.

We start with the assumption that the system does nothing.

Then we relax the assumption that all state is stored in memory.

Then we relax the assumption that errors do not happen.

Then we relax the assumption that the network latency is zero.

Then we relax the assumption that the user is willing to wait forever.

And so on.
* The end-user's mental model
** Understanding the end-user's train of thought
I think software development can be sped up by minimizing the gap between the end-user's mental model and the programmer's mental model.
Matching mental model is a requirement of good user experience.

The users think of a software system as the set of things that they can do with it,
as the set of the ways they can interact with the system,
as a set of possible queries and commands.
The user's mental model is imperative/procedural.

We classify things all the time.
At first, evolutionarily, I think we classify things into two: those that help us survive, and those that do not.
Every adjective divides the world into two: the set of things that satisfy it, and the set of things that don't.
We classify things into food and non-food, drink and non-drink, kin and non-kin, harm and non-harm, insider and outsider.

For example, everyone knows that profit is income minus expenses.
But not everyone has the same idea about income.

UML can express cardinality constraints, but only 1:1, 1:N, N:1, and M:N are implementable in SQL.
But that is no problem.
Zero, one, or infinity.[fn::https://en.wikipedia.org/wiki/Zero_one_infinity_rule]
** Their practical philosophy, mental model, and ontological commitments
The users know their goals, but they don't know how to interact with the software system to achieve those goals.

The users have an ontology, although they may not be aware that it is called "ontology".
The users have a /mental model/ of what classes and individuals exist in the software system.
The users have an idea about what the software system knows and what it does not.
The users apply their /theory of mind/[fn::https://en.wikipedia.org/wiki/Theory_of_mind] to the software system.
They may be thinking in terms of classes, properties, and individuals.
They may be thinking in terms of objects, properties, and values.
They may be thinking in terms of entities and relationships[fn::https://en.wikipedia.org/wiki/Entity–relationship_model].
Which is the users' mental model:
object-property-value, entity-relationship, or something else?

The users believe that pressing the "Save" button will cause the system to "remember" something.
Thus the users think of a software system as a combination of memory and rules.

We readily think in classes.
We readily categorize things.

What is a layperson's ontology?

For example, what is a chair?
The answer depends on what problem we are trying to solve.
- A chair is something we can sit on?
  But we can also sit on the floor.
- A chair has four legs?
  But a chair may also have three legs.
- Must a chair have back rest?

A chair has two essential aspects: sittability and back rest.
Thus a chair is something that a human can sit on and rest his/her back.

A general ontology is too cumbersome for developing enterprise software.
An overkill.
Excessive.
Lots of unused expressiveness.

For developing machine-helps-human enterprise software,
the ontology implied by Java and EMF is too poor,
and a general ontology such as SUMO is too rich.

A software system is a subsystem of the bigger supersystem that includes the software, the user, and the interaction between them.
Should model-driven development also model the /user/?

There are two kinds of enterprise software systems:
- those that help humans
- those that replace humans

The ontology should enable these:
- generate Java+SQL+HTTP+HTML+JavaScript application, with the behavior and GUI; programmer writes Prolog and zero lines of Java
- draw what graphics about the system?

Objects have identity.

How do software users think about what exists?
What is their mental model?

How does the user think about a web application?
Teleologically.
A stateful system.
A rigid assistant.
What can the user do with it.

Software users assume that abstract objects exist when they are using the software[fn::http://williamnava.com/abstract-objects-exist/].
Software users suspend their disbeliefs[fn::https://en.wikipedia.org/wiki/Suspension_of_disbelief] as long as they are using the software.
Gamers suspend their disbeliefs while they are playing.
Of course we know that an email does not have to have material existence.
But we also know that our reaction to emails is real, and thus emails can have real effects.

For example, consider email provider.

- A mail exists.
- A mail may have replies.

How do business users think of what exists?
What is their implicit ontology?

Example statements:

    - Positing the existence of ideal objects, declaring by fiat:
        - There exists a concept of employees.
        - There exists a concept of departments.
    - Declaring that an object belongs to a class:
        - "John" is an employee.
        - "Engineering" is a department.
    - Declaring that a class has an attribute:
        - An employee has a name.
        - A department has a name.
    - Declaring relationships:
        - An employee belongs to a department.
        - A department contains several employees.
    - Specifying an attribute:
        - The name of an account is a character string.
    - Constraints
        - Prices should not be negative.
        - Some people should not have access to something.

May an attribute have an independent existence from the object that has that attribute?
This is the "problem of universals".

Kinds of relations:

    - A is /detailed/ by B iff B cannot exist independently of A

#+BEGIN_EXAMPLE
concept(employee).

spo(each(employee), has(1), name).
spo(property(employee,name), is_a, string).
spo(property(employee,name), max_byte_count, 16).

concept_attribute_type(employee, name, #string).
#+END_EXAMPLE

The user thinks that, for each class, the system knows a set of individuals of such classes.
For example, there is an implicit set of employees known by the system.

/Computerizing the process does not change the user's ontology./
The user has the same ontology, regardless of whether the accounting is done by hand or by machine.
The business process has existed before computerization.

The user thinks that an accounting transaction is one object.
The computer stores an accounting transaction as several rows in a table.
The user expects to input a transaction in one HTTP request.
The user does not expect to submit each part of the transaction separately.
SQL conflates aggregation, composition, and what?
SQL conflates mereology and relationship?
SQL conflates whether one X is related to many Y and whether one X consists of many Y.
SQL conflates relationship and composition.
But we have nullable foreign keys to distinguish between association, aggregation, and composition?
Aggregation vs composition:
In aggregation, the children can exist independently of the parent.
Not so in composition.[fn::https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-aggregation-vs-composition/]
** What
Formal ontology, knowledge representation, modeling an enterprise software in Prolog

Synonym set: domain of discourse, domain of interest, subject matter

Related: expert system
** Gradual refinement of ontologies
Here we try to build ontologies by gradually adding constructs and thus gradually increasing expressiveness.
This gradualism imitates van Roy & Haridi 2004 \cite{van2004concepts}, but this is about ontologies instead of computation models.
Adding more constructs increases expressivity but decreases reasonability.

Increasing expressiveness:
- propositional logic
- first-order predicate logic
- classes and properties; instantiation
- entities and relationships = classes and properties + relationships
- subclassing, subtyping, subsumption?
- upper ontologies

Propositional logic is used in simple logic circuits.
Microwave door interlock.
Vending machine coin change.
Air conditioner remote control.
#+BEGIN_EXAMPLE
microwave_is_on :- door_is_closed, button_is_down.
#+END_EXAMPLE

The limit is that one proposition can only model one entity (one thing, one object).
#+BEGIN_EXAMPLE
nat(z).
nat(s(A)) :- nat(A).
#+END_EXAMPLE
In propositional logic we would need an infinite number of propositions
that correspond to the ground terms satisfying nat/1.
#+BEGIN_EXAMPLE
nat_z.
nat_s_z.
nat_s_s_z.
% ...
#+END_EXAMPLE

At the most trivial level, /some things exist/.
The following Prolog program models reality, in the sense that there is an interpretation of exist/0 that is true in reality;
for example, we may interpret exist/0 to mean "we exist".
#+BEGIN_EXAMPLE
exist.
#+END_EXAMPLE

It is easy to model the static existence of timeless abstract objects.
We just add a fact for exist/1.

The next level is /classes and properties/.
A property is a mathematical function whose domain is the set of objects
and whose codomain is the set property values.

Class-property modeling is intuitive and uncontroversial.
Entity-relationship is class-property plus relationship.

Parametrization (adding parameters) is one way of increasing the level of abstraction.
Example:
#+BEGIN_EXAMPLE
john_eat_hamburger. % very specific: can only model one object
eat(john,hamburger). % more general: can model all eating facts
spo(john,eat,hamburger). % even more general: can model all static facts
#+END_EXAMPLE

There is a diminishing return with increasing abstraction.
We want a Goldilocks abstraction: not too specific, but not too general.

#+BEGIN_EXAMPLE
class(employee).
class_property(employee, name).
class_property(employee, join_date).

class(department).
class_property(department, name).
class_property(department, establish_date).

relationship(work_at, [employee,department]).
#+END_EXAMPLE

#+BEGIN_EXAMPLE
person(john).
person_name(john, "John Doe").
person_website(john, "https://example.invalid/").
person_email(john, "john@example.invalid").
#+END_EXAMPLE

The database is in 6NF.
The advantage is extensibility:
this representation simplifies adding new properties, be it derived or not:
we just add a predicate.

Its weakness is its repetitiveness:
we have to repeat the person_ prefix and the surrogate key =john=.

#+BEGIN_EXAMPLE
person_proplist(john, [
    name-"John Doe"
    , website-"https://example.invalid/"
    , email-"john@example.invalid"
]).

person_name(P, V) :- person_proplist(P, L), member(name-V, L).
person_website(P, V) :- person_proplist(P, L), member(website-V, L).
person_email(P, V) :- person_proplist(P, L), member(email-V, L).
#+END_EXAMPLE

But that has two problems:
- That cannot express the cardinality[fn::also called "degree of relationship" or "multiplicity"][fn::https://en.wikipedia.org/wiki/Cardinality_(data_modeling)] of relations.
- That cannot express the type of property values, but we can add class_property_type/3.

SQL implements some cardinality constraints with unique indexes.
A property translates to an SQL column.
An entity translates to an SQL table with a surrogate primary key.
A relationship of arity N translates to an SQL table with N columns, each a foreign key to the corresponding entity table.

But what are the cardinalities of high-arity relations?

There are two problems:
- What exist?
- How do we talk about what exists?
  What language should we use?

Skeletons and shells \cite{sterling1996logic}

"Ontological commitment is an agreement to consistently use a vocabulary with respect to a theory specified by an ontology"
\cite{jurisica1999using}

If A is a /subclass/ of B, then every instance of A is /also/ an instance of B.

At which level is OWL?

OWL Lite vs DL vs Full[fn::https://ragrawal.wordpress.com/2007/02/20/difference-between-owl-lite-dl-and-full/].

What is the Bunge--Wand--Weber ontology?
"BWW ontology is a generic framework for analysis and conceptualization of real world objects"

What is the Shlaer--Mellor method?
** Classes and instances; universals and particulars; and properties
/Classes and instances/ are also called /universals and particulars/.

We group things into classes because we want to /uniformly/ treat every instance of the class.
Which is more important, that two things are similar in essence, or that two things can be used for the same purpose?

IF class C has property P of type T,
AND I instance of C,
AND the P of I is V,
THEN V instance of T.
#+BEGIN_EXAMPLE
instance_property_value(I, P, V) :-
    instance_class(I, C),
    class_property(C, P, T),
    instance_class(V, T).
#+END_EXAMPLE

Example: the color of a car.

#+BEGIN_EXAMPLE
class(car).
class(color).

class_property_type(car, color, color).

instance_class(john, car).
instance_property_value(john, color, red).

instance_class(mary, car).
instance_property_value(mary, color, blue).

class_instance(color, red).
class_instance(color, green).
class_instance(color, blue).
#+END_EXAMPLE
** Statics and dynamics; structure and behavior
Models of a software system can be divided into two groups:
- structural model,
- behavioral model.

The type system/checking is software statics and the code is the software dynamics.

There are the statics and the dynamics of a software system, like branches of mechanics in physics.

Class-property model.
Entity-relationship model.

Synonyms: class, category, concept

Synonyms: object, thing, entity

Synonyms: property[fn::https://en.wikipedia.org/wiki/Property_(philosophy)], attribute[fn::https://en.wikipedia.org/wiki/Attribute_(computing)]

What is a concept?[fn::https://en.wikipedia.org/wiki/Concept]
** Philosophy of abstract objects?
*** What does it mean for an abstract object to exist?
Is software development applied metaphysics?
 [fn::https://skepticalmethodologist.wordpress.com/2013/12/08/software-development-applied-metaphysics/]
 [fn::https://www.eschrade.com/page/metaphysics-and-software-design/]

Theory of abstract objects[fn::https://mally.stanford.edu/theory.html]

What does it mean for a mathematical object to exist?[fn::https://www.math.toronto.edu/mathnet/answers/existence.html]

It is simple to define a mathematical object.

Describability does not imply existence.
Imaginability does not imply existence.

Whether anything exists depends on how we interpret "thing" and "exist".
For example, if by "unicorn" we mean horned horse, and by "exist" we mean to have material existence, then no, unicorns do not exist.
If by "exist" we mean to be imaginable, then yes, unicorns do exist.
What is a unicorn?
If we transplant a horn onto a horse, would it be a unicorn?
Must a unicorn be a unicorn by birth?
It is conceivable to draw unicorns.
A search on the Internet produces an image in a few seconds.
Does the question "Does unicorn exist?" even make sense at all?
Can everybody agree on what a unicorn is and what existence is?
What is existence?[fn::https://www.ontology.co/existence.htm]
*** Abstract objects, concrete consequences
Ranking algorithms have real consequences.
Algorithms impose onto everyone the value system of the programmers.
** What is the difference between ontology and metaphysics?
** OWL
We shall concern ourselves with the Primer[fn::https://www.w3.org/TR/2012/REC-owl2-primer-20121211/]
and not the other documents[fn::https://www.w3.org/TR/2012/REC-owl2-overview-20121211/#Documentation_Roadmap] for implementors.

It is straightforward to translate the Functional-style syntax examples in OWL 2 Primer to Prolog.

OWL and Prolog differs in open vs closed world.

OWL assumes open world:
- If \(p\) is provable, then \(p\) is true.
- If \(\neg p\) is provable, then \(p\) is false.
- If neither of \(p\) or \(\neg p\) is provable, then \(p\) is possible (unknown).

Prolog assumes closed world:
- If \(p\) is provable, then \(p\) is true.
- If \(p\) is not provable, then \(p\) is false.

We can use closed-world assumption in our enterprise software model.
If a class is not modeled in the Prolog, then it will not be in the generated Java source code.

an example of second-order reasoning in OWL[fn::http://www.xfront.com/why-use-owl.html]
** The ontology of enterprise web applications?
*** Entities
An /entity/ is something that has identity.
Every entity is distinguishable from other entities.
*** Properties (extrinsic properties)
A /property/ of an entity is something that makes the entity what it is.

In software modeling, properties are usually extrinsic properties.

An extrinsic property of an entity is something we give to the entity, not something that comes with the entity.

Examples of properties:

- The name of a person is an extrinsic property.
  Changing his name doesn't change what I think of him.
- The name of a hotel is an extrinsic property.
  Changing the hotel's name does not change my willingness to stay in it.

A /property/ is a function from entity E to value V.

https://en.wikipedia.org/wiki/Intrinsic_and_extrinsic_properties
*** Combining entities
*** Mapping entities to storages
** RDF triples
Similar concepts:
- subject-predicate-object in Semantic-Web RDF
- object-property-value in philosophical ontology
- entity-attribute-value in computer programming
** Objects
An object has identity.
Two objects may have the same properties,
but if their ObjectId differs, then they are not identical.
* Ontology engineering
We shall begin to design an ontology by formulating the /competency questions/ \cite{noy2001ontology}:
the questions that the ontology should be able to answer.

For example, accounting system competency questions:
- What is our balance sheet this year? (This is a lot of questions: What is our assets this year, what is our liabilities this year, etc.)
- How much profit/loss do we make this year?
- How much tax does the government expect to racketeer from me this year?

Smith 2006 "Against Idiosyncrasy in Ontology Development" \cite{smith2006against}

The end goal of an accounting ontology is for reporting, auditing, automation, calculation, and integration.

For example, hotel supply chain management tool competency questions:
- Should we restock property P?
  - What is the current stock level at property P?
  - How many rooms do property P have?
  - When do we expect property P to run out of stock?
- When did a property experience stock-outs?

Slide 6: five ways to represent knowledge[fn::https://www.scss.tcd.ie/Owen.Conlan/CS7063/06%20Introduction%20to%20OWL%20(1%20Lecture).ppt.pdf]

Should we teach ontology design with wine examples?

Ontology Development Pitfalls[fn::http://www.adampease.org/OP/Pitfalls.html]

One source of confusion is the many meanings of the copula.[fn::https://en.wikipedia.org/wiki/E-Prime#Different_functions_of_%22to_be%22]

Ontology of opinions?
Relationship between a person and an opinion:
approve, disapprove, unaware, indifferent, impartial, ignorant.
The sentiment of an opinion is either positive, neutral, or negative.

Ontology is not only taxonomy/classification/categorization.
What is the difference between taxonomy, classification, and categorization?
What is the difference between taxon, class, and category?

What is the difference between ontology and model?
Ontology = model + meta-model + logic?

UEML/GEM vs OWL \cite{khan2011transformation}.
Enterprise software model (UEML, GEM) vs enterprise software ontology (on OWL perhaps)?
* Bending Prolog to my will
** Component/module system, socket-plug metaphor
I need a component system for programming in the large.
Prolog module system is a building block, but Prolog modules by themselves are not enough.
Socket-and-plug metaphor fits nicely?
The name tells it all:
a socket is a female connector and a plug is a male connector,
and we connect plugs to sockets,
and Prolog should complain if it sees a socket that is connected not exactly once.

An input is a multifile predicate.

A pin is a Name/Arity term.

A plug exports symbols.

A socket imports symbols.

A module may have multiple plugs and sockets.

Pins are matched by NameArity.
The ordering of pins does not matter.

A Prolog module system is either /predicate-based/ or /atom-based/.
XSB is atom-based.
SWI is predicate-based.
GNU Prolog does not have a module system.
** Using Prolog for model-driven enterprise software engineering
The system is being sketched at a directory in our Git repository[fn::https://github.com/edom/work/tree/master/software/enterprise].
This document is a sketch of that system.
Not much has been implemented.

The expected workflow:
- Model the application in Prolog.
- Then transform the model into implementation.
  Two choices:
  - Translation: Transform the model to source code in a supported language.
  - Interpretation: Execute the model in Prolog.
** Bottom-up vs top-down
The bottom-up way is to start with Java and SQL, and abstract both Java and SQL into fUML/ALF or something else, etc.

The top-down way is to start with the business users' mental model, and ...?
** Modeling the application in Prolog
Clarify the ontology first.
The model follows from the ontology.

For example:
#+BEGIN_EXAMPLE
class(employee).
class_property(employee, name).

class(department).
% ...

relation(work_at, [employee,department]).
% ...
#+END_EXAMPLE
** The easy things: Modeling static structures
A Java program corresponds to one JVM instance.
A Java program is a set of source codes and dependencies.

A model of a Java program is straightforward:
class/1, class_package_name/2, class_name/2,
class_field/2, field_name/2, field_type/2, and so on.

A model of relational databases is straightforward:
table/1, table_name/2, table_column/2, column_name/2, and so on.
** The hard thing: abstracting both Java and SQL into ER and PAL?
ER = entity-relationship

PAL = procedural action language; similar to fUML ALF
** The even harder thing: combining them all into a coherent abstraction
** Modeling a web application?
*** Picking a modeling language
I have narrowed down:
- a relational language such as Prolog, Kanren, Mercury
- a functional language such as Haskell, Idris, Ocaml, ML
- TypeScript, Racket, Scheme, Lisp, Lua

There are too many choices.
What is the /semantics/?
What is the /essence/?
- https://en.wikipedia.org/wiki/Modeling_language

What is AsmL?
https://cs.wmich.edu/~OODA/translate.html
*** Example of modeling web application
What do we think a web application is?

What do users think?
What do users care?
What are the users' mental model?
How can we formalize the users' mental model, and use that formal model to develop an application with less effort?

Users think of an app as a /tool/, like a complicated hammer:
- What was it originally invented for? What is it supposed to do? What is it usually used for? (Drive nails into wall)
- How do I use it? (Grip the hammer, and hit the nail)
- What can I use it for? (Cracking this clam open? Destroying this stuff? Killing a house intruder? Euthanizing a dying dog?)

An application (a web application) maps a HTTP request to a HTTP response.

We use a Prolog atom to /refer/ to an /entity/ (something that is unique, has an identity, is identical only to itself, is not identical to any other entity).
Thus a Prolog atom is similar to an English /word/, and the Prolog knowledge base /gives meaning/ to that atom.

The formula =application__sql_table(A,T)= means that application A uses SQL table T.

The formula =application__page(A,P)= means the application A serves page P.
*** Zotonic?
Zotonic's authors at least has thought about its ontology
http://zotonic.com/page/618/flexible-datamodel
*** Ur/Web?
Language-level integration.

** The meaning/interpretation of Prolog programs
*** The meanings of a Horn clause
A Horn clause in Prolog looks like =A :- B=.

A Horn clause can be thought of in several ways.

The operational meaning of =A :- B1, ..., Bn= is that calling the procedure A causes B1, ..., Bn to be called in that order.
This is the actual meaning of Prolog programs.
All other meanings are useful fantasies.

The classical-logic reading of =A :- B= is \(A \leftarrow B\), that is, "A is true if B is true" or "A is implied by B".

The proof-theoretic reading of =A :- B= is "to prove \(A\), it is enough to prove \(B\)".

The search-tree reading of =A :- B1, ..., Bn= is that the tree node A has the children B1, ..., Bn.

These multiple readings are confusing.
For example, the classical-logic reading implies that querying =a= against the following knowledge base should succeed because in classical logic \( A \leftarrow (B \wedge A) \equiv A \leftarrow B \),
but the query =a= actually does not terminate.
#+BEGIN_EXAMPLE
a :- b, a.
b.
#+END_EXAMPLE
In classical logic but not in Prolog,
that knowledge base is equivalent to this:
#+BEGIN_EXAMPLE
a :- b.
b.
#+END_EXAMPLE

Enhancing the declarativeness of Prolog requires /memoization/.

What is the relationship between logic programming, relational programming, logic, Horn clauses, theorem proving, searching, and backtracking?
*** Epistemic interpretation of Prolog programs: Failure as ignorance
Sometimes a Prolog program should be interpreted epistemically,
in which Prolog's /fail/ is treated as /unknown/ instead of /false/.
Succeeding to prove a goal G means that we know that G is true.
Failing to prove a goal G means that we do not know anything about G.

=\+G= means we do not know G.

Succeeding to prove not(G) means that we know that G is false.
#+BEGIN_EXAMPLE
:- multifile not/1.
#+END_EXAMPLE

There is a difference between not/1 and \+/1.
In the epistemic interpretation, "\+" should be read as "unknown".

We waive the law of excluded middle.
In our Prolog program it does not hold that G ; not(G).

Suppose is_big(john).
If is_big(X) fails, it simply means that we don't know whether X is big.

Suppose that is_big(john,true) means we know that John is big.
And is_big(john,false) means we know that John is not big.
If is_big(john,_) fails, then we don't know whether John is big or not.
*** Some Prolog tricks?
Prolog =\+= can be used to limit the scope of unification, although not the scope of the variable itself.
This exploits the fact that throw/1 does not backtrack in the way fail/0 does.

When using Prolog procedurally, we often want throw/1 instead of fail/0.

It makes more sense to design a procedural DSL on Prolog than to use Prolog itself procedurally.
** The procedural-provability-logic interpretation of Prolog Horn clauses
=p :- q, r= can be interpreted as "to prove p, first prove q, and then prove r".
*** Problem: Horn clauses and biimplications
Classical propositional logic formula \( a \iff b \) (which is equivalent to \((a \to b) \wedge (b \to a)\)) does /not/ translate to this Prolog program:
#+BEGIN_EXAMPLE
a :- b.
b :- a.
#+END_EXAMPLE
Querying =?- a= does not terminate.

This terminates:
#+BEGIN_EXAMPLE
% H is the hypothesis bag.

a(H) :- member(a,H).
a(H) :- \+ member(a,H), b(H).

b(H) :- member(b,H).
b(H) :- \+ member(b,H), a(H).
#+END_EXAMPLE

** Writing enterprise web applications?
*** Comparison between ontology, relational programming, and database programming
Open World Assumption vs Closed World Assumption http://www.mkbergman.com/852/the-open-world-assumption-elephant-in-the-room/

How do we combine closed-world assumption (logic programming / relational database) and open-world assumption (web ontology)?
*** Knowledge representation and software specification
**** Their relationships
- 2010, "Functional-Logic Programming Lecture Notes", Harold Boley, slides, [[http://www.cs.unb.ca/~boley/FLP/cs6905FLP.pdf][pdf]]
  - Knowledge representation in AI roughly corresponds to software specification in software engineering.
  - Declarative programs can be thought as executable specifications.
  - Invertibility principle (slide 36)
  - Nesting/conjunction principle (slide 46)
  - Unification principle (slide 50)
  - Amalgamation/integration principle (slide 55)
  - That's a long deck: 270 slides.
**** Executable specification?
- lightweight executable mathematics https://www.cl.cam.ac.uk/~pes20/lem/

*** Logic programming vs theorem proving
- https://stackoverflow.com/questions/36335633/difference-between-logic-programming-and-automated-theorem-proving
- https://en.wikipedia.org/wiki/Automated_theorem_proving
*** SWI-Prolog, PostgreSQL, and ODBC
Install the Ubuntu 14.04 package =odbc-postgresql=.

I want my application to self-contain its configuration.
I don't configure ODBC INI files.

ODBC Data Source Name (DSN) connection string

Relevant commands: =odbcinst -j=

The file =/etc/odbcinst.ini= contains a list of driver names.

[[http://www.swi-prolog.org/pldoc/doc_for?object=section(%2527packages/cql.html%2527)][SWI-Prolog CQL documentation]] doesn't inspire confidence.
*** Deductive databases and Datalog?
** Related fields
Formal methods, formal verification, model checking
** Nonsensical models due to violation of simplifying assumption
It is possible to have a record in which an employee's join date precedes the date of birth.
But it is physically impossible for an employee to join the company before the employee is born.
Every model has simplifying assumptions.
** Ontology?
A class C has properties P1, P2, P3, etc.
How do we represent an /instance/ of C in Prolog?
There are at least two ways: /many-predicates/ and /one-term/.

The /many-predicates/ representation makes it easy to add derived properties.
One predicate represents one property.
This is similar to 6NF (sixth normal form) in database theory.

#+BEGIN_EXAMPLE
c_prop1(InstanceId, Prop1).
c_prop2(InstanceId, Prop2).
c_prop3(InstanceId, Prop3).
...
#+END_EXAMPLE

The /one-term/ representation makes it easy to specify an instance.
One term represents one instance.
This is similar to 0NF/1NF (zeroth or first normal form) in database theory.

#+BEGIN_EXAMPLE
c(InstanceId, [
    prop1 - Prop1,
    prop2 - Prop2,
    prop3 - Prop3,
    ...
]).
#+END_EXAMPLE

But we can combine both.
We can translate an instance-wise representation to a property-wise representation:

#+BEGIN_EXAMPLE
:- discontiguous c_prop1/2, ..., c_propN/2.

c_prop1(InstanceId, Prop1) :- c(InstanceId, Props), member(prop1-Prop1, Props).
c_prop2(InstanceId, Prop2) :- c(InstanceId, Props), member(prop2-Prop2, Props).
c_prop3(InstanceId, Prop3) :- c(InstanceId, Props), member(prop3-Prop3, Props).
...
#+END_EXAMPLE

But the many-predicates representation is easier to refactor than the one-term representation.

Conclusions:
- A module may internally specify objects in the one-term (denormal-form) style,
  but should only export predicates in the many-predicates (normal-form) style.
- A translation should not import denormal-form predicates.

** A note on temporal modeling
=employee_department/2= cannot keep track of movement history.
If it is important to keep track of employee movement,
we should use =employee_join_department/3= and =employee_leave_department/3=.

#+BEGIN_EXAMPLE
employee_department(?EmpId,?DepId)
employee_join_department(?EmpId,?DepId,?Time)
employee_leave_department(?EmpId,?DepId,?Time)
#+END_EXAMPLE
** One-property-one-predicate representation of objects
Another core idea is the /one-property one-predicate/ representation, with surrogate primary keys.
This enables us to represent objects in Prolog.
Objects have identities.
Two objects are identical iff their identifiers (primary keys) are equal.
Example:
#+BEGIN_EXAMPLE
person(PersonId)
person_name(PersonId, Name)
person_birthdate(PersonId, BirthDate)
#+END_EXAMPLE
** A relation can be thought as an interpretation of function terms, or, how Prolog is ideal for writing DSLs
For example, m0/2 and m1/2 give different meanings to the same function term f/1.
#+BEGIN_EXAMPLE
m0(f(X), Y) :- Y is X+1.
m1(f(X), Y) :- Y is 2*X.
#+END_EXAMPLE

Prolog is ideal for writing DSLs because:
- We can embed the abstract syntax in Prolog syntax.
  We can skip specifying the grammar and go directly to specifying the semantics.
- Specifying the semantics is straightforward.

#+BEGIN_EXAMPLE
exp_val(S, T) :- string(S), !, S = T.
exp_val(S, T) :- number(S), !, S = T.
exp_val(A+B, C) :- string(A), string(B), !, string_concat(A, B, C).
exp_val(A+B, C) :- number(A), number(B), !, C is A+B.
#+END_EXAMPLE
** Abstractions
The system should present the illusion that every system state is as simple as a global variable.
A PostgreSQL table is modeled as a global variable whose type is list.
** Logic of objects
"Mapping Objects to Persistent Predicates"
https://pdfs.semanticscholar.org/f1ec/9e0e24faa1332d0cb60149e1d633b8d2509e.pdf

Should we write our DSL in Twelf instead of Prolog?
http://twelf.org/wiki/LF

"Objects with logic" 1990
https://dl.acm.org/citation.cfm?id=100368



The difference between object and value is that an object has identity.

Must everything have a name?

An object has properties.
A property is a key-value pair.

There are several ways to /represent/ such objects in Prolog.

The 1-object-1-term representation represents an object as a ground term.
There are two choices for such term: (1) a Prolog functor whose arity is the object's property count, or (2) a list of key-value pairs.
The meaning of such representation is that iff the list L contains K-V, then the represented object has a property K whose value is V.

The 1-property-1-predicate representation represents each property as a predicate, but this requires /unique surrogate naming/ of the object for identification:
object_property1(O,P).
object_property2(O,P).

It is surprising that database normalization theory explains some characteristics of good Prolog code.

Example:
Suppose that there are two people Alice and Bob.

The question: is the object an /entity/ or a /value/?
An entity has identity.
A value does not have identity.
A natural number does not have an identity.
A person has an identity.
Two people may have the same name while still being two different people.
The same natural number may be referred with a Arabic numeral or a Chinese numeral, but both of them refer to the same natural number.

The 1-object-1-term representation:
[name-"Alice", birthdate-date(1990,1,1), pets-[cat,dog]]
[name-"Bob", birthdate-date(1990,1,1), pets-[cat,dog]]

The 1-object-1-predicate representation:
person([name-"Alice",birthdate-date(1990,1,1)).
person([name-"Bob",birthdate-date(1990,1,1)]).

The 1-property-1-predicate representation (is this database in sixth normal form?):
person_name(alice,"Alice").
person_pet(alice,cat).
person_pet(alice,dog).
Note that we do not write person_pets(alice,[cat,dog]).
person_name(bob,"Bob").

The ontological representation:
kind_surrogate_property_value(person,alice,name,"Alice").
kind_surrogate_property_value(person,alice,birthdate,date(1990,1,1)).

The parameter O serves as an internal name.
The equality of that parameter determines the identity of the represented object.

https://en.wikipedia.org/wiki/Triangle_of_reference
http://www.jfsowa.com/ontology/ontometa.htm


Two objects can be equal but not identical.

A value has no identity.
An object has an /identity/.

Iff object_property(O,P) is provable, then object O has property P.
* What mess?
** Model transformation as Horn clauses
Model transformation is a Prolog module (a set of Horn clauses).

The idea is to represent a model transformation as a set of Horn clauses in Prolog.
For example, we state that "There is a Java class for each SQL table" as:
#+BEGIN_EXAMPLE
java_class(sql_dto(T)) :- sql_table(T).
#+END_EXAMPLE

A more general way to write that:
#+BEGIN_EXAMPLE
% opv = object-property-value
object(java_class(sql_dto(T))) :- object(sql_table(T)).

opv(java_class(sql_dto(T)), name, JavaName) :-
    opv(sql_table(T), name, SqlName),
    sqlname_javaname(SqlName, JavaName).
#+END_EXAMPLE
** Total code generation from model/ontology
We aim for /total/ code generation from model/ontology.
Not only structure (Java classes and fields), but also behavior (Java method contents).
Not only the static aspects, but also the dynamic aspects.
Some model-driven software development approaches such as EMF models the structure but not the behavior;
thus they are not expressive enough to express all the information required to translate the model into a complete program,
but only the entity classes and perhaps some validation and serialization;
the engineer still has to write Java code.
Some others such as fUML/ALF try to also model the behavior.
** Mixing bottom-up and top-down
There are two ways to something complex (that is pretty much anything): /bottom-up/ and /top-down/.

There are two ways to design an ontology or a software:
/bottom-up/ (gradual abstraction) and /top-down/ (gradual concretion).

The advantages of bottom-up:
- The abstraction has been proven to be useful and necessary.
- Program development can start early, feedback is immediate, psychological reward, user can try system.

The advantage of top-down is philosophical soundness.
The disadvantage of top-down is that it is prone to creating over-engineered abstractions.

There are two camps in programming:
the bottom-up camp and the top-down camp.

The bottom-up camp starts from machines and goes up toward mathematics.
This camp produces Assembly, Fortran, Cobol, Pascal, C, C++, Go.
This camp produced fast but ugly implementations.
Haphazard incremental improvements.

The top-down camp starts from mathematics and goes down toward machines.
This camp produces Lisp, Scheme, Prolog, ML, Ocaml, Haskell, Coq, Idris, Agda, Lean.
This camp produced elegant but slow implementations.
Big design up front.

They seem to be converging to a middle ground: ugly and slow.

Why can't we get fast and elegant?
** Unifying several closely-related subfields
These are close.
We should unify these.
- ontology engineering and model-driven software development
- database theory, logic programming, and relational programming

Database normalization theory is related to writing good logic programs.
** The human aspects of the envisioned usage: infrastructure engineers and suprastructure engineers
- Suprastructure software engineer (language user) captures business logic into high-level program.
  - Source code should be human-readable article.
  - This steps focuses on describing what things exist and the relationships between them.
  - This steps focuses on modeling.
- Infrastructure software engineer (language designer) maps high-level languages to low-level languages.
  - Example of low-level programming language: Java, C#, C++, C, SQL, Scheme, Lisp, Haskell.
  - This steps focuses on the modeling language.
- some mention of "suprastructure" and "infrastructure" https://en.wikipedia.org/wiki/Process_architecture
** Language-oriented programming, domain-specific languages (DSLs)
The 2010 article "Using DSLs for Developing Enterprise Systems" [[https://research.cyber.ee/simpl/enterprise-dsl.pdf][pdf]]:

- It uses the terms "language engineer", "transformation specialist", and "business engineer".
- It defines several usage scenarios of DSLs.
- It defines five criteria for comparing DSL tools.
- It compares some DSL tools.

That paper should have been a wiki article.
** A type system that is an algebra of unary predicates
This is just an algebra of sets.

A type can be thought as a set.
A set can be thought as a unary predicate.
A type can be thought as a unary predicate.
\begin{align*}
p \wedge q &= \forall a (p'(a) \wedge q'(a))
\\
p \leftarrow q &= \forall a (p'(a) \leftarrow q'(a))
\\
gt(10) &= \forall a. gt'(a,10) = \forall a. a > 10
\end{align*}
where \(p'\) means the meaning (the unary predicate interpretation) of \(p\).

The algebra of unary predicates is analogous to the algebra of sets[fn::https://en.wikipedia.org/wiki/Algebra_of_sets]:
conjunction is intersection,
disjunction is union,
implication is subset, etc.
** Software architecture of logic programs?
How should logic programs be architected?
Can we generate architecture from semantics?
** Some kinds of software systems
Some flavors of big software systems with similar characteristics and programming techniques:
- enterprise programming
- game programming
- operating-system programming, hardware programming, device driver programming

Can we build every big software with model-driven software engineering?

Operating system exists because programming languages are inadequate.
Singularity operating system.
** Developing software for the Web
*** The Web was not designed to be a software platform
- [[https://news.ycombinator.com/item?id=11035143][The sad state of web development]] (not everyone agrees).
- It's time to kill the web https://blog.plan99.net/its-time-to-kill-the-web-974a9fe80c89
  - from https://twitter.com/tehjh Jann Horn's Twitter
    - At that time Jann Horn was a member of Google's Project Zero
      https://blog.plan99.net/what-should-follow-the-web-8dcbbeaccd93
- Why not infinite scrolling?
  - Do you have an alternative to infinite scrolling?
  - Do you handle network interruptions?
    How does the user continue scrolling after network connection is restored?
    Is there an unhandled exception in your script?
*** Web application frameworks?
http://zotonic.com/
*** TODO How do we develop enterprise web applications efficiently?
**** <2018-09-27> Enterprise application development is like three blind people describing an elephant.
Every team is a blind people.

The company's actual ontology is the elephant.

How do we unify enterprise systems?
Should we combine subsystem ontologies to produce the actual ontology,
or should we derive subsystem ontologies from the actual ontology?
** Mathematical history?
Gillies 2002 \cite{gillies2002logicism}
has a concise insightful historical summary explanation
of the three schools of mathematics: logicism, formalism, and intuitionism.
** Even technical writing should be narrative
"A group of well-formed sentences does not necessarily form a coherent paragraph.
The order in which they are placed can significantly alter the ease with which they can be understood" \cite{de2007narrative}

The problem with description: it does not tell /why/.
A narration or an argument tells why.

Structuring our writing as narrative may help expose the incoherence.
** Presentation is accidental complexity
The essence of an interaction is the conveyed information, not the appearance.
HTML is accidental complexity.
An interaction is either a /query/ or a /command/.
A query does not change the system state.
A command changes the system state.
Application logic vs presentation logic.
The essence is the data.
The user can enumerate the finite number of things that can be done with a web application.
The architecture is onion.

Suppose that an application is ported from Google Sheets to Java.
What does not change?
The ontology, the concepts, the formulas

A user is essentially making a remote procedure call to a web application..

A system is to help us store, retrieve, and compute information.

Presentation logic: HTTP-HTML-browser, SSH-CLI.
Changing the presentation does not change the application logic at all.
** A curious relationship
SQL schema ~ Prolog module ~ model-theory signature
database theory / relational algebra ~ logic programming / relational programming

<2019-03-06>
I am surprised.
Database theory is surprisingly relevant to logic programming.
Database normalization is surprisingly relevant to writing good Prolog code.

Suppose Prolog.
From logic programming point of view, the comma can be thought as a conjunction.
From database point of view, the comma can be thought as a join.
* Existing systems
** A little history of model-driven engineering?
1989: OMG[fn::https://en.wikipedia.org/wiki/Object_Management_Group] was founded.
1990s: OOP Method Wars.
CASE tools.
1997: OMG adopted UML[fn::https://en.wikipedia.org/wiki/Unified_Modeling_Language].
MDA[fn::https://en.wikipedia.org/wiki/Model-driven_architecture].

UML is focused on visualization for humans.
UML does not have a clear formal ontology for machine translation.
** How standard is KIF (Knowledge Interchange Format)?
** Ontologies for enterprise software systems
Is there already an ontology for enterprise software systems?
Fox & Grüninger 1997 \cite{fox1997ontologies}?
Dietz 2012 \cite{dietz2012enterprise}?
** Existing ontologies, models, meta-models, and modeling methods
Introduction to knowledge representation:
John F. Sowa's 2011 introduction to common logic[fn::http://www.jfsowa.com/talks/clintro.pdf].
Compares these notations: Frege 1879, Peirce 1885, Peano 1895, Peirce 1897.
They have identical semantics.

Ideally we build a lower (domain-specific) ontology on an upper ontology.

- BFO (Basic Formal Ontology) \cite{arp2015building}
- GFO (General Formal Ontology)
- OWL
- SUMO (Suggested Upper Merged Ontology)

A general ontology is meant to unify all ad-hoc ontologies.
Ad-hoc ontologies are practical and convenient but limited and incompatible with each other,
unless we work to define a translation between them.
Rather than defining \(n^2\) mappings between \(n\) ontologies,
we define \(n\) mappings, each between an ad-hoc ontology and the /upper ontology/.

Similar systems:

- Entity-relationship modeling
- Subject-predicate-object, RDF triple
- Object-property-value
- Entity-attribute-value[fn::https://en.wikipedia.org/wiki/Entity–attribute–value_model]
- Category of being[fn::https://en.wikipedia.org/wiki/Category_of_being]

Some interesting things: OMG MOF (Meta Object Facility), fUML/ALF.

fUML: Mayerhofer 2014 \cite{mayerhofer2014defining}

Shan 2008 \cite{shan2008code}:
"Trinity PhD Simone Grassi has carried out his research to create an abstract
specification of algorithms (based on a set of ontologies) as a Model Driven Platform
to build software [...]"

https://en.wikipedia.org/wiki/Data_model

Ontology vs data model[fn::https://www.topquadrant.com/2011/09/30/ontologies-and-data-models-are-they-the-same/]

ClioPatria[fn::https://cliopatria.swi-prolog.org/help/whitepaper.html] concise RDF triple syntax: predicate logic without XML noise.

RDF vs OWL[fn::https://stackoverflow.com/questions/1740341/what-is-the-difference-between-rdf-and-owl].
Basically, RDF is like a Prolog fact, and OWL is like a Prolog Horn clause.

With Prolog syntax, we can just skip all the XML-URI shenanigans[fn::https://www.w3.org/RDF/Metalog/docs/sw-easy].

** Problem: RDF triple with non-binary predicates
Unary, ternary, n-ary
Intransitive verbs

** Common to all ontologies: classes and instances
* Literature study
** Unknown, to find out
*** fUML/ALF
fUML/ALF with text instead of graphics?
*** How far can Protege generate Java code?
*** Escher Systems Perfect Developer
I somewhat agree with this "correct-by-construction" spirit[fn::https://www.eschertech.com/products/correct_by_construction.php].
But the website is all marketing and no technical.
*** There are too many tools
Which one is free-libre-open-source?
https://en.wikipedia.org/wiki/Model-driven_engineering

Topcased and Papyrus \cite{gamalielsson2011open}.

People use an open source project if they /perceives/ that reusing the project is cheaper than redoing it.
But how can you know you can even reuse that project, if that project has no documentation?
The first question of a person who is thinking about using your open-source project is:
Who else uses this?
Am I alone?
Will shit happen?
Who maintains this?
If the maintainer dies or gets bored, will I be in deep shit?
Can I use this as is?
Can I tailor this to my needs?
Will this project go against my needs?
** Things that do not suit my wants
*** EMF
EMF is limited to structure and not behavior.
EMF can generate code for domain model (similar to Java bean) and validation, but not business logic.
The programmer writes the business logic in Java, and EMF uses code-merging.
EMF has persistence framework.
EMF does not go far enough.

EMF overview[fn::https://help.eclipse.org/photon/index.jsp?topic=%2Forg.eclipse.emf.doc%2Freferences%2Foverview%2FEMF.html]
Ecore is similar to EMOF (Essential MOF),
with some small differences, mostly naming differences.
"EMF does not model behavior, so the implementation must be provided by user-written Java code."
Modeling dynamic behavior is harder than modeling static structure.
Modeling behavior is practically creating a programming language.

This is similar to Eclipse Modeling Framework (EMF).
The difference is:
EMF leaves behavior specification to Java, but I think Java is too low-level.
EMF models structure but not behavior.
EMF does not go far enough.
*** Java EE
https://docs.oracle.com/javaee/6/tutorial/doc/gjiup.html

Mateu MDD uses Vaadin https://github.com/miguelperezcolom/mateu-mdd
