#+TITLE: Building a formal language from lambda calculus
#+DATE: 2018-07-22 02:45 +0700
#+OPTIONS: ^:nil
#+PERMALINK: /lambda.html
#+MATHJAX: t

* Introduction
** Goal
The goal is to build a usable formal language up from lambda calculus.

A /formal human language/ is a formal language that humans use to precisely (unambiguously) communicate technicalities to other humans
in a way that is also feasible to machine translation using classical compiler techniques.
** Examples of extending lambda calculus
- [[https://sites.ualberta.ca/~jhoover/325/CourseNotes/section/UntypedLambda.htm][Functional Programming - 12. The Extended Untyped lambda Calculus]]
- STLC = simply-typed lambda calculus
- [[https://softwarefoundations.cis.upenn.edu/plf-current/MoreStlc.html][Extending STLC]]
- 1982 article "A consistent extension of the lambda-calculus as a base for functional programming languages", https://www.sciencedirect.com/science/article/pii/S0019995882904582
- "Extending the Lambda Calculus: An Eager Functional Language", [[http://www.cs.yale.edu/homes/hudak/CS430F07/LectureSlides/Reynolds-ch11.pdf][pdf slides]]
*** TODO Study OCaml
Caml begets Caml Light begets OCaml.
- https://ocaml.org/
- [[https://caml.inria.fr/pub/docs/manual-ocaml/coreexamples.html]]
- https://caml.inria.fr/resources/doc/faq/core.en.html
** Alternative titles
- "How far can we push Scheme/Lisp?"
** Principles
*** Refer to mathematics, logic, and English.
*** Solve the root cause; don't hack.
*** Interoperate with existing systems. Improve existing systems. Enable replacement, but don't require it.
** Other people's opinions about designing programming languages
- http://www.inquisition.ca/en/info/gepsypl/rules.htm
- 2015 dissertation "Evidence-based programming language design: a philosophical and methodological exploration",
  [[https://jyx.jyu.fi/handle/123456789/47698][abstract]],
  [[https://jyx.jyu.fi/bitstream/handle/123456789/47698/978-951-39-6388-0_vaitos04122015.pdf][pdf]]
- https://www.reddit.com/r/ProgrammingLanguages/comments/9ep9xq/what_i_did_not_steal_from_perl_6/
  - "What's a character?" https://www.perlmonks.org/?node_id=1214956
- https://www.reddit.com/r/ProgrammingLanguages/comments/9eqrfy/what_are_the_biggest_problems_with_programming/
- 2017 article "The End of History? Using a Proof Assistant to Replace Language Design with Library Design" [[https://www.cs.purdue.edu/homes/bendy/Fiat/fiat-snapl.pdf][pdf]]
- [[http://purduepl.github.io/index.html][Purdue university programming languages group]]
** Shopping for ideas
- [[https://www.reddit.com/r/ProgrammingLanguages/comments/8vcrzb/what_are_some_interesting_language_features_that/][What are some interesting language features that may not be well known? : ProgrammingLanguages]]
- https://softwareengineering.stackexchange.com/questions/55047/what-is-the-greatest-design-flaw-you-have-faced-in-any-programming-language
- https://www.reddit.com/r/ProgrammingLanguages/comments/9erq87/languages_with_separate_types_for_pointers_to_the/
- http://math.andrej.com/2009/05/29/mathematically-structured-but-not-necessarily-functional-programming/
- read, "true sums of products" http://hackage.haskell.org/package/generics-sop
* Lambda calculus
Lambda calculus formalizes binding and substitution.

Follow [[https://crypto.stanford.edu/~blynn/lambda/][Ben Lynn's lambda-calculus tutorial]]:

- why use lambda calculus as theoretical basis (cool reasons!)
** Beta-reduction
- reduce : E -> E
- reduce ((\ x -> y) p) = reduce (y[x:=p])
  - y[x:=p] means y but with every bound occurence of x replaced with p)
- reduce x = x otherwise
* Strings, especially of characters
A /string/ is a homogenous sequence.

A string has a beginning, and may have an ending.
A string may be finite.

A /byte string/ is a sequence of bytes.

An /ASCII string/ is a byte string.

A /character string/ is a sequence of characters.

Unqualified "string" usually means "character string".

A /character string literal/ is surrounded with quotes.
** Escape sequences
** Characters
What is Unicode's definition of "character"?
Is that definition sane?

Should Unicode normalization/canonicalization be built into the programming language?

Issues: ordering/collation, capitalization, combination, halfwidthization, ligature, etc.

- https://en.wikipedia.org/wiki/String_(computer_science)
- https://en.wikipedia.org/wiki/Character_(computing)
* Macro, reflection, reification, quoting
The language should be a model of itself.

The language should be able to describe itself.

Does that cause a paradox?
* What program, execution, and termination mean in declarative paradigms

In functional paradigm:

- The program is a big lambda expression.
- Execution is beta-reduction / term-rewriting.
- Execution terminates when the program reaches normal form (is no longer beta-reducible).

In satisfying-logic paradigm:

- The program is a big logic formula.
- Execution is trying to satisfy the formula.
- Execution terminates when satisfiability is determined.

In theorem-proving paradigm:

- The program is a big logic formula, presumably in conjunctive-normal form.
- Execution is trying to prove the main(world) goal.
- Execution terminates when the goal is proved or disproved.

* Records, also for namespaces and modules

We want records because /records obviate namespaces and modules/.

We want namespaces and modules because they are necessary for humans to manage large programs.

** We don't want to represent records as functions.

We can describe the semantics of a record r as a function r : string -> expression.

There are several options to pretty-print a record:

- Define a =show-record= function that is different from =show=.
- But we want polymorphic =show=. We want one =show= function to work for all things.
- If a record is represented by a lambda abstraction, then pretty-printing the record will pretty-print a lambda abstraction.
  We don't want that.
  We want pretty-printed records to look like how we write records.

** We want records to be applicable like lambda; we add a new beta-reduction rule for "applying" records.

Record access is function application.
To get the field =fld= or record =rec=, evaluate =rec fld=.

The record =rec= with the the field =fld= updated to =new= is the expression =\ name -> IF name = fld THEN new ELSE rec fld=.

We add this beta-reduction rule:

- If X is a record, and Y is a string, then =X Y= reduces to =get X Y=.

We want to pretend that records are functions.
We want to use records as if they were functions.
But we don't want records to be functions; we want to pretty-print records as records, not as lambda abstractions.

** Modules as record functions

A module is a function taking a record and giving a record.
The input is called /imports/ or /dependencies/.
The output is called /exports/.

Example:

#+BEGIN_EXAMPLE
\ { add; } -> { add_one: \ x -> add x 1; }
#+END_EXAMPLE

** Record expressions

We add these expression syntax rules:

- If each of x1,...,xn is a label and each of e1,...,en is an expression, then ={x1:e1; ...; xn:en;}= is a /record expression/.
- =union R S= is a /record union expression/.
- record update expression (should be polymorphic)
- record filtering/selection/intersection expression

An example of a record expression is ={id: \ x -> x; app: \ f x -> f x;}=.

** Labels

A /label/ is a string.
If the label doesn't contain funny characters, it doesn't have to be quoted.
For example, ={"a":1;}= and ={a:1;}= are the same thing.

Should we generalize label to expression?

* Annotations: user-defined metadata attached to concrete syntax tree nodes

We add these expression syntax rules:

- If M is an expression and E is an expression, then =E : M= (read: data E annotated with metadata M) is an /annotated expression/.
  - Alternative syntax: =E : M= can also be written =meta M E=.

This generalizes type systems.
With type systems, you annotate an expression with a type expression.
With general annotations, you annotate an expression with another expression (some of which are type expressions).

We assume that the outermost metadata update wins:

- meta M (meta N E) = meta M E

We add metadata extraction function symbol =meta-of=.

We add these beta-reduction rules:

- reduce (meta M E) = reduce E
- reduce (meta-of (meta M E)) = reduce M
- reduce (meta-of E) = #<empty-record> (for expressions without metadata)

This is like Java/C# annotation but more principled?

** Annotation is not type

This is an example of type annotation that our annotation above can't handle: =\ (x : T) -> y=,
because =x= is not an expression.

* Let-expressions

The /let-expression/ =let x1 = y1; ...; xn = yn; in z;= desugars to =(\ x1 ... xn -> z) y1 ... yn=.

Let-expressions is for readability by humans.

Do we still need let-expressions if our program is well-factored?

** let-expressions may recur

I think letrec is ugly.
All let-expression should allow recursion, like Haskell's.

https://stackoverflow.com/questions/28796904/whats-the-reason-of-let-rec-for-impure-functional-language-ocaml/28798040

* Sharing, laziness, full laziness, complete laziness, and optimal reduction

- https://www.reddit.com/r/haskell/comments/3pa5ii/are_optimal_evaluators_actually_optimal/
  - https://cstheory.stackexchange.com/questions/32850/are-optimal-evaluators-actually-optimal

** Sharing

- Should the programmer care about sharing?
- sigma-calculus?
- Should the programmer decide whether to share or not?
- Is there a best sharing strategy?
- Should the machine guess by heuristics?

Sharing affects performance, but does not change the result.
Should we care?

** Example of sharing

Consider the expression letexp defined as =let x = y in z;=.

We want x to be shared iff doing so speeds up the reduction of letexp.

This is always the case:

- If x occurs /at most once/ in z, we always want x not shared.

These depend on circumstances:

- If y is expensive, we want x shared.
- If y is cheap, we want x not shared.

How do we define "expensive"?

** Lazy accumulation problem

#+BEGIN_EXAMPLE
sum a 0 = a
sum a

sum 0 = 0
sum n = n + sum (n - 1)
#+END_EXAMPLE

* Currying is not compatible with vararg and named parameters?

Vararg stands for "variable-length arguments".

Do we want currying?

Currying simplifies language user but complicates compiler writer.

The problems:

- https://softwareengineering.stackexchange.com/questions/286231/is-it-possible-to-have-currying-and-variadic-function-at-the-same-time
- http://tolmasky.com/2016/03/24/generalizing-jsx/

* Modeling all data

** Hypothesis: data = ADTs + records + row polymorphism

Hypothesis: All data can be modeled by a combination of these:

- product (tuple)
- sum (alternative, union)
- record (tuple with named components)
- row polymorphism

Can we use web standards to define an ontology (so we can use Protege to edit it)?
https://protege.stanford.edu/

- Does Eclipse EMF have textual representation?

** Church-representation of products, sums, and algebraic data types in general

https://en.wikipedia.org/wiki/Lambda_calculus#Pairs

Let [x] mean the /representation/ of x.

A /product/ (a,b) can be represented as [(a,b)] = \ f -> f [a] [b].

The left projection p1 is represented as [p1] = \ p -> p (\ a b -> a).

If we assume the sum type A + B, then:

- The choice inl a can be represented as [inl a] = \ f g -> f [a].
- The choice inr b can be represented as [inr b] = \ f g -> g [b].

A recursive data type such as "stream a = (a, stream a)" can be represented as:

- [cons h t] = \ f -> f [h] [t].

Thus [a : b : c : ...] = \ f -> f [a] (\ f -> f [b] (\ f -> f [c] ...)).

A recursive data type such as "list a = nil | cons a (list a)" can be represented as:

- [nil] = \ f g -> f.
- [cons x y] = \ f g -> g [x] [y].

Natural numbers "nat = z | s nat":

- [z] = \ f g -> f.
- [s x] = \ f g -> g [x].

Thus:

- [s z] = \ f g -> g (\ f g -> f)

** Reverse semantics

Semantics maps syntax to mathematical object.

Reverse semantics maps mathematical object to syntax.
Reverse semantics is representation.
Reverse semantics is realization.

Example of reverse semantics is representing the tuple =(x,y)= with the lambda abstraction =\ f -> f [x] [y]= where =[x]= denotes the representation of x.

https://en.wikipedia.org/wiki/Realizability

** Self-interpreter

1994 article "Efficient Self-Interpretation in Lambda Calculus"

* Representing knowledge; logic programming; symbolic AI

- https://en.wikipedia.org/wiki/Logic_programming#Knowledge_representation
- https://en.wikipedia.org/wiki/Knowledge_representation_and_reasoning

Example: We encode "a todo item has an int64 id" as

#+BEGIN_EXAMPLE
IF entity todo_app todo E THEN property E int64 id.
#+END_EXAMPLE

* Dynamic binding, contextual holes

- 1996 article "Enriching the lambda calculus with contexts: toward a theory of incremental program construction" https://dl.acm.org/citation.cfm?id=232652
- 1998 article "A lambda-calculus for dynamic binding" https://core.ac.uk/download/pdf/82810390.pdf
- 1998 article "Computing with Contexts: A simple approach" https://core.ac.uk/download/pdf/82065430.pdf
- 2009 article "Two-level Lambda-calculus" https://www.sciencedirect.com/science/article/pii/S1571066109002400

* Working with existing systems
** Working with Java
* Semantics (should we worry about this earlier?)

** Cost model

- "Cost models based on the lambda-calculus", [[http://www.cs.cmu.edu/~guyb/papers/lambdaInria.pdf][pdf slides]], from http://www.cs.cmu.edu/~guyb/

** Denotational semantics

*** Intro to denotational semantics

- 1971, monograph, Dana Scott and Christopher Strachey, "Toward a mathematical semantics for computer languages", [[https://www.cs.ox.ac.uk/files/3228/PRG06.pdf][pdf]]
- [[https://pdfs.semanticscholar.org/presentation/76cd/955ec6dafde3699d64e50882ec7fb4384803.pdf][pdf slides]]
- [[https://www.seas.harvard.edu/courses/cs152/2016sp/sections/sec-2016-02-18-soln.pdf][Exercises]] about denotational semantics and lambda calculus
- 1997, book, "Denotational semantics: a methodology for language development", [[http://www.bcl.hamilton.ie/~barak/teach/F2008/NUIM/CS424/texts/ds.pdf][pdf]]
- 1989, PhD thesis, Frank Steven Kent Silbermann, "A Denotational Semantics Approach to Functional and Logic Programming", chapter 3, [[http://www.cs.unc.edu/techreports/89-030.pdf][pdf]]
  - "A novel approach is taken in constructing an operational semantics directly from the denotational description."

*** TODO Does lambda calculus have a semantics that doesn't depend on reduction strategy?

** Operational semantics and evaluation/reduction strategy

Which one should we choose, and why?

- call-by-name
- call-by-value
- call-by-need
- what else?

<2018-09-29> Wikipedia needs cleanup:

- https://en.wikipedia.org/wiki/Reduction_strategy_(lambda_calculus)
- https://en.wikipedia.org/wiki/Lambda_calculus#Reduction_strategies
- https://en.wikipedia.org/wiki/Evaluation_strategy

* Overloadable function application?

* Interpreters: Giving different meanings to the same syntax

Sometimes we want to interpret the same syntax (appearance, source code, text) differently.

* System F, System F with subtyping, System F-omega

https://en.wikipedia.org/wiki/System_F

"System F is rich enough that the self-application =\x.x x= is typable." https://crypto.stanford.edu/~blynn/lambda/systemf.html

Brown and Palsberg, "Breaking Through the Normalization Barrier: A Self-Interpreter for F-omega"

* Lambda-prolog?

- lambda-prolog http://www.lix.polytechnique.fr/~dale/lProlog/

* Imperative subset

Haskell's ST monad enables us to embed a local imperative program in a functional program.

* Introduction?

- unknown-year lecture notes "Lambda Calculus as a Programming Language" [[http://andrei.clubcisco.ro/cursuri/2pp/01.Lambda_prog.pdf][pdf]]

I thought lambda calculus could be summarized in one page, but Henk Barendregt wrote hundreds of pages about it. Is there more to lambda calculus than it seems?

- 1994, 50 pages, [[http://www.nyu.edu/projects/barker/Lambda/barendregt.94.pdf][pdf]]
- 1991, 190 pages, [[https://people.mpi-sws.org/~dreyer/tor/papers/barendregt.pdf][pdf]]

* Extending lambda-calculus with various bells and whistles

- Vectorial lambda-calculus

  - The 2013 article "The Vectorial Lambda-Calculus" [[https://who.rocq.inria.fr/Alejandro.Diaz-Caro/TheVectorialCalculus.pdf][pdf]] adds vectors and matrices and their types to lambda calculus.
  - The 2010 article "Semantics of a Typed Algebraic Lambda-Calculus" [[https://arxiv.org/abs/1006.1433][pdf available]] also mentions "vectorial".

- 2016 article "System F-omega with Equirecursive Types for Datatype-Generic Programming" [[http://ps.informatik.uni-tuebingen.de/research/functors/equirecursion-fomega-popl16.pdf][pdf]]

* Lambda calculus semantics?

- https://en.wikipedia.org/wiki/Lambda_calculus#Semantics

  - "In the 1970s, Dana Scott showed that, if only continuous functions were considered,
    a set or domain D with the required property could be found, thus providing a model for the lambda calculus."

    - 1982, [[https://www.sciencedirect.com/science/article/pii/S0019995882800879]["What is a model of lambda calculus?"]]
    - 2008, PhD thesis, [[https://tel.archives-ouvertes.fr/tel-00715207/document]["Models and theories of lambda calculus"]]

      - 2009, [[https://arxiv.org/abs/0904.4756][summary]]

- Paul Hudak, lecture notes, [[http://www.cs.yale.edu/homes/hudak/CS430F07/LectureSlides/Reynolds-ch10.pdf][The Lambda Calculus]]

  - "The Greatest Thing Since Sliced Bread™, or maybe even before it"

- The operational semantics of lambda calculus depends on the evaluation strategy?

  - What-reduction?

    - Normal-order reduction
    - Applicative-order reduction

  - Call-by-what?

    - Call-by-value
    - Call-by-name

* When should we introduce a type system?

- 2005 article "Introduction to Type Theory" [[http://www.cs.ru.nl/~erikb/onderwijs/sl2/materiaal/tt-sl2.pdf][pdf]]

* Optimizing lambda calculus?

- http://thyer.name/lambda-animator/
- http://thyer.name/phd-thesis/
- http://hackage.haskell.org/package/graph-rewriting-lambdascope
- partial evaluation

  - 2010, slides, "O, partial evaluator, where art thou?", Lennart Augustsson, [[http://www.cse.chalmers.se/~palka/Lennarts_talk/PEPM-2010.pdf][pdf]]

    - https://en.wikipedia.org/wiki/Partial_evaluation

      - Futamura projection

  - 1997, article, "Distributed partial evaluation", [[http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.134.1238][citeseerx]]

- Lambda calculus

  - might be related to bottom-up beta substitution

    - Abdullah hinted that BUBS (bottom-up beta-substitution [Shivers2004])
      might be used to make a garbage-free or a fast interpreter.
    - https://en.wikipedia.org/wiki/Strict_programming_language
    - https://en.wikipedia.org/wiki/Lazy_evaluation
    - [[https://memo.barrucadu.co.uk/strict-vs-lazy.html][Strict-by-default vs Lazy-by-default]]
    - https://en.wikipedia.org/wiki/Applicative_computing_systems
    - non-strict, beta reduction, normal order, applicative order
    - The terms "lazy" and "strict" imply operational semantics.
      They are two strategies for beta-reduction.
      "Lazy" is normal-order.
      "Strict" is applicative-order.
    - [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.2386&rep=rep1&type=pdf][An Algorithm for Optimal Lambda Calculus Reduction, John Lamping]]
    - [[http://www.lsv.fr/Publis/PAPERS/PDF/sinot-wrs07.pdf][Complete Laziness: a Natural Semantics, François-Régis Sinot]]
    - http://rochel.info/ graph-rewriting-lambdascope (screenshot): An implementation of an optimal evaluator for the λ-calculus, PDFLambdascope

  - How is lambda calculus algebraic?

    - [[https://www.mscs.dal.ca/~selinger/papers/combinatory.pdf]["The lambda calculus is algebraic", Peter Selinger]]

      - "We argue that free variables should not be interpreted as elements in a model, as is usually done, but as indeterminates."

    - [[https://pdfs.semanticscholar.org/055d/69ee4dc95fbf6457419c90338493667478b1.pdf]["On the algebraic models of lambda calculus", Antonino Salibra]]

      - "The variety (equational class) of lambda abstraction algebras was introduced
        to algebraize the untyped lambda calculus in the same way Boolean algebras algebraize the classical propositional calculus."
        Propositional logic is modeled by Boolean algebra.
        First-order logic is modeled by cylindric algebra?
        Lambda calculus is modeled by lambda abstraction algebra.
        Why algebra? Because it is equational?

    - [[https://en.wikipedia.org/wiki/Algebraic_logic][Wikipedia "algebraic logic"]]
    - [[https://pdfs.semanticscholar.org/7596/19f05a42ff3045bcf87fcaa3edbff01e1130.pdf]["The algebraic lambda-calculus", Lionel Vaux]]
    - [[https://pdfs.semanticscholar.org/44c9/2ad00b8ceba78319005db048b24d61a80748.pdf]["Lambda abstraction algebras: representation theorems", Don Pigozzi, Antonino Salibra]]
    - [[http://www.dsi.unive.it/~salibra/mainfinale.pdf]["Applying Universal Algebra to Lambda Calculus", Giulio Manzonetto, Antonino Salibra]]

  - Dana Scott's PCF; also search the Internet for "the language pcf"
    [[http://www.cs.bham.ac.uk/~mhe/papers/RNC3.pdf]["Introduction to Real PCF (Notes)", Mart'in H"otzel Escard'o]]
  - 1993 John Launchbury [[https://pdfs.semanticscholar.org/492b/200419199892857faa6a6956614641ae9464.pdf][Lazy imperative programming]]

- lambda calculus

  - Church-encoding enables lambda calculus to represent conditionals and algebraic data types.
  - Fixed-point combinators enables recursion and looping.
  - https://en.wikipedia.org/wiki/Lambda_cube
  - https://en.wikipedia.org/wiki/Calculus_of_constructions
  - https://en.wikipedia.org/wiki/Simply_typed_lambda_calculus

    - "The simply typed lambda calculus [...], a form of type theory,
      is a typed interpretation of the lambda calculus with only one type constructor: [...] that builds function types."

      - What is an "interpretation of the lambda calculus"?
      - What is "the lambda calculus"? Is there only one lambda calculus?

  - https://www.reddit.com/r/haskell/comments/8els6f/why_are_combinators_as_powerful_as_full/
  - https://math.stackexchange.com/questions/5639/the-power-of-lambda-calculi
  - Implement lambda calculus.

    - Without dynamic allocation / garbage collection.
    - Translate lambda calculus to assembly

      - Basic idea:

        - Every expression translates to a subroutine.
        - Calling the subroutine ~ evaluating the expression.
        - Subroutine return value ~ value obtained by evaluating the expression.

      - A lambda abstraction translates to a subroutine that accepts one parameter.
      - An application translates to a subroutine call.
      - An int value translates to what? Choice:

        - itself
        - a subroutine that returns the int

    - 2012, article, [[https://arxiv.org/abs/1202.2924]["From Mathematics to Abstract Machine: A formal derivation of an executable Krivine machine"]]

      - https://en.wikipedia.org/wiki/Krivine_machine

* Begin with an interpreter, not a compiler

- Don't make a compiler?
  Make an interpreter instead, and stage it?
  Turn an interpreter into a compiler for free?
- "To stage an interpreter" is to add staging annotations to the code of the interpreter.
- Staging is similar to quoting in Lisp/Scheme.
- 2004 article "A Gentle Introduction to Multi-stage Programming" [[http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.103.2543&rep=rep1&type=pdf][pdf]]
  - Basic Problems in Building Program Generators
  - part 2 https://pdfs.semanticscholar.org/aa3c/d4233f7c0db95e5c38d5b8fc1d199df21857.pdf
- multi-stage programming for Scala https://scala-lms.github.io/
- 2006 article "A Verified Staged Interpreter is a Verified Compiler" [[https://www.researchgate.net/profile/Kevin_Hammond/publication/221108683_A_verified_staged_interpreter_is_a_verified_compiler/links/00b7d517ede725c057000000.pdf][pdf]]

* Foreign function interface: working with C

* Ocaml

- https://ocaml.org/learn/

* Reconciling functional and logic programming into declarative programming?

1996 publication "A Note on Declarative Programming Paradigms and the Future of Definitional Programming" [[http://www.cse.chalmers.se/~oloft/Papers/wm96/wm96.html][html]]

** Example: Representing a predicate in lambda calculus

Lambda calculus with boolean logic extensions:

#+BEGIN_EXAMPLE
p = \ x -> x = "a" OR x = "b"
#+END_EXAMPLE

Prolog:

#+BEGIN_EXAMPLE
p(a).
p(b).
#+END_EXAMPLE

** Example: Representing a function in logic programming

#+BEGIN_EXAMPLE
inc(X, Y) :- X = Y + 1.
#+END_EXAMPLE

** The "satisfy" function

The expression "satisfy f" finds all x : a that satisfies f : a -> bool.
Thus the type of "satisfy" is "(a -> bool) -> list a".

It is in principle possible to write such "satisfy" builtin for some lambda expressions.

#+BEGIN_EXAMPLE
satisfy (\ x -> x = "a" OR x = "b")
=> ["a","b"]

satisfy (\ (x : int) -> x >= 10)
=> [10,11,12,...] -- an infinite list

satisfy (\ (x : bool) -> true)
=> [false,true]
#+END_EXAMPLE

** A function is a relation, a relation is a function, so what?

A function \( (A,B,F) \) is trivially a relation.

A relation \( (A,B,R) \) is a function \( (A,2^B,F) \) where \( F(x) = \{ y ~|~ (x,y) \in R \} \).

* Precise memory accounting

We want precise memory accounting to enable the runtime to limit memory usage.

* Logic programming vs theorem proving
- https://stackoverflow.com/questions/36335633/difference-between-logic-programming-and-automated-theorem-proving
- https://en.wikipedia.org/wiki/Automated_theorem_proving
* Execution state reification, save states, saving and loading states, pausing and resuming computations

We want execution state reification so that we can do live process migration.

* Knowledge representation and software specification
** Their relationships
- 2010, "Functional-Logic Programming Lecture Notes", Harold Boley, slides, [[http://www.cs.unb.ca/~boley/FLP/cs6905FLP.pdf][pdf]]
  - Knowledge representation in AI roughly corresponds to software specification in software engineering.
  - Declarative programs can be thought as executable specifications.
  - Invertibility principle (slide 36)
  - Nesting/conjunction principle (slide 46)
  - Unification principle (slide 50)
  - Amalgamation/integration principle (slide 55)
  - That's a long deck: 270 slides.
** Executable specification?
- lightweight executable mathematics https://www.cl.cam.ac.uk/~pes20/lem/
* Haskell woes

- [[https://news.ycombinator.com/item?id=5893442][Ask HN: Any downsides of programming in Haskell? | Hacker News]]
- [[https://www.reddit.com/r/haskell/comments/1gknfs/ask_hn_any_downsides_of_programming_in_haskell/][Ask HN: Any downsides of programming in Haskell? : haskell]]

** Can't import type class instances explicitly

[[https://stackoverflow.com/questions/8728596/explicitly-import-instances][There is a reason]].

* Monads, and Haskell type system limitations

- A monad is a way of /conservatively extending/ all categories. (Abdullah, private correspondence)
- https://www.reddit.com/r/haskell/comments/3h2aqg/can_someone_explain_the_monads_are_generalised/

** Should Nat (the natural numbers) be a subtype of Int (the integers)?

Intuitively, yes.

** <2018-10-01> @abdullah Signedness is a monad: conservatively extending naturals to integers

I think this is what we mean when we say "integer is a monad".
I think what we are really trying to say is "signedness is a monad", that is, "we can conservatively extend the naturals to the integers by using the Signed monad".

We can write that in Haskell as follows (with some problems described later).

#+BEGIN_EXAMPLE
data Nat = Zero | Succ Nat
type Int = Signed Nat
data Signed a = Positive a | Negative a

instance Functor Signed ...
instance Applicative Signed ...

instance Monad Signed where
    return = Positive
    m >>= k = join_signed (fmap k m)

join_signed :: Signed (Signed a) -> Signed a
join_signed mm = case mm of
    Positive x -> x
    Negative x -> negate_signed x

negate_signed :: Signed a -> Signed a
negate_signed (Positive x) = Negative x
negate_signed (Negative x) = Positive x

f :: Nat -> Nat
f = ...

f_int :: Int -> Int
f_int = fmap f
#+END_EXAMPLE

We can have Signed Char, Signed String, etc., but those may not make sense.

The problem:
Nat should be a subtype of Int, because everyone who knows arithmetics seems to think that way.
We want f and f_int to be the /same/ function.
We don't want to type fmap, liftM2, and their ilk.
