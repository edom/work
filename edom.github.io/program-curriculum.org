#+TITLE: Toward a curriculum for computer programming
#+DATE: 2020-01-20 00:00:00 +0700
* Principles
- Programmers /translate/ human desires into computer systems.
- Programmer metrics measure translation quality.
  An example of translation quality measurement is that of [[https://unbabel.com/blog/measuring-translation-performance/][unbabel.com]]
  (its speed-effort-quality framework is also applicable to formal translations).
  - The primary measurement is faithfulness/fidelity: Translate a desire into a program that does what is intended and does /only/ what is intended.
  - The secondary measurements are speed and effort.
  - Some items from [[https://www.atanet.org/certification/aboutexams_overview.php][American Translators Association]][fn::<2020-01-20>] are also applicable:
    - "Everything integral to the source text is included in the target text and nothing that is not implicitly or explicitly stated by the author is added."
    - "Syntax is appropriate to the target language; the target text does not necessarily imitate the sentence structure of the source text."
    - "The target text flows smoothly and does not contain awkward expressions that mark it distinctly as a translation."
    - [[https://www.atanet.org/certification/aboutexams_error.php][Explanation of Error Categories]]
- AI/ML can be thought of as a subset of computer programming (i.e. making computers do what we want).
** Translators, programmers, managers, and their measurements
A translator is measured by the faithfulness of translation and speed of translation?

If programmers /translate/ human desire to computer program, then ... the same measure.

Managers also /translate/ from abstract desire to concrete implementation?
Or is that directors?

Programming ability, how able they are to make machines do what they want.

A programmer may be measured in the same way we measure animal trainers, formal translators, and government legislators.

/Everyone/ can be measured by their ability to translate their desires into reality.
Everyone can be measured by their ability to manifest their desires.
* General Aspirant
- Translate simple desires into programs in JavaScript in a common browser's JavaScript console (because everybody has a browser).
* General Beginner
- Understand modeling (abstraction).
  - Understand simplifying assumptions.
  - Understand when models break down.
  - Understand layers of abstraction.
  - Understand that troubleshooting often digging down through layers of abstraction.
  - Understand that even though one may not know the lower layers, one must know that he does not know the lower layers.
- Translate simple desires into programs in these languages: Assembly, C, Scheme, Haskell, Prolog.
- Understand the abstraction from computer programs down to electronic logic gates.
- Prove the correctness of simple programs, but be aware that "correctness"
  is relative to a model; there is no absolute correctness; there is no correctness in reality.
- Read/maintain/change programs.
- Understand evaluation order.
  - Understand normal-order and applicative-order lambda-calculus reduction strategies.
- Programming without caring about time/ordering/sequentiality.
- Understand hard (NP-complete) problems, and understand whether to give up, to approximate, or to do something else.
- [[file:git-curriculum.html][Use Git]].
- Know what you are doing.
  Manipulate code in well-defined steps/operations, not haphazardly.
  - Create a function with simplifying assumptions.
  - Relax a simplifying assumption.
- Understand some philosophical jargon, especially epistemology and ontology.
- Understand accidental complexity and essential complexity.
** Testing
- Test functions.
- Test programs.
- Test systems.
- Property-based testing with QuickCheck.
- Fuzzing.
* General Requirement Analysis
- Understand analytical philosophy: how to define terms.
- Understand how to use a language, a dictionary, an etymology dictionary, and a thesaurus.
- Translate what is meant, not only what is said.
  Translate the intention, not the utterance.
  - Uncover implicit/hidden desires (non-functional requirements).
  - Uncover some probable hidden future desires.
  - Ask/clarify/confirm back in the dialog with the client.
* General Mathematics
- Understand that mathematical notation is a shorthand for natural languages such as English.
- Read mathematical notation in a natural language such as English.
  For example, read "\( x + 1 = 2 \)" as "there is something called '\(x\)' such that \(x\) plus one equals two.".
* General Network
- Understand Ethernet.
- Understand Wi-Fi.
- Understand electromagnetism.
- Understand how materials reflect electromagnetic waves, for various wavelengths/frequencies.
- Understand the Internet Protocol stack.
- Understand the OSI 7-layer model and the Internet 5-layer model.
* General Web
- Understand HTML and CSS.
- Understand basic HTTP.
- Understand that client--server separation introduces accidental complexity that can be hidden with model-driven architecture.
  - Apply the Request--Response / Command--Response abstraction to command-line applications and web applications.
* General Intermediate
- Translate simple desires into programs in these languages: C++, Java, Kotlin, Go.
- Translate complex desires into systems in these languages: Common Lisp, Scheme, Racket.
- Design application programming interfaces (APIs).
- Understand backward-compatibility.
- Formalize requirements.
  - Begin by designing the data model or the ontology of the information system being built.
- Interoperate several programming language implementations.
- van Roy & Haridi: alternative semantics https://www.info.ucl.ac.be/~pvr/book.html
- Understand performance.
  - Have a mental model of resource usage (time complexity).
  - Understand practical benchmarking.
  - Understand performance measurement, CPU profiling, memory profiling, disk profiling.
  - Find bottlenecks.
  - Predict bottlenecks.
  - Understand some queuing theory.
- Design systems according to expected number of users and expected lifetime.
- Understand deductive databases.
  - Understand Prolog, backward chaining, SLDNF resolution, how Kowalski relates sequence of procedure calls and conjunction of Horn clauses.
  - Understand Datalog, forward chaining.
  - Understand SQL databases as almost-deductive databases.
  - Understand the relationship between relation (extension) and predicate (intension).
  - Understand that standard SQL cannot compute transitive closure.
  - I decided not to /mainly/ use Prolog because Prolog lacks these things that would help maintaining large programs:
    scoping (local variable), anonymous (first-class) modules.
    However, I may decide to /embed/ Prolog;
    For databases, I love Prolog/Datalog much more than I like SQL.
** Algebraic modeling
- Model some systems algebraically.
  - Come up with a set.
  - Come up with a /closed/ operation on that set.
  - Example: shape algebra:
    - constructors
      - circle : Radius -> Shape
      - square : Side -> Shape
    - algebraic operations
      - juxtapose : Shape -> Shape -> Shape
      - on : Shape -> Shape -> Shape
    - combinators
      - translate : DX -> DY -> Shape -> Shape
* General Advanced
- Decompose systems such that the difficulty of a change is proportional to the change's probability.
- Automate the translation of desires.
  Model-driven development.
  Make computers help translate desires.
  Teach computer how to reason.
- Design a programming language, probably domain-specific, beginning from the language's semantics.
- Make interpreters.
- Make compilers.
- Trade-offs, constraints.
- Program humans and machines.
- Program human--machine hybrid systems (which is all practical systems).
* Special Critical Systems
- It is OK to be disiniterested in this; few people like this.
- https://en.wikipedia.org/wiki/Critical_system
- Program computers without assuming that hardware is 100% reliable.
- Define failure modes.
* General Culmination: post-scarcity, spirituality, actualization, apotheosis
- Make things with love, for beauty and simplicity, because we want to, not because we have to.
