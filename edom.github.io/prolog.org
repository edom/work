#+TITLE: Using Prolog
#+DATE: 2018-04-11 00:00 +0700
#+OPTIONS: ^:nil toc:nil
#+PERMALINK: /prolog.html
#+TOC: headlines 1
* Before you go full Prolog
#+TOC: headlines 2 local
** <2018-11-30> This is a book in progress! I don't know whether I will ever finish this.
** Who might you be? How might this book serve you?
- a programmer used to C, C++, Java, PHP, Ruby, Python
- a programmer used to Lisp, Scheme, Haskell
- a Prolog believer
- a Prolog evangelist
- someone who used to write Prolog codes
- a dreamer who thinks machines should do more
- a researcher, theoretician, computer scientist, mathematician, logician, philosopher?
- (Who else might you be, why the hell are you here, and how should I write for you?)
** Warning about the woes and blockers
I'm selling you Prolog here, but let me be honest:
Don't buy it if any of these year-2018 deal-breakers are an issue for you.
Prolog isn't ready for these use cases in 2018; I hope these will change.

<2018-12-09>
Somewhat fatal:
ISO Prolog open/4 has no way to open a file for writing without truncating it.
(How the hell did they overlook such a common use case?)
But some implementations have extensions to work around that:
- Prolog implementations that can open a file for both reading and writing:
  - <2018-12-09> Amzi! Prolog open/4 has "readwrite" mode[fn::https://www.amzi.com/manuals/amzi/pro/ref_io.htm]
- Prolog implementations that can open a file for writing without truncating it, but not for both reading and writing:
  - <2018-12-09> SWI-Prolog open/4 has "update" mode[fn::http://www.swi-prolog.org/pldoc/doc_for?object=open/4]
  - <2018-12-09> ECLiPSe Prolog open/4 has "update" mode[fn::http://eclipseclp.org/doc/bips/kernel/iostream/open-4.html]
- Prolog implementations that /cannot/ open a file for writing without truncating it:
  - <2018-12-09> GNU Prolog[fn::http://www.gprolog.org/manual/html_node/gprolog034.html#open%2F4]
  - <2018-12-09> SICStus Prolog[fn::https://sicstus.sics.se/sicstus/docs/4.2.1/html/sicstus/mpg_002dref_002dopen.html]
  - <2018-12-09> Ciao Prolog[fn::https://ciao-lang.org/docs/1.14/13646/CiaoDE-1.14.2-13646_ciao.html/streams_basic.html#open/4]

<2018-11-30>
No arrays.

<2018-11-30>
SWI-Prolog is honest:
"The main weakness of Prolog are algorithms that require destructive assignment,
intensive array processing or bare-metal performance for e.g., processing pixels."
 [fn::http://www.swi-prolog.org/FAQ/PrologLAMP.txt]

<2018-10-24>
There is no standard date/time/calendar library?
There may be one?
I'm still looking.
library(julian)?
- Java 8 has "java.util.time".
  Previous Java versions can use "Joda Time".
- Haskell has the "time" package ("Data.Time" module).
*** <2018-11-22> Prolog weakness: binary array and low-level input-output
Prolog doesn't have arrays.

Workaround: we can fake an array:
Allocate with functor(T,F,N), read with arg(N,T,A), and write with nb_setarg(N,T,A).

Prolog doesn't have unsigned integers.

How fast is this?

This requires that the implementation doesn't limit functor arguments.
** Let me hype you up.
(You can skip this.)

<2018-11-30>
Don't take this too seriously.
I'm on a honeymoon with Prolog.

Prolog is a /mind augmentation language/.
Prolog is a mental prosthesis.
With prosthetic arms, I can beat you in arm wrestling.
With prosthetic legs, I can beat you in running.
With prosthetic minds, I can beat you in thinking.
If logic is the language of thought, then Prolog is the closest thing we have to mind dump.
Offload your reasoning to computers.
As Leibniz said, "Let us calculate!"

You love Lisp macros?
Prolog has term_expansion/2, goal_expansion/2, op/2, and the infix operators that you have been dreaming of!

You love Haskell type system?
In Prolog you can write your own type systems!

You love C++ operator overloading?
In Prolog you can define your own operators with their precedences and associativities!

You want to beat/outdo/one-up your coworkers?
Prolog is perfect for that!
Unless you're low-level-programming,
Prolog is the secret weapon that multiplies your productivity by 20 compared to a low-level programming language such as C, C++, Java.
When you build your home, you don't build your own bricks.

Your coworkers are beating you with Prolog?
Well, what the hell are you waiting for?
Learn Prolog now, or lose your job and die in oblivion!

"Prolog is a convenient language in which to express the semantics of other languages."
https://www3.hhu.de/stups/prob/index.php/Why_Prolog%3F
** Not sure yet? Try Prolog with minimal investment.
If you're not sure yet, I suggest that you
read [[https://www.metalevel.at/prolog][Markus Triska's book "The power of Prolog"]]
while doodling some code on [[http://pengines.swi-prolog.org/apps/swish/index.html][SWISH online Prolog interpreter]].
** Comparing Prolog implementations?
I use SWI-Prolog because it's what I used in university, and because of this [[http://www.swi-prolog.org/features.html][SWI-Prolog sales pitch]].

This book assumes that the reader uses SWI-Prolog 7.6.4.

There are many Prolog implementations.
Some companies have their own Prolog implementations.

GNU Prolog is "a native-code compiler which produces standalone executables which don’t rely on any byte-code emulator or meta-interpreter."
 [fn::https://www.semanticscholar.org/paper/On-the-Implementation-of-GNU-Prolog-Diaz-Abreu/2c4f697f96202f988602e88c49625a862a4ce696]
But as of 2019 GNU Prolog does not have a module system.

See also:
- https://en.wikipedia.org/wiki/Comparison_of_Prolog_implementations
- Comparison between SWI Prolog, YAP, GNU Prolog http://www.david-reitter.com/compling/prolog/compare.html

Prolog in JavaScript/browser
http://tau-prolog.org/
** <2019-03-26> What is a Prolog IDE?
SWISH?
 [fn::http://www.swi-prolog.org/IDE.html]
 [fn::https://stackoverflow.com/questions/5277263/good-ide-to-get-started-with-prolog]

I use VSCode.
There may be other IDEs, but I don't know which one is supported.
It's one of the woes of using an unpopular language: Few people are working on the tools.
** Prolog community
Where is the community?
- IRC requires login.
  Where is the chat log?
- SWI-Prolog Google Groups (web-browsable mailing list) https://groups.google.com/forum/#!forum/swi-prolog
- comp.lang.prolog https://groups.google.com/forum/#!forum/comp.lang.prolog
- StackOverflow tag swi-prolog https://stackoverflow.com/questions/tagged/swi-prolog
- SWI-Prolog roadmap https://github.com/SWI-Prolog/roadmap
- http://www.swi-prolog.org/Links.html
- https://www.reddit.com/r/prolog/
- http://prolog-commons.org

SWI-Prolog packs need curation/vetting/testimony/promotion.
** Things to do in each OS reinstall
This has to be at least once.
This may have to be redone every time we replace our operating system, such as when replacing Ubuntu 14.04 with Debian 9.
*** <2018-10-20> Installing SWI-Prolog 7.6.4 on Ubuntu 14.04
If you are using Ubuntu 14.04, follow my instructions below.
If your operating system has packaged SWI-Prolog 7.6.4 or newer, use it.
Otherwise, follow the [[http://www.swi-prolog.org/Download.html][official instructions]] and find SWI-Prolog 7.6.4.

The following guide is for installing SWI-Prolog 7.6.4 on Ubuntu 14.04.

Uninstall existing SWI-Prolog installations.
The version packaged with Ubuntu 14.04 is too old (6.6.4).
SWI-Prolog 7 introduces a new double-quoted string type.

Install dependencies.
I take this from the [[http://www.swi-prolog.org/build/Debian.html][Debian build instructions]] with these changes.
I replace =libunwind-dev= with =libunwind8-dev=.
I remove =openjdk-8-jdk= and =junit=.
I add =libreadline-dev=.
#+BEGIN_EXAMPLE
sudo apt-get install \
        build-essential autoconf curl chrpath pkg-config \
        ncurses-dev libreadline-dev libedit-dev \
        libunwind8-dev \
        libgmp-dev \
        libssl-dev \
        unixodbc-dev \
        zlib1g-dev libarchive-dev \
        libossp-uuid-dev \
        libxext-dev libice-dev libjpeg-dev libxinerama-dev libxft-dev \
        libxpm-dev libxt-dev \
        libdb-dev \
        libpcre3-dev \
        libyaml-dev \
        libreadline-dev
#+END_EXAMPLE

That doesn't include the documentation dependencies because they are too big.
Just read the documentation online.

After apt-get finishes, for security (avoiding sudo cache), close that terminal, and open a new one.

Download the [[http://www.swi-prolog.org/download/stable][source]].

Check the checksum using sha256sum.

=cp -p build.templ build=

=mkdir -p $HOME/.local=

Edit =build= script.
Set =PREFIX= to =$HOME/.local=.
Uncomment the =--link= option in =EXTRACFG= variable.

Run =./build=.
It should take a few minutes (about 5 minutes on my 4-core 8-GB-RAM machine).

Ensure that =$HOME/.local/bin= is in your =PATH=.
For example, I have this line somewhere near the end of my =~/.bashrc= file:
#+BEGIN_EXAMPLE
export PATH="$PATH:$HOME/.local/bin"
#+END_EXAMPLE

If you edit your bashrc, close your terminal and open a new one.
Then enter =swipl --version= in the new terminal.
The program should show something like this:
#+BEGIN_EXAMPLE
SWI-Prolog version 7.6.4 for x86_64-linux
#+END_EXAMPLE

If you don't want to edit your bashrc, you can run swipl by its full path =~/.local/bin/swipl=.
*** Enabling readline
We want readline for history (Ctrl+R, Ctrl+S) and completion (Tab, Ctrl+P/Up, Ctrl+N/Down).

To keep the entire codebase under BSD license,
SWI-Prolog doesn't enable the GPL-licensed GNU readline by default.
But you can tell SWI-Prolog to use readline.
First, install your distro's libreadline-dev package.
Then, put this line in your =~/.swiplrc=:
#+BEGIN_EXAMPLE
:- set_prolog_flag(readline, readline).
#+END_EXAMPLE

Related: [[https://github.com/SWI-Prolog/issues/issues/72][GitHub issue #72]]: "how to build with GNU readline on linux".
* Workflow
We assume that you have installed SWI-Prolog 7.6.4.
** Starting the interpreter and the documentation server
I start SWI-Prolog with this command line:
#+BEGIN_EXAMPLE
swipl --pldoc=DocPort -l PrologFile
#+END_EXAMPLE

I use 4002 for DocPort.

I open [[http://localhost:4002/pldoc/]] in my browser.
** Thinking and editing
I edit some Prolog source files in Visual Studio Code with vim key bindings
because I often need to duplicate a line when adding a new clause.

I add statements or comments.

I think a lot about names, representations, and relations.

To edit the source of a thing in PceEmacs, we have several options:
- click the "Edit file" or "Edit predicate" button in pldoc server, or
- query =edit(Name)= or =edit(Name/Arity)= in the interpreter.
** Rebuilding
To see the updated documentation,
I click "Make & Reload" button in my pldoc website, if I haven't done so.
If I have clicked that button, I simply refresh my browser with F5 or Ctrl+R.

To test the program, I query =make.= in the interactive prompt, and I enter some queries.

Warnings are errors.
If there is a warning, I go back to editing.
"Singleton variables" most likely mean there's a typo.
** Trying and manual testing
Important: /Prolog source file and Prolog query prompt have different syntax./
A Prolog source file contains /statements/.
The Prolog interpreter accepts /queries/.
Pasting a file into the interpreter does /not/ load the file;
this is contrary to Lisp/Python/Ruby interpreters.

The prompt =?-= means that the interpreter is expecting a /query/.
However, we can enter temporary statements:
- Type the query =[user].=.
  The prompt changes to =|:=.
  We're now at the statement prompt.
  (The syntax =:- [foo].= is shorthand for =:- consult(foo).= which is documented in [[http://www.swi-prolog.org/pldoc/man?predicate=consult/1][consult/1]].)
- Enter several lines of statements.
- End with a new line and Control+D.
  We're now back at the query prompt.

Those temporary statements disappear when the interpreter quits.

Usually, after trying my changes, I go back to thinking and editing.
** Seeing source codes and finding definitions
To show the canonical representation (properly-parenthesized tree form) of a term, query =write_canonical(Term)=.

To see the source code of a predicate, query =edit(Name)= or =edit(Name/Arity)= or =listing(Module:Name)= or =listing(Name)=.
We can see the source code of libraries.
We can easily find where things are defined.
** Troubleshooting: tracing and spying
Having to use the tracer means I have failed to design unsurprising programs.
It means that my past self have failed to communicate to my future self.

Sometimes I query debug/0 to disable optimizations so that errors have full stack trace.
Sometimes I need to restart the interpreter and query debug/0 before running my development web server.
See also nodebug/0.

I start tracing a goal with the query =trace, Goal.=
In the tracer prompt:
- =a= aborts (calls abort/0; goes back to toplevel interpreter prompt)
- =c= creeps ("step into" in modern debugger parlance)
- =s= skips ("step over" in modern debugger parlance)
- =l= leaps ("run" in modern debugger parlance)
- Type =/f= in the tracer prompt to run to the next failure.

I stop tracing by notrace/0.

TODO spy/1, tspy/1

trace/0, gtrace/0, notrace/0

These resources say something about fixing programming errors:
- https://www.cs.ucsb.edu/~kyledewey/cs162w15/debugging_prolog.html
- http://www.swi-prolog.org/pldoc/man?section=debugoverview
- https://www.metalevel.at/prolog/testing
- https://www.metalevel.at/prolog/debugging
** Committing to a Git repository
I commit my work to Git repository with Emacs Magit or git-gui.
I sanity-check the tree with =gitk --all=.
I push my work to my GitHub work repository.
* The things we have to know
This chapter should not exist.
The users have to know these, but when should we introduce these topics?
- operational semantics: how the Prolog program actually runs: depth-first search (brute force)
- how to get unstuck
** Which string representation should I use?
The answer: Dedicated double-quoted string type (SWI-Prolog 7), unless you have to care about portability.
- "Strings are distinct from lists"[fn::http://www.swi-prolog.org/pldoc/man?section=strings]
- "Why has the representation of double quoted text changed?"[fn::http://www.swi-prolog.org/pldoc/man?section=ext-dquotes-motivation]
- 2013 article "Strings in ECLiPSe 6.2, SWI-7 and YAP"[fn::http://eclipseclp.org/wiki/Prolog/Strings]
  - "With SWI-7 and ECLiPSe 6.2 string support has been harmonized, and YAP is expected to agree as well."
  - "Agreed Common Functionality"
  - "Situation before December 2013"

Non-answer: Edinburgh style: Double-quoted string as list of integer codes (default mode of SWI-Prolog 6.6.4 on Ubuntu 14.04):
A string is represented as a list of character codes.
Example: ="aaa" = [97,97,97]=.
But this behavior changed in SWI-Prolog 7.
This was in 1993 ISO standard draft[fn::http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf], but this wasn't in the final version?

Non-answer: Double-quoted string as list of one-character atoms.
A string is represented as a list of one-character atoms.
Example: ="aaa" = [a,a,a]=.
This is backward-incompatible and creates lots of garbage.
** Some Greek words used in philosophy and programming
"ontos" is "(of) being".

"episteme" is "knowledge".

"logos" is "word", "theory".

Thus, "ontology" is "theory of being", and "epistemology" is "theory of knowledge".
They are two branches of philosophy.
** <2018-12-10> Smart editors are dangerous! Arbitrary code execution!
I use the VSCode extension VSC-Prolog, but I disabled its linter after I realize that it may execute arbitrary code.
I only use its syntax highlighting and documentation popup feature.
Fortunately the plugin is still very useful without the linter.

Imagine this file:
#+BEGIN_EXAMPLE
% doom.pro
:- shell('touch ~/doomed').
#+END_EXAMPLE

I loaded that file into VSCode, and a file named =doomed= appeared in my home directory.
I'd be really doomed if someone replaced that command with 'rm -rf /'.

Perhaps we should make a whitelist of allowed directives?

Vim suffers the same thing with its modelines. I think it's now disabled by default?

However, this doesn't affect you if you only open what you write yourself, and never open a criminal's Prolog code.
But this is an accident waiting to happen!

I reported this:
- https://github.com/arthwang/vsc-prolog/issues/31
** Modules?
Prolog syntax for use_module is documented in [[http://www.swi-prolog.org/FAQ/LoadLibrary.html][LoadLibrary FAQ]], not in the documentation for use_module/1.
The =library= alias is defined in file_search_path/2.

swipl: use =-s= instead of =-l=
http://www.swi-prolog.org/pldoc/man?section=cmdline
** Equalities and equivalences?
What is the difference: =, ~==~, ~=:=~, is
* Declarative Prolog, and other beautiful things
What is the meaning/interpretation of a Prolog program?

How to read a Prolog program?
** How to read declarative Prolog programs
A /Horn clause/ =A :- B= means "to prove A, prove B".
The left-arrow =:-= can be read as "if".

#+BEGIN_EXAMPLE
wet :- rain.
wet :- sprinkle.

% The same.

wet :- rain ; sprinkle.
#+END_EXAMPLE

The conjunction =A,B= means prove A /and then/ prove B.
Prolog proves them in sequence.

Example:
The fire triangle[fn::https://en.wikipedia.org/wiki/Fire_triangle]:
#+BEGIN_EXAMPLE
% A line comment begins with a percent sign.

fire :- oxygen, heat, fuel.

oxygen.
heat.
#+END_EXAMPLE

Prolog complains about undefined predicate fuel/0.

An alternative in which Prolog does not complain about undefined predicates:
#+BEGIN_EXAMPLE
known(oxygen).
known(heat).
known(fire) :- known((oxygen,heat,fuel)).
known((A,B)) :- known(A), known(B).
#+END_EXAMPLE

We have just defined a small /world/, a small /ontology/.
(Is this too fast-paced for beginners?)

The disjunction =A;B= means prove A /or/ prove B.
If A fails, Prolog backtracks and tries to prove B.

Non-variables in clause head abbreviate unification.
For example, =p(a,b) :- Q= abbreviates =p(A,B) :- A=a, B=b, Q=.

=A :- B= is pure iff all reordering of the phrases of B doesn't change the result?

=\+A= means "fail to prove A".
It is not classical-logical negation.

Every variable is implicitly universally quantified.

The prompt =?- Q= means we ask Prolog to prove =Q=.

Perhaps elucidating
https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics

We often define a set \(A\) with the set-builder notation \( \SetBuilder{x}{\phi_A(x)} \).
We should not conflate a set \(A\) and its membership-testing predicate \(\phi_A\).

A set can be thought as all the ground terms that satisfy a predicate.
#+BEGIN_EXAMPLE
% person ~ {joe}
person(joe).

% natural ~ {0, 1, 2, ...}
natural(N) :- integer(N), N >= 0.
#+END_EXAMPLE
** Epistemic interpretation of Prolog programs: Failure as ignorance
Sometimes a Prolog program should be interpreted epistemically,
in which Prolog's /fail/ is treated as /unknown/ instead of /false/.
In this interpretation:
- Succeeding to prove a goal G means that we know that G is true.
- Failing to prove a goal G means that we do not know anything about G.

There are two negations: There is a difference between not/1 and \+/1.
In the epistemic interpretation, "\+" should be read as "unknown".

=\+G= means we do not know G.

Succeeding to prove not(G) means that we know that G is false.
#+BEGIN_EXAMPLE
:- multifile not/1.
#+END_EXAMPLE

We waive the law of excluded middle.
In our Prolog program it does not hold that G ; not(G).

Suppose is_big(john).
If is_big(X) fails, it simply means that we don't know whether X is big.

Suppose that is_big(john,true) means we know that John is big.
And is_big(john,false) means we know that John is not big.
If is_big(john,_) fails, then we don't know whether John is big or not.
** Designing predicates: naming is hard.
The name of a relation should describe the relationship.

If we intend that there is only one relation between A and B that makes sense,
then we may name that relation A_B.
But:
- What if A or B contains underscores?
- Why do we prefer =father_child= to =beget= or =sire=?

is_thing(A).

A procedure's name should begin with a verb.

Order the parameters from the most likely to be bound.
If parameter A is more likely to be more bound than parameter B, then A should come before B.
Example: Write list_length/2 instead of length_list/2.
Unfortunately not everyone follows this convention.
** Naming the parts of a list: head, tail, and butt
- "head" is the first element
- "tail" is everything but the head
- "butt" is the last element
** Total relational programming? Relational programs that can be proven to terminate?
A total relation is a relation that is defined for every element in its domain.

If there is total functional programming, then there should be total relational programming.

It is too easy to write a Prolog program that doesn't terminate.
** Defining your own operators
- =:- op(Precedence, Type, Name)=
* Imperative Prolog, and other ugly things
Some ugly things are unfortunately necessary.
There are always some dirty jobs in real-world programming.
Example dirty jobs are input-output and error handling.
** The meanings of a Horn clause
A Horn clause in Prolog looks like =A :- B=.

A Horn clause can be thought of in several ways.

The operational meaning of =A :- B1, ..., Bn= is that calling the procedure A causes B1, ..., Bn to be called in that order.
This is the actual meaning of Prolog programs.
All other meanings are useful fantasies.

The classical-logic reading of =A :- B= is \(A \leftarrow B\), that is, "A is true if B is true" or "A is implied by B".

The proof-theoretic reading of =A :- B= is "to prove \(A\), it is enough to prove \(B\)".

The search-tree reading of =A :- B1, ..., Bn= is that the tree node A has the children B1, ..., Bn.

These multiple readings are confusing.
For example, the classical-logic reading implies that querying =a= against the following knowledge base should succeed because in classical logic \( A \leftarrow (B \wedge A) \equiv A \leftarrow B \),
but the query =a= actually does not terminate.
#+BEGIN_EXAMPLE
a :- b, a.
b.
#+END_EXAMPLE
In classical logic but not in Prolog,
that knowledge base is equivalent to this:
#+BEGIN_EXAMPLE
a :- b.
b.
#+END_EXAMPLE

Enhancing the declarativeness of Prolog requires /memoization/.

What is the relationship between logic programming, relational programming, logic, Horn clauses, theorem proving, searching, and backtracking?

** Prolog operational semantics
*** Swapped phrases
There is only a small syntactic difference between =dfs= and =bfs= (it's just flipped order).

Which one exploits tail call optimization (last call optimization)?
#+BEGIN_SRC prolog
bit(0).
bit(1).

dfs([]).
dfs([H|T]) :- bit(H), dfs(T).

bfs([]).
bfs([H|T]) :- bfs(T), bit(H).
#+END_SRC
*** Understanding depth-first search, backtracking, choice points, performance, and cuts
Save this knowledge base into a file, and load it into Prolog.
#+BEGIN_SRC prolog
a(0).
a(1).

b(0).
b(1).
#+END_SRC

Run the query =a(A), b(B).= and press =;= until Prolog fails.

This is what Prolog finds (we remove the newlines to make it more readable):
#+BEGIN_EXAMPLE
A = B, B = 0 ;
A = 0, B = 1 ;
A = 1, B = 0 ;
A = B, B = 1.
#+END_eXAMPLE

This is the search space (search tree) of that query.
#+BEGIN_EXAMPLE
       ?- a(A), b(B).
      /              \
    A = 0           A = 1
   /     \         /     \
B = 0   B = 1   B = 0   B = 1
#+END_EXAMPLE

Prolog traverses that tree in depth-first order as follows:
#+BEGIN_EXAMPLE
- ?- a(A), b(B).
  - A = 0
    - B = 0
    - B = 1
  - A = 1
    - B = 0
    - B = 1
#+END_EXAMPLE

The important things to infer from this experiment are:
- Prolog repeats the work on =b= as many times as the number of ways of satisfying =a=.
  If =a= can be satisfied in N ways, and satisfying =b= is a lot of work,
  then Prolog may do that work N times,
  although the work produces the same result.
- Everything to the right of an infinite branch will never be visited.

What is a choice point?

A cut makes =a(A), b(B)= and =b(B), a(A)= return different results.

How far does a cut cut?

"The craft of Prolog" defines three kinds of cuts: red, green, and blue.
- A red cut destroys the logical meaning of a program.
  Green and blue cuts don't.
*** Prolog is a depth-first brute-forcer
But you can emulate other search algorithms too.
**** Non-termination pitfalls, and how to generate terms correctly
Sometimes we forget that Prolog, on failure, backtracks (retries), not stops.

Sometimes we focus too much on the logical reading and neglect the procedural reading.

For example, suppose that you want to generate all lists whose length doesn't exceed 2.

The following is a mathematically correct statement about that fact,
but it doesn't work in Prolog.
It has correct logical reading, but incorrect procedural reading.
If you keep pressing =;=, this will fail to terminate.
#+BEGIN_SRC prolog
?- length(A, LA), LA =< 2.
#+END_SRC

The correct way to do that is to use =between/3= (inclusive):
#+BEGIN_SRC prolog
?- between(0, 2, LA), length(A, LA).
#+END_SRC

We can also use the =clpfd= library:
#+BEGIN_SRC prolog
:- use_module(library(clpfd)).

?- LA in 0..2, indomain(LA), length(A, LA).
#+END_SRC

We shouldn't have to resort to cuts:
#+BEGIN_SRC prolog
% Don't do this.
?- length(A, LA), (LA =< 2 -> true; !, fail).
#+END_SRC

See also:
- https://www.metalevel.at/prolog/nontermination
  - "[Non-termination is] common among beginners, and often lead them to perceive Prolog as 'slow', when in fact their program does not terminate /at all/."

** Cuts
- slide 5-28, pitfalls in implementing abs with cut http://users.informatik.uni-halle.de/~brass/lp06/c5_propr.pdf
** Speeding things up
*** Profiling: finding where your program spends time; finding where it is slow; diagnosing slowness
To run your =Goal= with profiling, simply query =profile(Goal)=.

Profiling couldn't be any simpler than this!

** Functional/expression style sometimes beats relational/unification style
#+BEGIN_EXAMPLE
-- Functional/expression style
g (f0 x0) (f1 x1) (f2 x2)

% Relational/unification style
f0(X0, Y0), f1(X1, Y1), f2(X2, Y2), g(Y0, Y1, Y2, Z).
#+END_EXAMPLE
Example where functional style wins:
- string formatting
- number crunching

If backtracking isn't involved, functional style wins (is more concise than relational style).

If computation is reversible, relational style wins (half the amount of code of functional style).

We should use both styles depending on circumstances.

We can define a functional/expression/applicative/evaluative sublanguage in Prolog, roughly like this:

#+BEGIN_SRC prolog
eval((A = B), Val) :- A = B, eval(B, Val), !.
eval(F, Val) :- callable(F), call(F, Val), !. % lots of hand-waving here
% etc.
#+END_SRC

Haskell is weak against the AST decoration problem.
Dynamic languages (Scheme, JavaScript, Prolog) / gradual-typed languages (TypeScript) beat static languages (Haskell) on the AST decoration problem.
How about Ocaml polymorphic variants?

Should we move from Prolog to Scheme/miniKanren or Mercury?
** Directives like =:- op= complicate parsing a Prolog source code.
** Zero-arity compound term
Use compound_name_arity/3 instead of functor/3, but this seems to be an SWI-Prolog extension.

http://www.swi-prolog.org/pldoc/man?section=ext-compound-zero
** Some Prolog negation tricks?
Prolog =\+= can be used to limit the scope of unification, although not the scope of the variable itself.
This exploits the fact that throw/1 does not backtrack in the way fail/0 does.

When using Prolog procedurally, we often want throw/1 instead of fail/0.

It makes more sense to design a procedural DSL on Prolog than to use Prolog itself procedurally.
** The procedural-provability-logic interpretation of Prolog Horn clauses
=p :- q, r= can be interpreted as "to prove p, first prove q, and then prove r".
*** Problem: Horn clauses and biimplications
Classical propositional logic formula \( a \iff b \) (which is equivalent to \((a \to b) \wedge (b \to a)\)) does /not/ translate to this Prolog program:
#+BEGIN_EXAMPLE
a :- b.
b :- a.
#+END_EXAMPLE
Querying =?- a= does not terminate.

This terminates:
#+BEGIN_EXAMPLE
% H is the hypothesis bag.

a(H) :- member(a,H).
a(H) :- \+ member(a,H), b(H).

b(H) :- member(b,H).
b(H) :- \+ member(b,H), a(H).
#+END_EXAMPLE
** Purifying Prolog?
- assert/2 can be replaced with two parameters (state and next-state).
** Error handling and logging
*** Fail, throw, stack traces
Two options: throw or fail.

If backtracking doesn't make sense, then throw, don't fail.

#+BEGIN_EXAMPLE
person(joe).
pair_first_second(pair(A,_), A, B).
#+END_EXAMPLE

Should =person(1)= fail or throw?
Should =pair_first_second(foo)= fail or throw?

Fail means try the next alternative.

If you want throw/1 with stack trace,
you must write it like =throw(error(Something, _))=.

A /function/ should always throw and not fail, when an argument has a wrong type.

#+BEGIN_EXAMPLE
negate(A,B) :- integer(A), !, B is -A.
negate(A,B) :- integer(B), !, A is -B.
negate(A,B) :- throw(error(negate(A,B),_)).
#+END_EXAMPLE

- https://wiki.colby.edu/display/~amvartan/Exception+and+Error+Handling+in+Prolog
- https://stackoverflow.com/questions/32968148/why-throw-an-exception-in-prolog-instead-a-simple-fail
*** Structured logging
This is how we log messages in Prolog:
- Design a term that represents the /meaning/ of the message.
- Call =print_message(Kind,Message)= where Message is that term.
- Extend =prolog:message//1= to translate that term to string.

#+BEGIN_EXAMPLE
% Syntax:
prolog:message(Term) --> Lines.

% Example:
prolog:message(Term) -->
    [ 'The term is ~q.'-[Term] ],
    [ 'This is the second line in the message.' ].
#+END_EXAMPLE

Syntax description:
- 'Lines' is a list of 'Line's.
  - A 'Line' has this shape:
    - Format-Args: 'Format' and 'Args' are the same arguments accepted by format/2.
    - Terms of other shapes are converted to string.

The printed message is the concatenation of all 'Line's.

TODO:
- How do we log to file?
- How do we rotate log files?

References:
- [[http://www.pathwayslms.com/swipltuts/message/index.html][Anne Ogborn's "Printing Messages in SWI-Prolog"]]
- http://www.swi-prolog.org/pldoc/man?section=printmsg
- http://www.swi-prolog.org/pldoc/man?section=debug
- https://www.metalevel.at/prolog/business

Usability issues:
- Where is =prolog:message//1= documented?
  I found that by looking at others' source code.
  There does not seem to be any documentation, or if there is, then it is at the wrong place.
- Why do we require people to understand DCG rules before they can use the messaging system?
* Programming in the large with Prolog
** A suggested way to use Prolog
Begin by defining an ontology or domain-specific language.
This is pure Prolog with declarative semantics.

Then specify a transformation or interpretation to reality.

Example:
A functional programming language:
#+BEGIN_EXAMPLE
%%  interpret(+Expression,-Value) is det.

interpret(write(A), Z) :- !,
    interpret(A, A0),
    write(A0),
    Z = unit.

interpret(A+B, Z) :- !,
    interpret(A, A0),
    interpret(B, B0),
    Z is A0 + B0.

interpret((A,B), Z) :- !,
    interpret(A, _),
    interpret(B, Z).

interpret(A, Z) :- number(A), !, Z = A.
interpret(A, Z) :- string(A), !, Z = A.
interpret(A, _) :- !, type_error(expression, A).
#+END_EXAMPLE

** Disciplines for writing large maintainable Prolog knowledge bases
Some disciplines are required:
- Separate declarative and imperative codes.
- Avoid depending on module systems.
- Each declarative source file is a small /ontology/.
  Each imperative source file /merges/ some ontologies.
** Organizing and loading Prolog source files without name clashes
Prolog multifile predicates can be used for /dependency injection/.
Instead of importing a module, declare a multifile predicate and let the user link that predicate.

Prolog source files come in /two kinds/ depending on how they are loaded: /type-1/ files and /type-2/ (module-free) files.
In short, a type-2 file should not assume that the Prolog implementation has a module system, unless when defining meta-predicates.
The discipline is:
- A type-2 file should not contain any directives except include/1.
  Thus a type-2 file must not begin with module/2 directive, and must not use the use_module/[1,2] directive.
- A type-2 file should not contain hard-coded module references.
  A type-2 file should not contain any qualified M:P call where M is a hard-coded atom;
  it is fine if M is a variable.

There are several incompatible ways to load a Prolog source file: include/1, consult/1, use_module/2, load_files/2.

consult_unregistered/2 is load_files/2 with module/1 and register(false) options.

The function of the main file is to link the non-main files.
To maximize reusability and minimize name clash,
a non-main file must not contain any hard-coded module names:
Those files must not contain module/2 declarations and use_module/[1,2] directives.
** Component/module system, socket-plug metaphor
I need a component system for programming in the large.
Prolog module system is a building block, but Prolog modules by themselves are not enough.
Socket-and-plug metaphor fits nicely?
The name tells it all:
a socket is a female connector and a plug is a male connector,
and we connect plugs to sockets,
and Prolog should complain if it sees a socket that is connected not exactly once.

An input is a multifile predicate.

A pin is a Name/Arity term.

A plug exports symbols.

A socket imports symbols.

A module may have multiple plugs and sockets.

Pins are matched by NameArity.
The ordering of pins does not matter.

A Prolog module system is either /predicate-based/ or /atom-based/.
XSB is atom-based.
SWI is predicate-based.
GNU Prolog does not have a module system.

** Writing extensible knowledge bases
*** Multifile or parametrization-and-catamorphism?
#+BEGIN_EXAMPLE
:- multifile foo_ext/1.

foo(A) :- foo_ext(A).
#+END_EXAMPLE

Catamorphism:
#+BEGIN_EXAMPLE
foo(F,A) :- call(F,A).
#+END_EXAMPLE

Don't multifile if clause order matters.
Reloading changes clause order.
http://www.swi-prolog.org/FAQ/Multifile.html
** Production prolog
"Production Prolog" by Michael Hendricks; Strange Loop 2014
https://www.youtube.com/watch?v=G_eYTctGZw8
- This mentions "Mercury's bisecting debugger"
- mavis library for optional type declarations
- julian library for dates
- time/1 for measuring how long a goal takes
- library(spawn)?
* Theories
** Relational-multidirectional-logic programming?
** Embedding Prolog/Haskell in Haskell/Prolog
*** Embedding Prolog in Haskell
- 1999 article "Embedding Prolog in Haskell" https://pdfs.semanticscholar.org/7c46/5d25205830735d0a034532746b7243221eca.pdf
  - "We propose an embedding of logic programming into lazy functional programming
    in which each predicate in a Prolog program becomes a Haskell function,
    in such a way that both the declarative and the procedural reading of the Prolog predicate are preserved."
- 1988 article "Towards functional programming in Prolog" ftp://obaluae.inf.puc-rio.br/pub/docs/Publications/88_AI_Furtado_SINPLAN.Not.pdf
*** Embedding Haskell in Prolog: Nobody is talking about this?
translate haskell to prolog
- https://stackoverflow.com/questions/1932770/haskell-vs-prolog-comparison
- https://github.com/COMS30106/slides
- https://github.com/COMS30106/slides/blob/master/haskell2prolog.pdf

Prolog and Haskell are almost equally concise.
Prolog and Haskell are even in head/2 and tail/2.
Prolog beats Haskell in null/1 and reverse/2.
Haskell beats Prolog in length/2, sumList/2, and everything that has arithmetics where Prolog requires intermediate variable such as "N1 is N-1".
** Comparison with other programming languages
"GOEDEL is intended to be a declarative successor to Prolog."
https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/impl/other/goedel/0.html

How are Prolog and Lisp similar?
- Both Prolog and Lisp have symbols and cons cells.
  - This is a Lisp cons cell: =(cons 'a 'b)= or ='(a . b)=.
  - This is the corresponding SWI-Prolog cons cell: =[a|b]= (the canonical form is ='[|]'(a,b)=).
- Both have macros.
  - Lisp has defmacro.
  - Prolog has term_expansion/2 and goal_expansion/2.

I'd say Prolog = Lisp + unification + backtracking - lambda.

Comparison between what is difficult in various programming languages:
- 2014 presentation "That scripting language called Prolog" https://www.slideshare.net/SergeiWinitzki/prolog-talk
  - It compares what is difficult in various programming languages.
  - It defines "declarative": 'Programming is "declarative" when /specifications are programs/.'
    - Slide 29: "declarative programming = creating a good DSL for your domain"
  - Slide 24 compares SQL, Datalog, and Prolog.

Comparison with other relational programming languages:

Comparison with miniKanren:
- https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp
  - William E. Byrd's answer:
    - Prolog is practical; miniKanren is pure.
    - Prolog unification doesn't use occurs check; miniKanren unification uses occurs check.
    - Prolog uses depth-first search; miniKanren uses complete interleaving search.
    - '[...] miniKanren is being used for research in "relational" programming.'
    - "Over time miniKanren has added more symbolic constraints, really becoming a symbolically-oriented Constraint Logic Programming language."
    - "There are other very interesting logic programming languages as well, such as Mercury, Curry, and Gödel, each of which has its own take on logic programming."

Mercury vs Prolog
- http://lambda-the-ultimate.org/node/890
- <2018-10-21> "The Prolog to Mercury transition guide" https://www.mercurylang.org/information/doc-latest/transition_guide.pdf

SQL? Datalog?
* <2018-12-05> How to present Prolog to newcomers
This is a draft.
These are slides.
Assume that one section is one slide.
#+TOC: headlines 1 local
** The coolest thing about Prolog: relational/multidirectional programming
The Prolog phrase "append(A, B, C)" means the English clause "appending list A and list B produces list C".

Here we show some ways of calling append/3.
Here we show how to read Prolog fragments in English.

"Prolog, does appending [1] and [2,3] produce [1,2,3]?"
#+BEGIN_EXAMPLE
?- append([1], [2,3], [1,2,3]).
true.
#+END_EXAMPLE

"Prolog, what does appending [1] and [2,3] produce?"
#+BEGIN_EXAMPLE
?- append([1], [2,3], C).
C = [1,2,3].
#+END_EXAMPLE

"Prolog, what list do I have to append to [1] in order to produce [1,2,3]?"
#+BEGIN_EXAMPLE
?- append([1], B, [1,2,3]).
B = [2,3].
#+END_EXAMPLE

"Prolog, what list produces [1,2,3] when appended with [2,3]?"
#+BEGIN_EXAMPLE
?- append(A, [2,3], [1,2,3]).
A = [1] ;
false.
#+END_EXAMPLE

"Prolog, does appending [1] and [2] produce [1,2,3]?"
#+BEGIN_EXAMPLE
?- append([1], [2], [1,2,3]).
false.
#+END_EXAMPLE

We press ";" to ask Prolog to find another solution.
Prolog prints "false" when it doesn't find any more solutions.

"Prolog, what list produces [1] when appended with itself?"
#+BEGIN_EXAMPLE
?- append(A, A, [1]).
false.
#+END_EXAMPLE

"Prolog, what list produces [1,2,1,2] when appended with itself?"

"[1,2]."

"Is there any other such list?"

"No."
#+BEGIN_EXAMPLE
?- append(A, A, [1,2,1,2]).
A = [1,2] ;
false.
#+END_EXAMPLE

"Prolog, what two lists A and B produce [1,2,3] when appended?"
#+BEGIN_EXAMPLE
append(A, B, [1,2,3]).
A = [], B = [1,2,3] ;
A = [1], B = [2,3] ;
A = [1,2], B = [3] ;
A = [1,2,3], B = [] ;
false.
#+END_EXAMPLE
** Write once, run in several directions
The Prolog code for append/3 seems simple.
We can see in SWI-Prolog library/lists.pl [[http://www.swi-prolog.org/pldoc/doc/_SWI_/library/lists.pl?show=src#append/3][append/3]] (I renamed some variables to improve readability):
#+BEGIN_EXAMPLE
append([], B, B).
append([H|A], B, [H|C]) :- append(A, B, C).
#+END_EXAMPLE

Haskell seems simpler:
#+BEGIN_EXAMPLE
append [] b = b
append (h : a) b = h : append a b
#+END_EXAMPLE

But those fragments differ.
Prolog gives us the ability to run the code in other directions.
There are 3 parameters; each parameter is either bound or unbound; thus there are 2^3 = 8 possible directions.
If we don't use a logic programming library in Haskell,
the Prolog predicate translates to at least 5 Haskell functions,
for the 5 ways of using append/3 we saw earlier.
If we use a logic programming library in Haskell, the definition wouldn't be as concise as the Prolog definition.

We write append/3 once, and we get at least five ways of calling it.

But this beautiful dream crumbles outside /pure/ logic programming.
** Another declarative example: palindromes
"A list L is a palindrome iff L is its own reverse."
#+BEGIN_EXAMPLE
palindrome(L) :- reverse(L, L).
#+END_EXAMPLE
** What
2015
Approaches for Learning Prolog Programming
https://www.tandfonline.com/doi/full/10.11120/ital.2007.06040088
* Ideas to flesh out?
** Prolog should use three-valued logic?
Suppose that both A and B are unbound variables.
Then:
- =A == B= is unknown, but it's false in Prolog.
- =A \= B= is unknown, not it's false in Prolog.

In that case, it is better for Prolog to throw an instantiation_error instead of failing.

Three-valued logic would simplify and elegantize constraint logic programming?
** Declarative programming? Function arguments?
The idea:
A relation's parameter can be a unifiable logic variable or a beta-reducible lambda expression.
#+BEGIN_EXAMPLE
is_one(A : exp(integer)) :- A = 1.
?- is_one(0+1).
true.

f(A : var(integer)) :- A = 1.
?- f(0+1).
false.
#+END_EXAMPLE

TODO
Compare various approaches such as LambdaProlog, Mercury, and Curry.
** Philosophy
Writing a Prolog knowledge base is an exercise in philosophy, especially ontology.
We ask these all the time:
- What exist?
- How do they relate?
- How do we model all those entities and relationships in Prolog for not-too-slow computation?
** Idea: Write an SQL database explorer in Prolog.
CLI interface without ncurses without pager.
Imagine printing to paper like early Fortran/Unix/ed.
Paper user interface.
- menu(KeyActionPairs).
- select database
- select schema
- show 10 rows of table, 15 chars per column, truncating long strings with ">"
  - tput https://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window
  - My 1920x1080 terminal has 191 columns and 53 lines.
- go up / back to previous menu.
** Use Prolog for formal software requirement capture / modeling.?
"Are there any standard Prolog knowledge bases available anywhere that have the same purpose as Cyc, namely to encode generally accepted common sense and human knowledge?"
https://cs.stackexchange.com/questions/35237/open-standard-prolog-knowledge-bases

2004 "SweetProlog: A System to Integrate Ontologies and Rules"
https://pdfs.semanticscholar.org/03c2/a0048a5845bb1f52462c4f26d7be0a929d7a.pdf

Prolog is better than Turtle.
http://sujitpal.blogspot.com/2009/06/ontology-rules-with-prolog.html
"I actually set out to learn Jena Rules using the Semantic Web Programming book as a guide.
Midway through that exercise, it occurred to me that Prolog would be a cleaner and almost drop-in replacement to the rather verbose Turtle syntax.
Apparently the Semantic Web community thinks otherwise, since Turtle stands for Terse RDF Triple language.
I haven't actually used Prolog before this, although I've read code snippets in articles once or twice (but not recently), so the realization was almost like an epiphany."

http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1989/8910/8910f/8910f.htm

https://www.cs.auckland.ac.nz/~j-hamer/07.363/prolog-for-se.html

http://ceur-ws.org/Vol-274/paper6.pdf
** Meta-programming
- To define 'macros', use =term_expansion= or =goal_expansion=.
** Use clpfd #=/2 instead of is/2?
But it's good to have minimal dependencies.
** Iterative deepening search with length/1
Prolog uses depth-first search.
It isn't complete.
(What does that mean?)

If you have a query =goal(List)= where =List= is a list,
then you can query =length(List, _), goal(List)= to make the search complete.

https://en.wikibooks.org/wiki/Prolog/Search_techniques
* What mess?
** Ramble: Translating Prolog to native code?
The idea is to relate a Prolog predicate and a C routine.

Every disjunct translates into one routine / basic block.

The current goal relates to the instruction pointer.

Proving a goal ~ calling a routine
Conjunction of phrase ~ sequence of call
Disjunction of clause ~ speculative parallel execution, for pure predicates only

p(A),q(A) can be optimized from O(PQ) time to O(max(P,Q)) time if we order the storage.

Intermediate language
Compile by abstract interpretation
unify(Var1,Var2)
frame(Instrs)
prove((A,B)) :- prove(A), prove(B).

A variable in clause head is implicitly universally quantified.
A free variable in clause body is implicitly existentially quantified.


Prolog just-in-time compilation
compile(GoalAst, Fragment)
call(Fragment)
Execute?

Compile prolog predicates, limited to u32 parameters.
Normalize p(a). to p(A) :- A=a.
If first arg is bound, use index.
Else sequential scan.
Subset of prolog.
Focus on translation for performance.
No dynamic predicates.
Generate a c func for some predicate direction.
plus_bbb
plus_bbu
...
plus_uuu
Add a state parameter for nondet predicate. (Next clause index to try). Initial value 0.
p(A,B) :- B is A + 1.

Libjit vs llvm?
mmap and mprotect

father_child(F,C)

bool father_child(termref F, termref C) {
}
** Implicit state language?
#+BEGIN_SRC prolog
interpret(state(S), S, S).
interpret(state_set(S), _, S).
interpret((A,B),S0,S2) :- interpret(A,S0,S1), interpret(B,S1,S2).
#+END_SRC
** Devops, dependency, build system?
Prolog marelle, Haskell shake, build system?

- http://quietlyamused.org/blog/2013/11/09/marelle-for-devops/
- "there is already a configuration management language that is strongly influenced by Prolog and logic programming - Puppet - and the results are not that great"
  https://news.ycombinator.com/item?id=6701362
  - really?
  - The computer can't read your mind.
    You lie to the computer, it does what you told it to do.
    Don't blame the computer for your failing to tell the computer everything it needs to do the job.
** Prolog revival attempt
- https://github.com/Web-Prolog/swi-web-prolog
** What
Gerrit has prolog?
https://gerrit-review.googlesource.com/Documentation/prolog-cookbook.html

Prolog web browser, prolog gui, prolog operating system, prolog system f, normal-order lambda calculus, Haskell in prolog

Prolog to glue Haskell, racket, typescript

<2018-12-06>
Prolog is the most ideal metalanguage I have found so far.

"adding a search Path in SWI prolog"
https://stackoverflow.com/questions/6334050/adding-a-search-path-in-swi-prolog

Alternative Prolog syntax?
Curry/ML-like syntax for Prolog?

#+BEGIN_EXAMPLE
append([],B,B).
append([H|A], B, [H|C]) :- append(A,B,C).

append [] B B.
append [H|A] B [H|C] :- append A B C.
#+END_EXAMPLE

If everyone could be 20x more productive using Prolog, then it is a sin to let them use Java or C++.
It is a massive waste of human life.

"Syntactic integration of external languages in Prolog"
https://pdfs.semanticscholar.org/35eb/0b9d6edc27dd4564d98b107fec08e45e36cd.pdf
SQL-Prolog
Draxler [2]
NED [5]


"The Mess We're In" by Joe Armstrong"
https://www.youtube.com/watch?v=lKXe3HUG2l4
43:20
We assume that two files A and B are similar if size(compress(A)) is similar to size(compress(A++B)).

"Goal: Adapting the Warren abstract machine to the LLVM IR machine model for later compilation."
"Hassan Aït-Kaci's WAM book"
2018
https://www.researchgate.net/project/Compiling-Prolog


decompilation
"J.P. Bowen, From Programs to Object Code and Back Again Using Logic Programming: Compilation and Decompilation, Journal of Software Maintenance: Research and Practice, Vol. 5, No. 4, pp.205-234, December, 1993"
https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/compiler2.html


Prolog parser in Prolog
https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/parser.html

XPCE may have been considered deprecated since 2015
https://github.com/SWI-Prolog/roadmap/issues/29



"What is Wrong with Logic Programming?"
"A Deductive Solution to Mutable State and I/O"
https://pdfs.semanticscholar.org/ca08/dcb9eddc1e7651509daac7fa02eddb7f675b.pdf

http://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/cql.html%27)
Draxler 1991 relates database table and Prolog predicate.
CQL models SQL query in Prolog terms.
** miniKanren?
Relational programming, microKanren
http://matt.might.net/articles/microkanren/

2017
A Unified Approach to Solving Seven Programming Problems (Functional Pearl)
http://io.livecode.ch/learn/gregr/icfp2017-artifact-auas7pp

2013
rKanren - Guided Search in miniKanren, Part I
http://cgswords.github.io/rkanren/

Schelog vs minikanren?
** what
!!
https://www.cambridge.org/core/journals/theory-and-practice-of-logic-programming/article/structured-alternative-to-prolog-with-simple-compositional-semantics/3E4B4198D74D6A2EC92DF4D6DC78DDE3

Prolog clpq documentation doesn't mention multivariate optimization?
https://stackoverflow.com/questions/27716598/constraint-values-on-local-variable

http://www.amzi.com/manuals/amzi/pro/ref_execution.htm

http://users.cs.cf.ac.uk/O.F.Rana/prolog/lectureP5/node3.html

https://coderwall.com/p/laduzw/how-to-measure-execution-time-in-swi-prolog

https://www.reddit.com/r/prolog/comments/9mxhbw/the_art_of_prolog_second_edition_is_available_as/

https://github.com/klauscfhq/awesome-prolog/blob/master/readme.md

http://www.swi-prolog.org/pldoc/man?section=modes

Twitter LOPSTR:
Logic Based Program Synthesis and Transformation: 13th International...

https://www.ajibot.com/blog/overview-of-logic-languages

https://stackoverflow.com/questions/1817010/embedded-prolog-interpreter-compiler-for-java

https://github.com/raydac/java-prolog-parser

http://dbs.informatik.uni-halle.de/Lehre/LP09/c3_purep.pdf

http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf

prolog headless clause
https://stackoverflow.com/questions/14168363/what-does-a-clause-without-a-head-mean-in-prolog

Read "The art of Prolog", second-order programming,

https://stackoverflow.com/questions/32835086/prolog-how-to-avoid-backtracking-without-cuts

Now I know this is false:
- Relational programming subsumes functional programming.
  - Functional programming is a special case of relational programming.
  - Every function is a relation.

Functional programming is more concise and readable than logic (relational?) programming when we are describing functions:
#+BEGIN_SRC haskell
fib 0 = 1
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
#+END_SRC

#+BEGIN_SRC prolog
fib(0,1).
fib(1,1).
fib(N,F) :- N1 is N-1, N2 is N-2, fib(N1,F1), fib(N2,F2), F is F1+F2.
#+END_SRC

But we can translate a function to a deterministic (det) predicate in Prolog.
** whaaat
This marshallp guy is... inhuman?
He uses Prolog for note taking!
https://news.ycombinator.com/item?id=1142292
** Search engine?
AntRank
http://www.ijettcs.org/Volume3Issue2/IJETTCS-2014-04-23-113.pdf
** Reverse engineering?
- 1992 "A Logic-Based Approach to Reverse Engineering Tools Production"
https://pdfs.semanticscholar.org/4882/9fd716349ff586e21e9277890989daa0e916.pdf

Prolog-COBOL stuff

- 1991, Using Prolog for Reverse-Engineering and Validation
http://www.academia.edu/2493008/Using_Prolog_for_reverse-engineering_and_validation
- 1994, "Reverse Engineering of COBOL Programs into Prolog Programs"
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.5073&rep=rep1&type=pdf
- 1992, "The Art of Computer Un-Programming: Reverse Engineering in Prolog"
http://www.academia.edu/1413561/The_art_of_computer_un-programming_Reverse_engineering_in_Prolog
  - https://link.springer.com/chapter/10.1007/3-540-55930-2_20

http://www.academia.edu/1413561/The_art_of_computer_un-programming_Reverse_engineering_in_Prolog
** Prolog, somewhat object-oriented, mapping from Java to Prolog
Prior arts:
2017 "Mapping Objects to Persistent Predicates"
https://pdfs.semanticscholar.org/f1ec/9e0e24faa1332d0cb60149e1d633b8d2509e.pdf

http://ceur-ws.org/Vol-274/paper6.pdf

Every Java class instantiation expression becomes a Prolog compound.

#+BEGIN_EXAMPLE
% From Java expression: new Class_name(field_1, field_n)
class_name(Field_1, ..., Field_N)
#+END_EXAMPLE

Every Java class instantiation statement becomes a Prolog fact.

#+BEGIN_EXAMPLE
% From Java statement: Class_name instance_name = new Class_name(field_1, field_n)
Class_name(Instance_name, Field_1, ..., Field_N).
#+END_EXAMPLE

Example
2010 "Simulating BPMN Models with Prolog"

#+BEGIN_EXAMPLE
final class Car {
    final String brand;
    final int year;
    // constructor omitted
}

Car a_car = new Car("Toyota", 2000);
#+END_EXAMPLE

becomes

#+BEGIN_EXAMPLE
car(a_car, [brand('Toyota'), year(2000)]).
% or
car(a_car, 'Toyota', 2000).
% or
car(a_car, car('Toyota', 2000)).
#+END_EXAMPLE

Large-scale Prolog?
1991 "Efficient Access To Large Prolog Knowledge Bases"
https://link.springer.com/chapter/10.1007/978-3-7091-7555-2_26
** What? 99 Prolog problems?
There is the [[http://www.ic.unicamp.br/~meidanis/courses/problemas-prolog/][99 Prolog problems]].
But what if you we are not undergraduate students with too much free time?
** Difference lists
- Who invented difference lists when?

A "difference list" is a term of the form =A - B= where =A= is a list and =B= is a list.

A difference list represents a list.

The difference list =A - []= represents the list =A=.

- https://en.wikipedia.org/wiki/Difference_list
- https://en.wikibooks.org/wiki/Prolog/Difference_Lists
  - Difference list has constant-time append.
    Ordinary list has linear-time append.
- https://wiki.haskell.org/Difference_list
  - "Whether this kind of difference list is more efficient than another list representations depends on usage patterns."
- http://homepages.inf.ed.ac.uk/pbrna/prologbook/node180.html
** <2018-10-20> How do we make sense of this counterintuitive module syntax?
- https://stackoverflow.com/questions/42399020/how-to-get-a-listing-of-a-specific-knowledge-base
** Discover the wonderful world of Prolog / logic programming / relational programming
*** Symbolic AI is the easiest AI approach.
- Connectionist AI (neural networks) excels at tasks that are difficult to describe in formal logic.
- Symbolic AI (Prolog) is much more understandable and predictable than connectionist AI.
  - Understanding connectionist AI requires probability, statistics, and real analysis.
- Why not both?
  2017 article "SLDR-DL: A Framework for SLD-Resolution with Deep Learning" https://arxiv.org/pdf/1705.02210.pdf?
*** Dreams
- offload/scale/formalize thinking/cognition
- transform reasoning into data entry
- brain prosthetics; cognitive prosthetics
- Leibniz, "Let us calculate!", calculus ratiocinator
  - https://en.wikipedia.org/wiki/Calculus_ratiocinator
  - https://publicdomainreview.org/2016/11/10/let-us-calculate-leibniz-llull-and-computational-imagination/
- probabilistic logic programming
- https://softwareengineering.stackexchange.com/questions/275680/the-dream-of-declarative-programming
** Making compilers
- https://www.reddit.com/r/ProgrammingLanguages/comments/9em9jf/future_directions_for_optimizing_compilers/
  - "Future Directions for Optimizing Compilers" https://arxiv.org/abs/1809.02161

"Universal-transpiler" may be similar to what we want.

- "Universal-transpiler"
  - https://github.com/jarble/transpiler
    - it also has links to similar projects
  - http://www.swi-prolog.org/pack/list?p=transpiler
** Declarative programming languages
[[http://www.cse.chalmers.se/~oloft/Papers/wm96/node2.html][Declarative Programming Languages]], functional logic programming, two ways it is done (narrowing and residuation);
definitional programming, GCLA language (separate definition and control)

- 1995, "Functional Logic Programming in GCLA", [[http://www.cse.chalmers.se/~oloft/Papers/wm95.pdf][pdf]]
** Speculative
*** Fast logic programming?
- https://www.reddit.com/r/ProgrammingLanguages/comments/9fgv3v/can_logic_programming_execute_as_fast_as/
  - https://www.info.ucl.ac.be/~pvr/Peter.thesis/Peter.thesis.html
- https://stackoverflow.com/questions/23711790/comparision-of-abstract-machines-for-execution-of-prolog
*** Lambda-prolog?

- lambda-prolog http://www.lix.polytechnique.fr/~dale/lProlog/
** Resources
*** For beginners
*** Not for beginners
- 1990 book "The craft of Prolog" by Richard A. O'Keefe
  - from the preface:
    "There are a lot of introductory Prolog books around.
    This is not one of them.
    Think of it as "second steps in Prolog".
    If you have already read one of the introductory books, if you have taken an introductory course on Prolog, if you have written one or two Prolog programs, and if you are wondering why it is still hard to writegood Prolog programs, this book is meant to help you.
    The purpose of the book is to show you how you can write Prolog programs that work, that don't take an unreasonable amount of time, and that are clean enough to show to your friends."
** What?
*** P# translates Prolog to C#.
https://pdfs.semanticscholar.org/12ec/568a6583d3d66b6821f28269f06937a9f2eb.pdf
*** "Real World Programming in SWI-Prolog"
http://www.pathwayslms.com/swipltuts/index.html
*** "Frequently Asked Questions for ##Prolog"
http://www.pathwayslms.com/swipltuts/student/
*** What are these trying to say?
- 1991 article "Logic Programming, Functional Programming, and Inductive Definitions" https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-205.pdf
  - "The unification of logic and functional programming, like the Holy Grail, is sought by countless people"
  - "More generally, we suggest that the traditional paradigm — logic programming as first-order logic — is seriously out of step with practice.
    We offer an alternative paradigm. We view the logic program as an /inductive definition/ of sets and relations."
  - "To justify the Closed World Assumption, we propose that logic programs should be viewed as inductive definitions, not as first-order theories.
    Some people refuse to abandon the dream of programming in first-order logic.
    But we have to ask whether this dream is possible — even whether it is desirable.
    The first-order paradigm does not deal adequately with negation in databases, and seems to be an unreliable guide in research on program correctness and language design.
    Inductive definitions are more fundamental than first-order logic, and perhaps easier to understand."
*** Books?
- 1995 book "Prolog Programming in Depth" http://www.lsv.fr/~reichert/Enseignement/2012/PPL/Prolog_Programming_In_Depth.pdf
  - 1.16 Styles of encoding knowledge, p. 28
    - parent, male, female vs. father, mother
    - "Which style is computationally more efficient depends on the kinds of queries to be answered."
    - "Unlike other knowledge representation languages, Prolog does not force the knowledge base builder to state information in a particular logical style.
      Information can be entered in whatever form is most convenient, and then appropriate rules can be added to retrieve the information in a different form."
    - "We could use a 'data-record' format to encode the family tree like [person(Name,Sex,Father,Mother)]"
      - "The only advantage of this style is that the multi-argument facts are often easy to generate from conventional databases,
        by simply printing out the data in a format that conforms to Prolog syntax."
  - 5.12 Grand Finale: Reading a Lotus Spreadsheet, p. 148
  - 5.13 Language and Metalanguage, p. 153
    - "A Prolog program can extend and modify the inference engine that controls program execution.
      Thus, the language can change itself in ways that go beyond superficial syntax."
      - Really? How?
  - 5.17 Intensional and Extensional Queries, p. 159
  - 5.19 Giving Meaning to Operators, p. 163
    - "How to make the ampersand mean 'and' in Prolog"
  - 5.20 Prolog in Prolog, p. 165
    - "Meta-interpreter for Prolog"
  - 5.21 Extending the inference engine, p. 167
    - biconditionals
  - 11 Defeasible Prolog, p. 347
    - 11.1 Nonmonotonic reasoning and Prolog, p. 347
      - "If our reasoning is monotonic, the set of conclusions we draw from the information we have only gets larger as we get more and more information.
        Once we reach a conclusion, no additional information will cause us to reject it.
        When our reasoning is nonmonotonic, we may reject an earlier conclusion on the basis of new information."
      - "Human reasoning is notoriously nonmonotonic. We make plans based on what we expect to happen,
        but we constantly revise our expectations, and our plans, as events unfold."
      - "The Prolog inference engine is nonmonotonic because of the way it handles negation."
      - Why is "defeasible" not spelled "defeatable"?
    - 11.2 New syntax for defeasible reasoning, p. 348
      - "Although Prolog can perform some kinds of nonmonotonic reasoning, Prolog rules are not defeasible."
      - "Some instances of defeasible reasoning cannot be reproduced in ordinary Prolog."
      - "What we need is a new way to represent defeasible rules and presumptions and
        an inference engine that knows how to use them. We also need a negation operator
        that is different from negation-as-failure so we can represent rules that tell us
        when something is positively not the case rather than just that we cannot /prove/ that it is the case.
        These negative rules are needed to tell us when we have an exception to a defeasible rule, but they are desirable in their own right as well."
        - The second sentence is too long.
    - (I haven't read it.)
** TODO <2018-11-30> Prolog needs static checking like Erlang Dialyzer.
SWI-Prolog has check library?

Is there a Prolog totality/determinism checker?

Prolog typechecking is vital to prevent stupid mistakes in a large knowledge base?

1997 inconclusive discussion "Prolog Type Checker"
https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/typing/types.html
