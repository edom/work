#+TITLE: Using Prolog
#+DATE: 2018-04-11 00:00 +0700
#+OPTIONS: ^:nil toc:nil
#+PERMALINK: /prolog.html
#+TOC: headlines 1
* Finding psychological security before going full Prolog
#+TOC: headlines 2 local
** <2018-11-30> This is a book in progress!
I don't know whether I will ever finish this.

By "See file X" I mean a file somewhere in [[https://github.com/edom/work][my Github repository]].

Who might you be?
How might this book serve you?
- a programmer used to C, C++, Java, PHP, Ruby, Python
- a programmer used to Lisp, Scheme, Haskell
- a Prolog believer
- a Prolog evangelist
- someone who used to write Prolog codes
- a dreamer who thinks machines should do more
- a researcher, theoretician, computer scientist, mathematician, logician, philosopher?
- (Who else might you be, why the hell are you here, and how should I write for you?)

We are wearing multiple hats:
- mathematician
- philosopher
- engineer

The goal of this book is to convince you that you should use Prolog to create your next system (what system? game? enterprise application? shell script?).

Ivan Bratko has a "Prolog programming for artificial intelligence" book.
I want a "Prolog programming for everything" book.
** Warning about the woes and blockers
I'm selling you Prolog here, but let me be honest:
Don't buy it if any of these year-2018 deal-breakers are an issue for you.
Prolog isn't ready for these use cases in 2018; I hope these will change.

<2018-12-09>
Somewhat fatal:
ISO Prolog open/4 has no way to open a file for writing without truncating it.
(How the hell did they overlook such a common use case?)
But some implementations have extensions to work around that:
- Prolog implementations that can open a file for both reading and writing:
  - <2018-12-09> Amzi! Prolog open/4 has "readwrite" mode[fn::https://www.amzi.com/manuals/amzi/pro/ref_io.htm]
- Prolog implementations that can open a file for writing without truncating it, but not for both reading and writing:
  - <2018-12-09> SWI-Prolog open/4 has "update" mode[fn::http://www.swi-prolog.org/pldoc/doc_for?object=open/4]
  - <2018-12-09> ECLiPSe Prolog open/4 has "update" mode[fn::http://eclipseclp.org/doc/bips/kernel/iostream/open-4.html]
- Prolog implementations that /cannot/ open a file for writing without truncating it:
  - <2018-12-09> GNU Prolog[fn::http://www.gprolog.org/manual/html_node/gprolog034.html#open%2F4]
  - <2018-12-09> SICStus Prolog[fn::https://sicstus.sics.se/sicstus/docs/4.2.1/html/sicstus/mpg_002dref_002dopen.html]
  - <2018-12-09> Ciao Prolog[fn::https://ciao-lang.org/docs/1.14/13646/CiaoDE-1.14.2-13646_ciao.html/streams_basic.html#open/4]

<2018-11-30>
No arrays.

<2018-11-30>
SWI-Prolog is honest:
"The main weakness of Prolog are algorithms that require destructive assignment,
intensive array processing or bare-metal performance for e.g., processing pixels."
 [fn::http://www.swi-prolog.org/FAQ/PrologLAMP.txt]

<2018-10-24>
There is no standard date/time/calendar library?
There may be one?
I'm still looking.
library(julian)?
- Java 8 has "java.util.time".
  Previous Java versions can use "Joda Time".
- Haskell has the "time" package ("Data.Time" module).
*** <2018-11-22> Prolog weakness: binary array and low-level input-output
Prolog doesn't have arrays.

Workaround: we can fake an array:
Allocate with functor(T,F,N), read with arg(N,T,A), and write with nb_setarg(N,T,A).

Prolog doesn't have unsigned integers.

How fast is this?

This requires that the implementation doesn't limit functor arguments.
** If you need to be hyped up
(You can skip this.)

<2018-11-30>
Don't take this too seriously.
I'm on a honeymoon with Prolog.

Prolog is a /mind augmentation language/.
Prolog is a mental prosthesis.
With prosthetic arms, I can beat you in arm wrestling.
With prosthetic legs, I can beat you in running.
With prosthetic minds, I can beat you in thinking.
If logic is the language of thought, then Prolog is the closest thing we have to mind dump.
Offload your reasoning to computers.
As Leibniz said, "Let us calculate!"

You love Lisp macros?
Prolog has term_expansion/2, goal_expansion/2, op/2, and the infix operators that you have been dreaming of!

You love Haskell type system?
In Prolog you can write your own type systems!

You love C++ operator overloading?
In Prolog you can define your own operators with their precedences and associativities!

You want to beat/outdo/one-up your coworkers?
Prolog is perfect for that!
Unless you're low-level-programming,
Prolog is the secret weapon that multiplies your productivity by 20 compared to a low-level programming language such as C, C++, Java.
When you build your home, you don't build your own bricks.

Your coworkers are beating you with Prolog?
Well, what the hell are you waiting for?
Learn Prolog now, or lose your job and die in oblivion!

"Prolog is a convenient language in which to express the semantics of other languages."[fn::https://www3.hhu.de/stups/prob/index.php/Why_Prolog%3F]

Why logic programming?
Because logic is the internal language of thought.
It is the highest level programming possible, until we invent telepathy.
Don't we dream about programming directly in the language of thought?

A paragraph from Kowalski 1974 \cite{kowalski1974predicate}:
#+BEGIN_QUOTE
As a programming language, predicate logic is the only language which is entirely user-oriented.
It differs from existing high-level languages in that it possesses no features which are meaningful in only machine-level terms.
It differs from functional languages like LISP, based on the \(\lambda\)-calculus, in that it derives from the normative study of human logic,
rather than from investigations into the mathematical logic of functions."\cite{kowalski1974predicate}
#+END_QUOTE

"Prolog is an excellent programming contest language:
Prolog is close enough to the ultimate specification language (logic), so that the distance between problem and solution is not too big."
\cite{demoen2005first}
** Not sure yet? Try Prolog with minimal investment.
If you're not sure yet, I suggest that you
read [[https://www.metalevel.at/prolog][Markus Triska's book "The power of Prolog"]]
while doodling some code on [[http://pengines.swi-prolog.org/apps/swish/index.html][SWISH online Prolog interpreter]].
** Comparing Prolog implementations?
I use SWI-Prolog because it's what I used in university, and because of this [[http://www.swi-prolog.org/features.html][SWI-Prolog sales pitch]].

This book assumes that the reader uses SWI-Prolog 7.6.4.

There are many Prolog implementations.
Some companies have their own Prolog implementations.

GNU Prolog is "a native-code compiler which produces standalone executables which donâ€™t rely on any byte-code emulator or meta-interpreter."
 [fn::https://www.semanticscholar.org/paper/On-the-Implementation-of-GNU-Prolog-Diaz-Abreu/2c4f697f96202f988602e88c49625a862a4ce696]
But as of 2019 GNU Prolog does not have a module system.

See also:
- https://en.wikipedia.org/wiki/Comparison_of_Prolog_implementations
- Comparison between SWI Prolog, YAP, GNU Prolog http://www.david-reitter.com/compling/prolog/compare.html

Prolog in JavaScript/browser
http://tau-prolog.org/

Questions that we should answer, for each implementation:
- Who uses it?
  How many people use it?
- What is its strengths?
- What is its weaknesses?
- Where is its source code?
- Does the project seem alive?
- Where is the community?
** <2019-03-26> Is there any Prolog IDE?
SWISH?
 [fn::http://www.swi-prolog.org/IDE.html]
 [fn::https://stackoverflow.com/questions/5277263/good-ide-to-get-started-with-prolog]

I use VSCode.
There may be other IDEs, but I don't know which one is supported.
It's one of the woes of using an unpopular language: Few people are working on the tools.

<2018-12-10> Smart editors are dangerous! Arbitrary code execution!

I use the VSCode extension VSC-Prolog, but I disabled its linter after I realize that it may execute arbitrary code.
I only use its syntax highlighting and documentation popup feature.
Fortunately the plugin is still very useful without the linter.

Imagine this file:
#+BEGIN_EXAMPLE
% doom.pro
:- shell('touch ~/doomed').
#+END_EXAMPLE

I loaded that file into VSCode, and a file named =doomed= appeared in my home directory.
I'd be really doomed if someone replaced that command with 'rm -rf /'.

Perhaps we should make a whitelist of allowed directives?

Vim suffers the same thing with its modelines. I think it's now disabled by default?

However, this doesn't affect you if you only open what you write yourself, and never open a criminal's Prolog code.
But this is an accident waiting to happen!

I reported this:
- https://github.com/arthwang/vsc-prolog/issues/31

I hear some things about Eclipse PDT.
** Prolog community
Questions, answers, discussions, news:
- SWI-Prolog Discourse Group[fn::https://swi-prolog.discourse.group].
  <2019-04-03> The old SWI-Prolog Google Groups[fn::https://groups.google.com/forum/#!forum/swi-prolog] has been deprecated.
  They are moving.
- IRC requires login.
  Where is the chat log?
- comp.lang.prolog https://groups.google.com/forum/#!forum/comp.lang.prolog
- StackOverflow tag swi-prolog https://stackoverflow.com/questions/tagged/swi-prolog
- https://www.reddit.com/r/prolog/

What:
- SWI-Prolog roadmap https://github.com/SWI-Prolog/roadmap
- http://www.swi-prolog.org/Links.html

Unclear links:
- http://prolog-commons.org

"Conference on the practical application of Prolog":
When was it last held?
It seems no more.

Twitter LOPSTR:
Logic Based Program Synthesis and Transformation: 13th International...

Who uses Prolog?

Gerrit has prolog?
https://gerrit-review.googlesource.com/Documentation/prolog-cookbook.html

I hate "awesome" lists like this "awesome Prolog"[fn::https://github.com/klauscfhq/awesome-prolog/blob/master/readme.md]
list because such lists do not explain /why/ something is awesome.
** Recommended learning sequence
- Know how to read Prolog programs.
  - Know basic Prolog syntax.
    - Know what a Prolog /term/ is.
    - Know what a Prolog /clause/ is.
  - Know how to read/interpret the meaning of a Prolog clause as an English sentence.
- Know the operational semantics of Prolog.
- Know some declarative semantics of Prolog.
- Come up with alternative declarative semantics for Prolog programs.
* Set-up and workflow
We assume that you have installed SWI-Prolog 7.6.4.
** Things to do in each OS reinstall
This has to be at least once.
This may have to be redone every time we replace our operating system, such as when replacing Ubuntu 14.04 with Debian 9.
*** <2018-10-20> Installing SWI-Prolog 7.6.4 on Ubuntu 14.04
If you are using Ubuntu 14.04, follow my instructions below.
If your operating system has packaged SWI-Prolog 7.6.4 or newer, use it.
Otherwise, follow the [[http://www.swi-prolog.org/Download.html][official instructions]] and find SWI-Prolog 7.6.4.

The following guide is for installing SWI-Prolog 7.6.4 on Ubuntu 14.04.

Uninstall existing SWI-Prolog installations.
The version packaged with Ubuntu 14.04 is too old (6.6.4).
SWI-Prolog 7 introduces a new double-quoted string type.

Install dependencies.
I take this from the [[http://www.swi-prolog.org/build/Debian.html][Debian build instructions]] with these changes.
I replace =libunwind-dev= with =libunwind8-dev=.
I remove =openjdk-8-jdk= and =junit=.
I add =libreadline-dev=.
#+BEGIN_EXAMPLE
sudo apt-get install \
        build-essential autoconf curl chrpath pkg-config \
        ncurses-dev libreadline-dev libedit-dev \
        libunwind8-dev \
        libgmp-dev \
        libssl-dev \
        unixodbc-dev \
        zlib1g-dev libarchive-dev \
        libossp-uuid-dev \
        libxext-dev libice-dev libjpeg-dev libxinerama-dev libxft-dev \
        libxpm-dev libxt-dev \
        libdb-dev \
        libpcre3-dev \
        libyaml-dev \
        libreadline-dev
#+END_EXAMPLE

That doesn't include the documentation dependencies because they are too big.
Just read the documentation online.

After apt-get finishes, for security (avoiding sudo cache), close that terminal, and open a new one.

Download the [[http://www.swi-prolog.org/download/stable][source]].

Check the checksum using sha256sum.

=cp -p build.templ build=

=mkdir -p $HOME/.local=

Edit =build= script.
Set =PREFIX= to =$HOME/.local=.
Uncomment the =--link= option in =EXTRACFG= variable.

Run =./build=.
It should take a few minutes (about 5 minutes on my 4-core 8-GB-RAM machine).

Ensure that =$HOME/.local/bin= is in your =PATH=.
For example, I have this line somewhere near the end of my =~/.bashrc= file:
#+BEGIN_EXAMPLE
export PATH="$PATH:$HOME/.local/bin"
#+END_EXAMPLE

If you edit your bashrc, close your terminal and open a new one.
Then enter =swipl --version= in the new terminal.
The program should show something like this:
#+BEGIN_EXAMPLE
SWI-Prolog version 7.6.4 for x86_64-linux
#+END_EXAMPLE

If you don't want to edit your bashrc, you can run swipl by its full path =~/.local/bin/swipl=.
*** Enabling readline
We want readline for history (Ctrl+R, Ctrl+S) and completion (Tab, Ctrl+P/Up, Ctrl+N/Down).

To keep the entire codebase under BSD license,
SWI-Prolog doesn't enable the GPL-licensed GNU readline by default.
But you can tell SWI-Prolog to use readline.
First, install your distro's libreadline-dev package.
Then, put this line in your =~/.swiplrc=:
#+BEGIN_EXAMPLE
:- set_prolog_flag(readline, readline).
#+END_EXAMPLE

Related: [[https://github.com/SWI-Prolog/issues/issues/72][GitHub issue #72]]: "how to build with GNU readline on linux".

** Workflow
*** Starting the interpreter and the documentation server
I start SWI-Prolog with this command line:
#+BEGIN_EXAMPLE
swipl --pldoc=DocPort -l PrologFile
#+END_EXAMPLE

I use 4002 for DocPort.

I open [[http://localhost:4002/pldoc/]] in my browser.
*** Thinking and editing
I edit some Prolog source files in Visual Studio Code with vim key bindings
because I often need to duplicate a line when adding a new clause.

I add statements or comments.

I think a lot about names, representations, and relations.

To edit the source of a thing in PceEmacs, we have several options:
- click the "Edit file" or "Edit predicate" button in pldoc server, or
- query =edit(Name)= or =edit(Name/Arity)= in the interpreter.
*** Rebuilding
To see the updated documentation,
I click "Make & Reload" button in my pldoc website, if I haven't done so.
If I have clicked that button, I simply refresh my browser with F5 or Ctrl+R.

To test the program, I query =make.= in the interactive prompt, and I enter some queries.

Warnings are errors.
If there is a warning, I go back to editing.
"Singleton variables" most likely mean there's a typo.
*** Trying and manual testing
Important: /Prolog source file and Prolog query prompt have different syntax./
A Prolog source file contains /statements/.
The Prolog interpreter accepts /queries/.
Pasting a file into the interpreter does /not/ load the file;
this is contrary to Lisp/Python/Ruby interpreters.

The prompt =?-= means that the interpreter is expecting a /query/.
However, we can enter temporary statements:
- Type the query =[user].=.
  The prompt changes to =|:=.
  We're now at the statement prompt.
  (The syntax =:- [foo].= is shorthand for =:- consult(foo).= which is documented in [[http://www.swi-prolog.org/pldoc/man?predicate=consult/1][consult/1]].)
- Enter several lines of statements.
- End with a new line and Control+D.
  We're now back at the query prompt.

Those temporary statements disappear when the interpreter quits.

Usually, after trying my changes, I go back to thinking and editing.
*** Seeing source codes and finding definitions
To show the canonical representation (properly-parenthesized tree form) of a term, query =write_canonical(Term)=.

To see the source code of a predicate, query =edit(Name)= or =edit(Name/Arity)= or =listing(Module:Name)= or =listing(Name)=.
We can see the source code of libraries.
We can easily find where things are defined.
*** Troubleshooting: tracing and spying
Having to use the tracer means I have failed to design unsurprising programs.
It means that my past self have failed to communicate to my future self.

Sometimes I query debug/0 to disable optimizations so that errors have full stack trace.
Sometimes I need to restart the interpreter and query debug/0 before running my development web server.
See also nodebug/0.

I start tracing a goal with the query =trace, Goal.=
In the tracer prompt:
- =a= aborts (calls abort/0; goes back to toplevel interpreter prompt)
- =c= creeps ("step into" in modern debugger parlance)
- =s= skips ("step over" in modern debugger parlance)
- =l= leaps ("run" in modern debugger parlance)
- Type =/f= in the tracer prompt to run to the next failure.

I stop tracing by notrace/0.

TODO spy/1, tspy/1

trace/0, gtrace/0, notrace/0

These resources say something about fixing programming errors:
- https://www.cs.ucsb.edu/~kyledewey/cs162w15/debugging_prolog.html
- http://www.swi-prolog.org/pldoc/man?section=debugoverview
- https://www.metalevel.at/prolog/testing
- https://www.metalevel.at/prolog/debugging
*** Committing to a Git repository
I commit my work to Git repository with Emacs Magit or git-gui.
I sanity-check the tree with =gitk --all=.
I push my work to my GitHub work repository.
* Prolog as database programming language
** Reading Prolog programs, and a crash course to logic
What is the meaning/interpretation of a Prolog program?

A /clause/ has the shape =Head :- Body=.

Usually we begin with genealogy like Abraham's[fn::https://en.wikipedia.org/wiki/Abraham%27s_family_tree].
Family tree is actually not a tree but a directed graph:
Families sometimes inbreed.

The words "father" and "mother" are to be interpreted as verbs here.
#+BEGIN_EXAMPLE
father(abraham, isaac).
father(abraham, ishmael).
father(isaac, esau).
father(isaac, jacob).

mother(sarah, isaac).
mother(hagar, ishmael).
mother(rebecca, esau).
mother(rebecca, jacob).

parent(A, B) :- father(A,B) ; mother(A,B).
#+END_EXAMPLE
** Prolog and ontology
Writing a Prolog knowledge base is an exercise in ontology (a branch of philosophy, that studies beings and relationships).
We ask these all the time:
- What exist?
- How do they relate?
- How do we model all those entities and relationships in Prolog for not-too-slow computation?
** "Pure" relation built from impure parts
We can define a truly relational plus/3 that works for all mode combinations for natural numbers, but the code seems too much and illogical.

#+BEGIN_EXAMPLE
nat(A) :- integer(A), A >= 0.

plus(A, B, C) :- nat(A), nat(B), nat(C), !, C =:= A + B.
plus(A, B, C) :- nat(A), nat(B), !, C is A+B.
plus(A, B, C) :- nat(A), nat(C), !, B is C-A.
plus(A, B, C) :- nat(B), nat(C), !, A is C-B.
plus(A, B, C) :- nat(A), !, between(0, inf, C), plus(A, B, C).
plus(A, B, C) :- nat(B), !, between(0, inf, C), plus(A, B, C).
plus(A, B, C) :- nat(C), !, between(0, C, A), plus(A, B, C).
plus(A, B, C) :- between(0, inf, C), plus(A, B, C).
#+END_EXAMPLE

We can write that shorter in miniKanren which uses iterative-deepening search?

** Knowledge representation; designing predicates; naming is hard
One possible mapping is:
- a noun maps to a term
- a verb maps to a predicate

Come to think of it, a transitive verb indeed denotes a relation between two nouns.

The name of a predicate is less important than its mapping and its meaning.
#+BEGIN_EXAMPLE
father(abraham, isaac).
beget(abraham, issac).
papa(abraham, issac).
spawn(abraham, issac).
mystery_predicate(abraham, issac).
#+END_EXAMPLE

"A bird eats an apple" means \( \exists x \exists y ( bird(x) \wedge apple(y) \wedge eat(x,y) ) \).

The name of a relation should describe the relationship.

If we intend that there is only one relation between A and B that makes sense,
then we may name that relation A_B.
But:
- What if A or B contains underscores?
- Why do we prefer =father_child= to =beget= or =sire=?

is_thing(A).

A procedure's name should begin with a verb.

Order the parameters from the most likely to be bound.
If parameter A is more likely to be more bound than parameter B, then A should come before B.
Example: Write list_length/2 instead of length_list/2.
Unfortunately not everyone follows this convention.
** Knowledge representation and software specification
*** Their relationships
- 2010, "Functional-Logic Programming Lecture Notes", Harold Boley, slides, [[http://www.cs.unb.ca/~boley/FLP/cs6905FLP.pdf][pdf]]
  - Knowledge representation in AI roughly corresponds to software specification in software engineering.
  - Declarative programs can be thought as executable specifications.
  - Invertibility principle (slide 36)
  - Nesting/conjunction principle (slide 46)
  - Unification principle (slide 50)
  - Amalgamation/integration principle (slide 55)
  - That's a long deck: 270 slides.
*** Executable specification?
- lightweight executable mathematics https://www.cl.cam.ac.uk/~pes20/lem/
** Total relational programming? Relational programs that can be proven to terminate?
A total relation is a relation that is defined for every element in its domain.

If there is total functional programming, then there should be total relational programming.

It is too easy to write a Prolog program that doesn't terminate.
** The meaning of a pure Prolog predicate
The meaning of a predicate is the set of all ground terms that satisfy that predicate.
Formally, the meaning of the predicate \(p\) is the set \( \SetBuilder{x}{p(x)} \).
Such set is called the /extension/[fn::https://en.wikipedia.org/wiki/Extension_(predicate_logic)] of the predicate.

In this example, what is the meaning of t/2 supposed to be?
Declaratively, the query =?- t(A,B)= means the finite set ={(1,1)}=, and thus the query should terminate.
But with SLD-resolution operational semantics, the query does not terminate.
#+BEGIN_EXAMPLE
e(1,1).

t(A,B) :- e(A,M), t(M,B).
#+END_EXAMPLE
* Prolog as logic programming language
** Multi-directional predicates
A predicate has several uses: iteration, searching, testing, and other computation.
A predicate can be used both to enumerate/iterate a finite set, to search for a satisfier, and to test membership.
#+BEGIN_EXAMPLE
person(alice).
person(bob).

?- person(charlie). % test membership
?- once(person(A)). % satisfy
?- person(A), !. % satisfy
?- person(A). % iterate
#+END_EXAMPLE

A predicate can be used both to enumerate some infinite sets and to test membership.
The programmer is reponsible to ensure that the recursion terminates.
#+BEGIN_EXAMPLE
nat(z).
nat(s(A)) :- nat(A).
#+END_EXAMPLE

#+BEGIN_EXAMPLE
succ(A, s(A)).

succ(A, s(A)) :- nat(A).
#+END_EXAMPLE

For non-pure Prolog programs, we have to do some repetition if we want a multi-directional relation.
#+BEGIN_EXAMPLE
succ(A, B) :- integer(A), !, B is A+1.
succ(A, B) :- integer(B), !, A is B-1.
succ(A, B) :- !, type_error(succ, succ(A,B)).
#+END_EXAMPLE

But that can be done more elegantly with /constraint logic programming/.
#+BEGIN_EXAMPLE
succ(A, B) :- A + 1 #= B.
#+END_EXAMPLE
** Functional (deterministic) relation
#+BEGIN_EXAMPLE
f(In1, Out1) :- Guard1, !, Body1.
...
f(InN, OutN) :- GuardN, !, BodyN.
f(In, _) :- !, type_error(Type, In).
#+END_EXAMPLE
** How to read declarative Prolog programs
A /Horn clause/ =A :- B= means "to prove A, prove B".
The left-arrow =:-= can be read as "if".

#+BEGIN_EXAMPLE
wet :- rain.
wet :- sprinkle.

% The same.

wet :- rain ; sprinkle.
#+END_EXAMPLE

The conjunction =A,B= means prove A /and then/ prove B.
Prolog proves them in sequence.

Example:
The fire triangle[fn::https://en.wikipedia.org/wiki/Fire_triangle]:
#+BEGIN_EXAMPLE
% A line comment begins with a percent sign.

fire :- oxygen, heat, fuel.

oxygen.
heat.
#+END_EXAMPLE

Prolog complains about undefined predicate fuel/0.

An alternative in which Prolog does not complain about undefined predicates:
#+BEGIN_EXAMPLE
known(oxygen).
known(heat).
known(fire) :- known((oxygen,heat,fuel)).
known((A,B)) :- known(A), known(B).
#+END_EXAMPLE

We have just defined a small /world/, a small /ontology/.
(Is this too fast-paced for beginners?)

The disjunction =A;B= means prove A /or/ prove B.
If A fails, Prolog backtracks and tries to prove B.

Non-variables in clause head abbreviate unification.
For example, =p(a,b) :- Q= abbreviates =p(A,B) :- A=a, B=b, Q=.

=A :- B= is pure iff all reordering of the phrases of B doesn't change the result?

=\+A= means "fail to prove A".
It is not classical-logical negation.

Every variable is implicitly universally quantified.

The prompt =?- Q= means we ask Prolog to prove =Q=.

Perhaps elucidating
https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics

We often define a set \(A\) with the set-builder notation \( \SetBuilder{x}{\phi_A(x)} \).
We should not conflate a set \(A\) and its membership-testing predicate \(\phi_A\).

A set can be thought as all the ground terms that satisfy a predicate.
#+BEGIN_EXAMPLE
% person ~ {joe}
person(joe).

% natural ~ {0, 1, 2, ...}
natural(N) :- integer(N), N >= 0.
#+END_EXAMPLE
** Epistemic interpretation of Prolog programs: Failure as ignorance
Sometimes a Prolog program should be interpreted epistemically,
in which Prolog's /fail/ is treated as /unknown/ instead of /false/.
In this interpretation:
- Succeeding to prove a goal G means that we know that G is true.
- Failing to prove a goal G means that we do not know anything about G.

There are two negations: There is a difference between not/1 and \+/1.
In the epistemic interpretation, "\+" should be read as "unknown".

=\+G= means we do not know G.

Succeeding to prove not(G) means that we know that G is false.
#+BEGIN_EXAMPLE
:- multifile not/1.
#+END_EXAMPLE

We waive the law of excluded middle.
In our Prolog program it does not hold that G ; not(G).

Suppose is_big(john).
If is_big(X) fails, it simply means that we don't know whether X is big.

Suppose that is_big(john,true) means we know that John is big.
And is_big(john,false) means we know that John is not big.
If is_big(john,_) fails, then we don't know whether John is big or not.
** Naming the parts of a list: head, tail, and butt
- "head" is the first element
- "tail" is everything but the head
- "butt" is the last element
** Defining your own operators
- =:- op(Precedence, Type, Name)=
* Prolog as procedural programming language
Some ugly things are unfortunately necessary.
There are always some dirty jobs in real-world programming.
Example dirty jobs are input-output and error handling.
** The meanings of a Horn clause
A Horn clause in Prolog looks like =A :- B=.

A Horn clause can be thought of in several ways.

The operational meaning of =A :- B1, ..., Bn= is that calling the procedure A causes B1, ..., Bn to be called in that order.
This is the actual meaning of Prolog programs.
All other meanings are useful fantasies.

The classical-logic reading of =A :- B= is \(A \leftarrow B\), that is, "A is true if B is true" or "A is implied by B".

The proof-theoretic reading of =A :- B= is "to prove \(A\), it is enough to prove \(B\)".

The search-tree reading of =A :- B1, ..., Bn= is that the tree node A has the children B1, ..., Bn.

These multiple readings are confusing.
For example, the classical-logic reading implies that querying =a= against the following knowledge base should succeed because in classical logic \( A \leftarrow (B \wedge A) \equiv A \leftarrow B \),
but the query =a= actually does not terminate.
#+BEGIN_EXAMPLE
a :- b, a.
b.
#+END_EXAMPLE
In classical logic but not in Prolog,
that knowledge base is equivalent to this:
#+BEGIN_EXAMPLE
a :- b.
b.
#+END_EXAMPLE

Enhancing the declarativeness of Prolog requires /memoization/.

What is the relationship between logic programming, relational programming, logic, Horn clauses, theorem proving, searching, and backtracking?

If each phrase is deterministic (always succeeds exactly once and never fails),
then Prolog becomes a procedural programming language with assign-once variables and unification.
** Prolog operational semantics
*** Swapped phrases, depth-first, breadth-first
In this example, there is only a small syntactic difference between =dfs= and =bfs= (it's just flipped order).
Which one exploits tail call optimization (last call optimization)?
#+BEGIN_SRC prolog
bit(0).
bit(1).

dfs([]).
dfs([H|T]) :- bit(H), dfs(T).

bfs([]).
bfs([H|T]) :- bfs(T), bit(H).
#+END_SRC
*** Understanding depth-first search, backtracking, choice points, performance, and cuts
Save this knowledge base into a file, and load it into Prolog.
#+BEGIN_SRC prolog
a(0).
a(1).

b(0).
b(1).
#+END_SRC

Run the query =a(A), b(B).= and press =;= until Prolog fails.

This is what Prolog finds (we remove the newlines to make it more readable):
#+BEGIN_EXAMPLE
A = B, B = 0 ;
A = 0, B = 1 ;
A = 1, B = 0 ;
A = B, B = 1.
#+END_eXAMPLE

This is the search space (search tree) of that query.
#+BEGIN_EXAMPLE
       ?- a(A), b(B).
      /              \
    A = 0           A = 1
   /     \         /     \
B = 0   B = 1   B = 0   B = 1
#+END_EXAMPLE

Prolog traverses that tree in depth-first order as follows:
#+BEGIN_EXAMPLE
- ?- a(A), b(B).
  - A = 0
    - B = 0
    - B = 1
  - A = 1
    - B = 0
    - B = 1
#+END_EXAMPLE

The important things to infer from this experiment are:
- Prolog repeats the work on =b= as many times as the number of ways of satisfying =a=.
  If =a= can be satisfied in N ways, and satisfying =b= is a lot of work,
  then Prolog may do that work N times,
  although the work produces the same result.
- Everything to the right of an infinite branch will never be visited.

What is a choice point?

A cut makes =a(A), b(B)= and =b(B), a(A)= return different results.

How far does a cut cut?

"The craft of Prolog" defines three kinds of cuts: red, green, and blue.
- A red cut destroys the logical meaning of a program.
  Green and blue cuts don't.
*** Prolog is a depth-first brute-forcer
But you can emulate other search algorithms too.
**** Non-termination pitfalls, and how to generate terms correctly
Sometimes we forget that Prolog, on failure, backtracks (retries), not stops.

Sometimes we focus too much on the logical reading and neglect the procedural reading.

For example, suppose that you want to generate all lists whose length doesn't exceed 2.

The following is a mathematically correct statement about that fact,
but it doesn't work in Prolog.
It has correct logical reading, but incorrect procedural reading.
If you keep pressing =;=, this will fail to terminate.
#+BEGIN_SRC prolog
?- length(A, LA), LA =< 2.
#+END_SRC

The correct way to do that is to use =between/3= (inclusive):
#+BEGIN_SRC prolog
?- between(0, 2, LA), length(A, LA).
#+END_SRC

We can also use the =clpfd= library:
#+BEGIN_SRC prolog
:- use_module(library(clpfd)).

?- LA in 0..2, indomain(LA), length(A, LA).
#+END_SRC

We shouldn't have to resort to cuts:
#+BEGIN_SRC prolog
% Don't do this.
?- length(A, LA), (LA =< 2 -> true; !, fail).
#+END_SRC

See also:
- https://www.metalevel.at/prolog/nontermination
  - "[Non-termination is] common among beginners, and often lead them to perceive Prolog as 'slow', when in fact their program does not terminate /at all/."

** Cuts
- slide 5-28, pitfalls in implementing abs with cut http://users.informatik.uni-halle.de/~brass/lp06/c5_propr.pdf
** Speeding things up
The first thing to do is to get an unbiased profiler.

(Is SWI-Prolog profiler unbiased?)

Profiling: finding where your program spends time; finding where it is slow; diagnosing slowness

To run your =Goal= with profiling, simply query =profile(Goal)=.

Profiling couldn't be any simpler than this!
** Functional/expression style sometimes beats relational/unification style
#+BEGIN_EXAMPLE
-- Functional/expression style
g (f0 x0) (f1 x1) (f2 x2)

% Relational/unification style
f0(X0, Y0), f1(X1, Y1), f2(X2, Y2), g(Y0, Y1, Y2, Z).
#+END_EXAMPLE
Example where functional style wins:
- string formatting
- number crunching

If backtracking isn't involved, functional style wins (is more concise than relational style).

If computation is reversible, relational style wins (half the amount of code of functional style).

We should use both styles depending on circumstances.

We can define a functional/expression/applicative/evaluative sublanguage in Prolog, roughly like this:

#+BEGIN_SRC prolog
eval((A = B), Val) :- A = B, eval(B, Val), !.
eval(F, Val) :- callable(F), call(F, Val), !. % lots of hand-waving here
% etc.
#+END_SRC

Haskell is weak against the AST decoration problem.
Dynamic languages (Scheme, JavaScript, Prolog) / gradual-typed languages (TypeScript) beat static languages (Haskell) on the AST decoration problem.
How about Ocaml polymorphic variants?

Should we move from Prolog to Scheme/miniKanren or Mercury?
** Operators complicate parsing a Prolog source code
** Zero-arity compound term
SWI-Prolog extension compound_name_arity/3 vs ISO standard functor/3.[fn::http://www.swi-prolog.org/pldoc/man?section=ext-compound-zero]

- A function symbol with arity 2 looks like f(x,y).
- A function symbol with arity 1 looks like f(x).
- A function symbol with arity 0 should look like f().

Thus, indeed, SWI-Prolog's extension is the logical way,
but unfortunately we are stuck for historical reasons.
This makes sense if we are coming from mathematics,
in which it is common to conflate constants and 0-ary function symbols.
The formal logic literature conflates f() and f.

Problem arises when we want to distinguish between the x that is a variable reference and the x() that is a procedure call.
We can introduce additional abstract syntax to wrap and disambiguate them: var(x) and call(x,[]).

It is embarrassing that we have known zero for at least 2,000 years and yet we still have problems with zero.
** Some Prolog negation tricks?
Prolog =\+= can be used to limit the scope of unification, although not the scope of the variable itself.
This exploits the fact that throw/1 does not backtrack in the way fail/0 does.

When using Prolog procedurally, we often want throw/1 instead of fail/0.

It makes more sense to design a procedural DSL on Prolog than to use Prolog itself procedurally.
** The procedural-provability-logic interpretation of Prolog Horn clauses
=p :- q, r= can be interpreted as "to prove p, first prove q, and then prove r".
*** Problem: Horn clauses and biimplications
Classical propositional logic formula \( a \iff b \) (which is equivalent to \((a \to b) \wedge (b \to a)\)) does /not/ translate to this Prolog program:
#+BEGIN_EXAMPLE
a :- b.
b :- a.
#+END_EXAMPLE
Querying =?- a= does not terminate.

This terminates:
#+BEGIN_EXAMPLE
% H is the hypothesis bag.

a(H) :- member(a,H).
a(H) :- \+ member(a,H), b(H).

b(H) :- member(b,H).
b(H) :- \+ member(b,H), a(H).
#+END_EXAMPLE
** Purifying Prolog?
- assert/2 can be replaced with two parameters (state and next-state).
** Error handling and logging
*** Fail, throw, stack traces
Two options: throw or fail.

If backtracking doesn't make sense, then throw, don't fail.

#+BEGIN_EXAMPLE
person(joe).
pair_first_second(pair(A,_), A, B).
#+END_EXAMPLE

Should =person(1)= fail or throw?
Should =pair_first_second(foo)= fail or throw?

Fail means try the next alternative.

If you want throw/1 with stack trace,
you must write it like =throw(error(Something, _))=.

A /function/ should always throw and not fail, when an argument has a wrong type.

#+BEGIN_EXAMPLE
negate(A,B) :- integer(A), !, B is -A.
negate(A,B) :- integer(B), !, A is -B.
negate(A,B) :- throw(error(negate(A,B),_)).
#+END_EXAMPLE

- https://wiki.colby.edu/display/~amvartan/Exception+and+Error+Handling+in+Prolog
- https://stackoverflow.com/questions/32968148/why-throw-an-exception-in-prolog-instead-a-simple-fail
*** Structured logging
This is how we log messages in Prolog:
- Design a term that represents the /meaning/ of the message.
- Call =print_message(Kind,Message)= where Message is that term.
- Extend =prolog:message//1= to translate that term to string.

#+BEGIN_EXAMPLE
% Syntax:
prolog:message(Term) --> Lines.

% Example:
prolog:message(Term) -->
    [ 'The term is ~q.'-[Term] ],
    [ 'This is the second line in the message.' ].
#+END_EXAMPLE

Syntax description:
- 'Lines' is a list of 'Line's.
  - A 'Line' has this shape:
    - Format-Args: 'Format' and 'Args' are the same arguments accepted by format/2.
    - Terms of other shapes are converted to string.

The printed message is the concatenation of all 'Line's.

TODO:
- How do we log to file?
- How do we rotate log files?

References:
- [[http://www.pathwayslms.com/swipltuts/message/index.html][Anne Ogborn's "Printing Messages in SWI-Prolog"]]
- http://www.swi-prolog.org/pldoc/man?section=printmsg
- http://www.swi-prolog.org/pldoc/man?section=debug
- https://www.metalevel.at/prolog/business

Usability issues:
- Where is =prolog:message//1= documented?
  I found that by looking at others' source code.
  There does not seem to be any documentation, or if there is, then it is at the wrong place.
- Why do we require people to understand DCG rules before they can use the messaging system?
** States and dynamic predicates
Suppose that we want to write SQL connection pool.
We need state.
How do we write states in Prolog?
Dynamic predicates is one way of having states in Prolog.
The other is threading two extra state variables in each predicate that uses the state.
But this time purism seems to lose.
In the case of writing connection pools,
procedural programming seems to be the paradigm that produces the most concise and understandable code.

A stateless system is of limited use: They can't store data!
* Graphical-user-interface programming
** <2019-04-02> What are the options?
There are two options for doing GUI in SWI-Prolog:
- PCE: an abstraction layer like GNOME from the 1990s
- plgi[fn::http://www.swi-prolog.org/pack/list?p=plgi]: a SWI-Prolog pack containing bindings to Gtk

The future of XPCE is uncertain, but all the SWI-Prolog IDE components use it.[fn::https://github.com/SWI-Prolog/roadmap/issues/29]
It works; it's just not shiny.
Design sensibilities have changed due to new hardware.

PCE is an abstraction layer like GNOME.
It has an object system like GObject, a drawing-primitive system like Gdk, and GUI toolkit like Gtk.

PCE is written in C.

XPCE is PCE + SWI-Prolog bindings.

#+BEGIN_EXAMPLE
:- use_module(library(pce),[
    new/2
    , free/1
    , get/3
    , send/2
]).
:- use_module(library(pce_util),[
    send_list/3
]).
#+END_EXAMPLE

The predicates are:
- new(-Object, +Class) is det.
- free(+Object) is det.
- send(+Object, +MessageExp) is det.
- get(+Object, +MessageExp, -Result) is det.

A convenience predicate:
- send_list(+Object, +Slot, +Args) is det.

XPCE /object expression/ (message expression?) syntax is documented in XPCE User Guide section 10.2 ("Executable objects")[fn::http://www.swi-prolog.org/packages/xpce/UserGuide/exeobjects.html]:
- =@Name= global object
- =A ? B= obtainer ("getter" in Java parlance)

PCE is similar to C Gtk or Java Swing.
They are all object-oriented.
** Enlarge the fonts
XPCE was made in the 1990s when 800x600 screens were common.
In 2019, 1920x1080 screens are common.

The easiest way to set up the XPCE Defaults file is by PceEmacs.
#+BEGIN_EXAMPLE
?- emacs.
#+END_EXAMPLE

Edit > Editor preferences

Increment each number in "display.system_fonts" chain by 2 (thus replace 12 with 14, replace 13 with 15, and so on).

Save the file, exit PceEmacs, and restart the Prolog interpreter.
** Saving PCE/XPCE by porting it as much as possible to pure Prolog?
PCE/XPCE is surprisingly modern?
PCE =catch_all= is Ruby method_missing.
But perhaps this is not surprising because both PCE and Ruby take something from Smalltalk, directly or indirectly.

Need to be done:
- Write a shorter user guide.
  Write about the things that the user really needs to care about.
  People are impatient.
  Life is short.
- Integrate XPCE documentation system and PlDoc documentation system.
- Make manpce use one frame instead of many frames.
  Compare GIMP before single-window layout.

Nice to have?
- Rewrite the C parts in ISO Prolog.
- Build on GTK.

One problem is that PCE is not Prolog-only.
In principle, PCE may also be used with any host language, such as Lisp and C.
** Declarative GUI?
It is easy to model the /static/ structure of a GUI:
#+BEGIN_EXAMPLE
window(main).
textbox(a).
textbox(b).
textbox(c).
contain(main,a).
contain(main,b).
contain(main,c).
#+END_EXAMPLE

It is harder to model the /dynamic/ behavior of a GUI.
#+BEGIN_EXAMPLE
textbox_text(c,C) :-
    textbox_text(a,A),
    textbox_text(b,B),
    string_concat(A,B,C).
#+END_EXAMPLE

#+BEGIN_EXAMPLE
constraint(text(c) = text(a) + text(b)).
#+END_EXAMPLE

Logical reactive programming?

* Maintaining large knowledge bases
** What is software maintenance?
Software does not break down like machines.
It is the things around the software that change.
Hardware changes.
Laws change.
People change.
The world changes.
What was true when the software was made is no longer true.

But why do we change?
Other animals have been living just fine for millions of years without much change.
We change for fun, to avoid boredom.

It is fun to change things.
It is less fun to be affected by changes.

The key to maintainable software is to depend only on dependable things.
If A depend on B, then B should be more stable than A.
If a program uses a library, then the library should be more stable than the program.
If a library uses an operating system, then the operating system should be more stable than the library.

Stable dependencies principle[fn::http://wiki.c2.com/?StableDependenciesPrinciple]?

How to write a program that does not change?
It must capture the timeless essence of reality.
A bachelor is unmarried by definition, and that definition is unlikely to change.
** A suggested way to use Prolog for programming in the large?
Begin by defining an ontology or domain-specific language.
This is pure Prolog with declarative semantics.

Then specify a transformation or interpretation to reality.

Example:
A functional programming language:
#+BEGIN_EXAMPLE
%%  interpret(+Expression,-Value) is det.

interpret(write(A), Z) :- !,
    interpret(A, A0),
    write(A0),
    Z = unit.

interpret(A+B, Z) :- !,
    interpret(A, A0),
    interpret(B, B0),
    Z is A0 + B0.

interpret((A,B), Z) :- !,
    interpret(A, _),
    interpret(B, Z).

interpret(A, Z) :- number(A), !, Z = A.
interpret(A, Z) :- string(A), !, Z = A.
interpret(A, _) :- !, type_error(expression, A).
#+END_EXAMPLE

Always use explicit imports and exports.
Help =grep= help us.
** Disciplines for writing large maintainable Prolog knowledge bases
Some disciplines are required:
- Separate declarative and imperative codes.
- Avoid depending on module systems.
- Each declarative source file is a small /ontology/.
  Each imperative source file /merges/ some ontologies.
** Organizing and loading Prolog source files without name clashes
Prolog multifile predicates can be used for /dependency injection/.
Instead of importing a module, declare a multifile predicate and let the user link that predicate.

Prolog source files come in /two kinds/ depending on how they are loaded: /type-1/ files and /type-2/ (module-free) files.
In short, a type-2 file should not assume that the Prolog implementation has a module system, unless when defining meta-predicates.
The discipline is:
- A type-2 file should not contain any directives except include/1.
  Thus a type-2 file must not begin with module/2 directive, and must not use the use_module/[1,2] directive.
- A type-2 file should not contain hard-coded module references.
  A type-2 file should not contain any qualified M:P call where M is a hard-coded atom;
  it is fine if M is a variable.

There are several mostly incompatible ways to load a Prolog source file:
- include/1, only works as directive
- consult/1
- consult_unregistered/1, which is load_files/2 with register(false) option
- use_module/2
- load_files/2
- consult_unregistered_into_module/2, which is just load_files/2 with module/1 and register(false) options
- Logtalk, logtalk_load/1, logtalk_load/2

The function of the main file is to link the non-main files.
To maximize reusability and minimize name clash,
a non-main file must not contain any hard-coded module names:
Those files must not contain module/2 declarations and use_module/[1,2] directives.
** Component/module system, socket-plug metaphor
I need a component system for programming in the large.
Prolog module system is a building block, but Prolog modules by themselves are not enough.
Socket-and-plug metaphor fits nicely?
The name tells it all:
a socket is a female connector and a plug is a male connector,
and we connect plugs to sockets,
and Prolog should complain if it sees a socket that is connected not exactly once.

An input is a multifile predicate.

A pin is a Name/Arity term.

A plug exports symbols.

A socket imports symbols.

A module may have multiple plugs and sockets.

Pins are matched by NameArity.
The ordering of pins does not matter.

A Prolog module system is either /predicate-based/ or /atom-based/.
XSB is atom-based.
SWI is predicate-based.
GNU Prolog does not have a module system.

** Writing extensible knowledge bases
*** Multifile or parametrization-and-catamorphism?
#+BEGIN_EXAMPLE
:- multifile foo_ext/1.

foo(A) :- foo_ext(A).
#+END_EXAMPLE

Catamorphism:
#+BEGIN_EXAMPLE
foo(F,A) :- call(F,A).
#+END_EXAMPLE

Don't multifile if clause order matters.
Reloading changes clause order.
http://www.swi-prolog.org/FAQ/Multifile.html
** Production Prolog
"Production Prolog" by Michael Hendricks; Strange Loop 2014
https://www.youtube.com/watch?v=G_eYTctGZw8
- This mentions "Mercury's bisecting debugger"
- mavis library for optional type declarations
- julian library for dates
- time/1 for measuring how long a goal takes
- library(spawn)?
** Testing
An example of unit testing is in =test.pro=.

#+BEGIN_EXAMPLE
test(addition) :-
    1+2 =:= 3.

test(multiplication) :-
    2*3 =:= 6.

?- test_all.
#+END_EXAMPLE

What is this library for unit testing?[fn::[[http://www.swi-prolog.org/pldoc/doc_for?object=section(%27packages/plunit.html%27)]]]
** Why do we need predicates at all if we can do with one unary predicate?
#+BEGIN_EXAMPLE
:- op(600,xfy,:).
:- op(650,xfx,@).

invoke(father @ [abraham, isaac]).
invoke(father @ [abraham, ishmael]).
invoke(list_length @ [[], z]).
invoke(list_length @ [[_|A], N]) :-
    invoke(list_length @ [A,N0]),
    invoke(succ @ [N0,N]).
invoke(nat @ [z]).
invoke(nat @ [s(A)]) :- invoke(nat @ [A]).
invoke(succ @ [A, s(A)]) :- invoke(nat @ [A]).
#+END_EXAMPLE

We can even do module systems.

We can encode 1 module as 1 predicate.
#+BEGIN_EXAMPLE
module1(pred @ [Arg1, Arg2, ...]) ...
module2(pred @ [Arg1, Arg2, ...]) ...
#+END_EXAMPLE

We can encode all modules as 1 predicate.
We can have meta-predicates.
We can have variable-arity predicates.
#+BEGIN_EXAMPLE
invoke(module1:pred @ [Arg1, ...]) ...
invoke(module2(pred) @ [Arg1, ...]) ...
invoke(call @ [F|A]) :- invoke(F @ A).
#+END_EXAMPLE

We can do first-order logic with one predicate only and unlimited function symbols.
We can convert predicates into function symbols:
We can transform \( p_1(\vec{x}_1), \ldots, p_n(\vec{x}_n) \) to \( P(p_k, \vec{x}_k) \).
This is like writing the interpretation function inside the formal system itself.
This is still first-order logic.

Should =a:b@c= be interpreted as =(a:b)@c= (call a:b with arguments c) or =a:(b@c)= (call b with context a and arguments c)?

Abstract terms.
What if we write programs with only predicates and variables and no concrete terms?
Why should we?
Because it enables us to change the representation without changing the meaning of the program.
It is the same as abstract data types in other languages.

We can see an as atom as a singleton predicate, that is, a predicate that is satisfied by one thing only, that is the atom.
** Rethinking Prolog module systems
*** How do module systems arise?
We are merrily writing codes until our program grows big and we have difficulty finding things.
Then we feel that something has to be done.

We make module systems because we are humans with limited working memory.
Our only weapon against complexity is divide-and-conquer and hierarchical abstraction/categorization.
*** What
Each predicate has a name.

A /module/ is a set of predicates.

A /file/ also contains a set of predicates.

A module is the internal representation
File contains the external representation.
The analogy:
A module contains thoughts.
A file countains writings representing those thoughts.

If the relationship between a file and a module does not have to be 1:1,
then complications arise.

We assume 1:1 relationship between files and modules.

Problems:
- M:N mapping between files and modules
- Name clashes
- Module instantiation
- Imports and dependencies
- I want to make many languages and interpreters, and I don't want to prefix each predicate:
  I want to write N interpret predicates, I don't want to write 1 langN_interpret for each N.
- A clashy-named old predicate is used a lot.

#+BEGIN_EXAMPLE
interpret(Language, Context, Expression, Meaning).
#+END_EXAMPLE

Some solutions that come to mind:
- Load module using gensym/2 if not current_module/2.
  The loader generates the name of the module that the file is loaded to.
  module/2 is anti-pattern.
- name mangling like what C++ does on top of C; generated module names
- Pengines to separate the worlds?
- Logtalk

We want to state these facts:
- This file imports predicate P from file F,
  because a predicate in this file calls/uses/depends-on that predicate P defined in that file F.

We came up with the import/2 directive.

Prolog expansion has some problems.
 [fn::https://blog.logtalk.org/2011/03/a-more-sane-implementation-of-the-term-expansion-mechanism/]

Moura 2003 \cite{pmoura2003logtalk}: "The first time I felt the need for strong encapsulation features in Prolog was during my final year undergraduate project, in 1989."

This SWI-Prolog Google Groups discussion thread[fn::https://groups.google.com/forum/#!searchin/swi-prolog/clash$20module%7Csort:date/swi-prolog/f8LpJN8MYm0/uUYfUmN5AgAJ] is relevant.

Module is about namespacing.

We want to say that "The mypred/3 in file1 is the same as the yourpred/3 in file2."
*** Logtalk?
"You can even use [Logtalk] to run Prolog module code in Prolog compilers such as GNU Prolog that don't include a module system."
 [fn::https://stackoverflow.com/questions/6695788/programming-in-the-large-with-prolog]
** Documentation system
PlDoc <module> documentation should be taken to mean <file> documentation:
It is files that are documented, not modules.

Compare: Logtalk's documentation system[fn::https://logtalk.org/tools.html]
** Writing portable Prolog programs
*** Use Logtalk?
*** Which string representation should I use?
If you don't need to write portable Prolog programs, you can skip this section.

Unless you have to care about portability, use dedicated /double-quoted/ string type (SWI-Prolog 7):
- "Strings are distinct from lists"[fn::http://www.swi-prolog.org/pldoc/man?section=strings]
- "Why has the representation of double quoted text changed?"[fn::http://www.swi-prolog.org/pldoc/man?section=ext-dquotes-motivation]
- 2013 article "Strings in ECLiPSe 6.2, SWI-7 and YAP"[fn::http://eclipseclp.org/wiki/Prolog/Strings]
  - "With SWI-7 and ECLiPSe 6.2 string support has been harmonized, and YAP is expected to agree as well."
  - "Agreed Common Functionality"
  - "Situation before December 2013"

Non-answer: Edinburgh style: Double-quoted string as list of integer codes (default mode of SWI-Prolog 6.6.4 on Ubuntu 14.04):
A string is represented as a list of character codes.
This was in 1993 ISO standard draft[fn::http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf], but this wasn't in the final version?
Example: ="aaa" = [97,97,97]=.
But this behavior changed in SWI-Prolog 7.

Non-answer: Double-quoted string as list of one-character atoms.
A string is represented as a list of one-character atoms.
Example: ="aaa" = [a,a,a]=.
** How do we manage language complexity?
We use context to disambiguate sayings in natural languages.
For example, "man" can mean a male human or to station people at some places as in "man the guns" or "unmanned vehicle".
We use "table" to mean a flat surface or a data set shown in columns and rows, depending on context.

Ad-hoc overloading is an example of this in programming languages.
We use the same procedure name but different parameter types.

But ad-hoc overloading quickly becomes confusing?
Also, what is the philosophical/mathematical foundation of ad-hoc overloading?
Is it an engineering kludge?
** Not interesting?
Sterling & YalÃ§inalp 1996 \cite{sterling1996logic} presents the logic programming analog of the Gang of Four object programming design patterns.
** Testing
The initial idea of "prorogued" programming \cite{afshari2012liberating} is to use the /user/ as an interactive dummy implementation of stub methods.
The stub implementation is "ask the user for what the return value of this stub method should be".
"Prorogue" is a rare English word meaning prolong or extend[fn::https://en.wiktionary.org/wiki/prorogue].
But that is not all; types can be prorogued too.
* Logic of objects
"From a logical point of view, an object, the basic abstraction unit, has a natural interpretation as a logic theory:
/an object is simply a collection of axioms which describe what is true about the object itself/." \cite{ciancarini1993logic} (emphasis mine)

An object is something with identity.
In Prolog, we represent identity with the /unique name assumption/.
Each object has a unique surrogate primary key.
Usually this key is a Prolog atom.
** Analogy: adding objects to C
In C we can have OOP by adding one "this/self" parameter as the first parameter of each method.
I think it is also possible in Prolog.
But should we?

#+BEGIN_EXAMPLE
object_class(alice, person).
object_class(bob, person).
object_property_value(alice, name, "Alice").
object_property_value(bob, name, "Bob").
#+END_EXAMPLE

#+BEGIN_EXAMPLE
person(alice).
person(bob).
person_name(alice, "Alice").
person_name(bob, "Bob").
#+END_EXAMPLE

Do we want to parameterize the class?
Note that in Prolog unifying parameters is easier than unifying predicate names.
That is, we cannot write ~P(A) = Q(A)~ where P and Q are variables.

"Mapping Objects to Persistent Predicates"
https://pdfs.semanticscholar.org/f1ec/9e0e24faa1332d0cb60149e1d633b8d2509e.pdf

Should we write our DSL in Twelf instead of Prolog?
http://twelf.org/wiki/LF

"Objects with logic" 1990
https://dl.acm.org/citation.cfm?id=100368



The difference between object and value is that an object has identity.

Must everything have a name?

An object has properties.
A property is a key-value pair.

There are several ways to /represent/ such objects in Prolog.

The 1-object-1-term representation represents an object as a ground term.
There are two choices for such term: (1) a Prolog functor whose arity is the object's property count, or (2) a list of key-value pairs.
The meaning of such representation is that iff the list L contains K-V, then the represented object has a property K whose value is V.

The 1-property-1-predicate representation represents each property as a predicate, but this requires /unique surrogate naming/ of the object for identification:
object_property1(O,P).
object_property2(O,P).

It is surprising that database normalization theory explains some characteristics of good Prolog code.

Example:
Suppose that there are two people Alice and Bob.

The question: is the object an /entity/ or a /value/?
An entity has identity.
A value does not have identity.
A natural number does not have an identity.
A person has an identity.
Two people may have the same name while still being two different people.
The same natural number may be referred with a Arabic numeral or a Chinese numeral, but both of them refer to the same natural number.

The 1-object-1-term representation:
#+BEGIN_EXAMPLE
[name-"Alice", birthdate-date(1990,1,1), pets-[cat,dog]]
[name-"Bob", birthdate-date(1990,1,1), pets-[cat,dog]]
#+END_EXAMPLE

The 1-object-1-predicate representation:
#+BEGIN_EXAMPLE
person([name-"Alice",birthdate-date(1990,1,1)).
person([name-"Bob",birthdate-date(1990,1,1)]).
#+END_EXAMPLE

The 1-property-1-predicate representation (is this database in sixth normal form?):
#+BEGIN_EXAMPLE
person_name(alice,"Alice").
person_pet(alice,cat).
person_pet(alice,dog).
person_name(bob,"Bob").
#+END_EXAMPLE
Note that we do not write person_pets(alice,[cat,dog]).

The ontological representation:
kind_surrogate_property_value(person,alice,name,"Alice").
kind_surrogate_property_value(person,alice,birthdate,date(1990,1,1)).

The parameter O serves as an internal name.
The equality of that parameter determines the identity of the represented object.

Two objects can be equal but not identical.

A value has no identity.
An object has an /identity/.

Iff object_property(O,P) is provable, then object O has property P.

Object-oriented programming in Prolog?
https://stackoverflow.com/questions/28154041/objected-oriented-programming-in-swi-prolog

** One-property-one-predicate representation of objects
Another core idea is the /one-property one-predicate/ representation, with surrogate primary keys.
This enables us to represent objects in Prolog.
Objects have identities.
Two objects are identical iff their identifiers (primary keys) are equal.
Example:
#+BEGIN_EXAMPLE
person(PersonId)
person_name(PersonId, Name)
person_birthdate(PersonId, BirthDate)
#+END_EXAMPLE

** OPV (object-property-value) representation of constant objects
Objects without mutation.
Immutable objects.
** Representation
A class C has properties P1, P2, P3, etc.
How do we represent an /instance/ of C in Prolog?
There are at least two ways: /many-predicates/ and /one-term/.

The /many-predicates/ representation makes it easy to add derived properties.
One predicate represents one property.
This is similar to 6NF (sixth normal form) in database theory.

#+BEGIN_EXAMPLE
c_prop1(InstanceId, Prop1).
c_prop2(InstanceId, Prop2).
c_prop3(InstanceId, Prop3).
...
#+END_EXAMPLE

The /one-term/ representation makes it easy to specify an instance.
One term represents one instance.
This is similar to 0NF/1NF (zeroth or first normal form) in database theory.

#+BEGIN_EXAMPLE
c(InstanceId, [
    prop1 - Prop1,
    prop2 - Prop2,
    prop3 - Prop3,
    ...
]).
#+END_EXAMPLE

But we can combine both.
We can translate an instance-wise representation to a property-wise representation:

#+BEGIN_EXAMPLE
:- discontiguous c_prop1/2, ..., c_propN/2.

c_prop1(InstanceId, Prop1) :- c(InstanceId, Props), member(prop1-Prop1, Props).
c_prop2(InstanceId, Prop2) :- c(InstanceId, Props), member(prop2-Prop2, Props).
c_prop3(InstanceId, Prop3) :- c(InstanceId, Props), member(prop3-Prop3, Props).
...
#+END_EXAMPLE

But the many-predicates representation is easier to refactor than the one-term representation.

Conclusions:
- A module may internally specify objects in the one-term (denormal-form) style,
  but should only export predicates in the many-predicates (normal-form) style.
- A translation should not import denormal-form predicates.
* Writing enterprise web applications
** Convenient Prolog HTML Expression
CPH stands for Convenient Prolog HTML.
CPHE stands for CPH Expression.
The source file is =html_cph.pro=.

Before you use this library:
- We have only HTML 5 in mind.
  We do not handle DTD, SGML, XML, and all that stuffs.
- We require that the Prolog implementation have a dedicated double-quoted string type, in which a string is not a list of codes.
- We only write HTML and do not read HTML.
- We do not handle all tags.
  See is_tag/1 and is_empty_tag/1 in the source.
- We do not handle comments.
- We do not indent the HTML output.
  It is human-unreadable.
- Security notice:
  We only escape attribute values and text nodes.
  We do not escape attribute names and doctypes.
- Element names must be all-lower-case atoms.

<2019-03-29>
Motivation:
SWI Prolog 7.6.4 library(http/html_write)[fn::http://www.swi-prolog.org/howto/http/HelloHTML.html] was made before double-quoted strings.

To understand the idea, see the following example translation.

The predicate cphe_string/2 translates CPHE to HTML like this:
#+BEGIN_EXAMPLE
p(class=foo, "Text", style="color:#f00;", strong("Strong"))

<p class="foo" style="color:#f00;">Text<strong>Strong</strong></p>
#+END_EXAMPLE

An example of a document:
#+BEGIN_EXAMPLE
[
    '!doctype'(html)
    , html(
        head(
            title("Title")
        )
        , body(
            p("Paragraph")
        )
    )
]
#+END_EXAMPLE

Do not conflate atoms and strings.
Atoms translate to empty elements.
Strings translate to escaped texts.
** SQL-Prolog integration sketch
*** The idea
The source file is =sql.pro=.

The initial key idea is a 1:1 mapping between SQL tables and Prolog predicates.
But is it mapping to tables or to SQL SELECT queries?
We can think of a table as a SELECT query.
The key idea is a Prolog predicate that succeeds once for each row in a corresponding SQL table.
What if we can access a SQL table as if it were a Prolog predicate?

It should be possible to make something like F# data provider but with Prolog predicates.
It should be possible to make a Prolog predicate that fetches data when called.

The dream is seamless integration between Prolog and SQL databases.
Seamless SQL-backed Prolog predicates.

Several design choices:
- seamless/proxy-predicate approach: a predicate that uses a connection pool;
  use "proxy" predicates with odbc_query/3; an SQL table with N columns is represented by a predicate with arity N
- dynamic-predicate approach: populate dynamic predicates with data from table
- optimizer-interpreter that works for both Prolog databases and SQL databases; an SQL table is modeled by a term table(Id,Cols)
- The "persistency" library for persistent dynamic predicates[fn::http://www.swi-prolog.org/pldoc/man?section=persistency]

Warren 1999: "Prolog is an elegant language for database queries.
In fact if one constrains Prolog programs to use only atoms, integers and reals (no lists or complex terms) and disallows recursive definitions,
one gets a database language that is equivalent to a powerful subset of SQL."[fn::https://www3.cs.stonybrook.edu/~warren/xsbbook/node11.html]

#+BEGIN_EXAMPLE
% employee(Id, Name, Age)

query :- interpret((table_row(employee,E), row_column_value(E,age,Age), Age >= 20)).
#+END_EXAMPLE

Models of SQL SELECT statements:
- select(Table, Columns, Opts) where Opts is the optional parts (WHERE clause)
  - Column is an atom or an "Column as Alias"

#+BEGIN_EXAMPLE
select(information_schema:columns
    , [table_name as table, column_name as column, column_type as type]
    , [
        where(column_type = "integer")
        , order_by([asc(table)])
    ])
#+END_EXAMPLE

For testing (Do not do this on public/production server):
#+BEGIN_EXAMPLE
CREATE USER test PASSWORD 'test';
CREATE DATABASE test OWNER test;
#+END_EXAMPLE

Other systems:
- CQL[fn::http://www.swi-prolog.org/pldoc/man?section=cql] (Constraint Query Language) encloses its DSL expression in braces.

"There have been some Prolog systems in the past that could store predicates on a file."[fn::https://swi-prolog.discourse.group/t/scaling-to-billions-of-facts/380/2]

An SQL table can be thought as a predicate that only works with ground terms.
*** Making it work
*** Making it fast
We want to push the filter condition to SQL.
We want to filter as close as possible to the source as much as possible.
We want to minimize the amount of data transferred over the network.
We want to move the computation?
We want to run Prolog on the SQL database?
#+BEGIN_EXAMPLE
employee(E), employee_age(E,A), A >= 30
#+END_EXAMPLE
*** Incremental/progressive aggregation
We often need to derive OLAP table from OLTP table.
But PostgreSQL materialized view cannot partial-refresh.[fn::https://stackoverflow.com/questions/25641240/is-it-possible-to-partially-refresh-a-materialized-view-in-postgresql]
Often an OLTP table is an append-only log (but sometimes there is "backdating").

Often we want to speed up queries like this:
#+BEGIN_EXAMPLE
SELECT date, SUM(amount) FROM sale GROUP BY date;
#+END_EXAMPLE

We know that the query does not have to be recomputed because we know that there has been no changes to the past data in the source table.

But SQL is inconvenient, so we want to aggregate in the application and cache the result in an SQL table.

It should be possible to capture this architectural pattern in Prolog, and generate the implementation.
*** What else? Other similar implementations?
Jarke, Clifford, Vassiliou 1984 \cite{jarke1984optimizing}

"One of the things that ProLog by BIM had was the ability to have Prolog use Oracle or Sybase databases as if they were Prolog's own native database"[fn::https://news.ycombinator.com/item?id=12941910]

XSB-ODBC may be similar to what I want.
*** More ambitions: all data sources are predicates, and predicates are iterators
It is straightforward to generalize to other data sources:
JSON, CSV, NoSQL, Redis, Lucene, etc.
SLD resolution makes predicates behave as iterators.

Every object or table-row can be represented by a relation instance.

This is similar to F# type providers.
*** SWI-Prolog, PostgreSQL, and ODBC
Install the Ubuntu 14.04 package =odbc-postgresql=.

I want my application to self-contain its configuration.
I don't configure ODBC INI files.

ODBC Data Source Name (DSN) connection string

Relevant commands: =odbcinst -j=

The file =/etc/odbcinst.ini= contains a list of driver names.

[[http://www.swi-prolog.org/pldoc/doc_for?object=section(%2527packages/cql.html%2527)][SWI-Prolog CQL documentation]] doesn't inspire confidence.
Draxler 1991 relates database table and Prolog predicate.
CQL models SQL query in Prolog terms.
** Relational-multidirectional-logic programming?
** The operations
The story does not end with development.
After it comes /operation/.
It's a boring task.
But someone has to do it.
Thus, how we make it as painless as possible?
*** Devops, dependency, build system?
Prolog marelle, Haskell shake, build system?

- http://quietlyamused.org/blog/2013/11/09/marelle-for-devops/
- "there is already a configuration management language that is strongly influenced by Prolog and logic programming - Puppet - and the results are not that great"
  https://news.ycombinator.com/item?id=6701362
  - really?
  - The computer can't read your mind.
    You lie to the computer, it does what you told it to do.
    Don't blame the computer for your failing to tell the computer everything it needs to do the job.

** Idea: Write an SQL database explorer in Prolog.
CLI interface without ncurses without pager.
Imagine printing to paper like early Fortran/Unix/ed.
Paper user interface.
- menu(KeyActionPairs).
- select database
- select schema
- show 10 rows of table, 15 chars per column, truncating long strings with ">"
  - tput https://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window
  - My 1920x1080 terminal has 191 columns and 53 lines.
- go up / back to previous menu.
** Use Prolog for formal software requirement capture / modeling.?
"Are there any standard Prolog knowledge bases available anywhere that have the same purpose as Cyc, namely to encode generally accepted common sense and human knowledge?"
https://cs.stackexchange.com/questions/35237/open-standard-prolog-knowledge-bases

2004 "SweetProlog: A System to Integrate Ontologies and Rules"
https://pdfs.semanticscholar.org/03c2/a0048a5845bb1f52462c4f26d7be0a929d7a.pdf

Prolog is better than Turtle.
http://sujitpal.blogspot.com/2009/06/ontology-rules-with-prolog.html
"I actually set out to learn Jena Rules using the Semantic Web Programming book as a guide.
Midway through that exercise, it occurred to me that Prolog would be a cleaner and almost drop-in replacement to the rather verbose Turtle syntax.
Apparently the Semantic Web community thinks otherwise, since Turtle stands for Terse RDF Triple language.
I haven't actually used Prolog before this, although I've read code snippets in articles once or twice (but not recently), so the realization was almost like an epiphany."

http://collaboration.cmc.ec.gc.ca/science/rpn/biblio/ddj/Website/articles/DDJ/1989/8910/8910f/8910f.htm

https://www.cs.auckland.ac.nz/~j-hamer/07.363/prolog-for-se.html

http://ceur-ws.org/Vol-274/paper6.pdf
** Prolog revival attempt
- https://github.com/Web-Prolog/swi-web-prolog

Wielemaker & Angelopoulos 2012 "Syntactic integration of external languages in Prolog"
https://pdfs.semanticscholar.org/35eb/0b9d6edc27dd4564d98b107fec08e45e36cd.pdf
SQL-Prolog
Draxler [2]
NED [5]
** Logic programming for software engineering?
\cite{ciancarini1993logic}

\cite{liu2018logic}
** How reliable is query-by-example?
https://en.wikipedia.org/wiki/Query_by_Example
* DSL, meta-programming, optimizing, checking, multi-paradigm, whatnot
** Ramble: Translating Prolog to native code?
The idea is to relate a Prolog predicate and a C routine.

Every disjunct translates into one routine / basic block.

The current goal relates to the instruction pointer.

Proving a goal ~ calling a routine
Conjunction of phrase ~ sequence of call
Disjunction of clause ~ speculative parallel execution, for pure predicates only

p(A),q(A) can be optimized from O(PQ) time to O(max(P,Q)) time if we order the storage.

Intermediate language
Compile by abstract interpretation
unify(Var1,Var2)
frame(Instrs)
prove((A,B)) :- prove(A), prove(B).

A variable in clause head is implicitly universally quantified.
A free variable in clause body is implicitly existentially quantified.


Prolog just-in-time compilation
compile(GoalAst, Fragment)
call(Fragment)
Execute?

Compile prolog predicates, limited to u32 parameters.
Normalize p(a). to p(A) :- A=a.
If first arg is bound, use index.
Else sequential scan.
Subset of prolog.
Focus on translation for performance.
No dynamic predicates.
Generate a c func for some predicate direction.
plus_bbb
plus_bbu
...
plus_uuu
Add a state parameter for nondet predicate. (Next clause index to try). Initial value 0.
p(A,B) :- B is A + 1.

Libjit vs llvm?
mmap and mprotect

father_child(F,C)

bool father_child(termref F, termref C) {
}
** Implicit state language?
#+BEGIN_SRC prolog
interpret(state(S), S, S).
interpret(state_set(S), _, S).
interpret((A,B),S0,S2) :- interpret(A,S0,S1), interpret(B,S1,S2).
#+END_SRC
** <2018-11-30> Prolog needs static checking like Erlang Dialyzer.
SWI-Prolog has check library?

Is there a Prolog totality/determinism checker?

Prolog typechecking is vital to prevent stupid mistakes in a large knowledge base?

1997 inconclusive discussion "Prolog Type Checker"
https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/typing/types.html
** Alternative declarative semantics
*** Prolog should use three-valued logic?
Suppose that both A and B are unbound variables.
Then:
- =A == B= is unknown, but it's false in Prolog.
- =A \= B= is unknown, not it's false in Prolog.

In that case, it is better for Prolog to throw an instantiation_error instead of failing.

Three-valued logic would simplify and elegantize constraint logic programming?
*** Declarative programming? Function arguments?
The idea:
A relation's parameter can be a unifiable logic variable or a beta-reducible lambda expression.
#+BEGIN_EXAMPLE
is_one(A : exp(integer)) :- A = 1.
?- is_one(0+1).
true.

f(A : var(integer)) :- A = 1.
?- f(0+1).
false.
#+END_EXAMPLE

TODO
Compare various approaches such as LambdaProlog, Mercury, and Curry.
*** What?
Porto 2011 \cite{porto2011structured}
** Meta-programming
<2018-12-06>
Prolog is the best meta-language I have found so far.
It is a good meta-language for defining other languages.

To define 'macros', use =term_expansion= or =goal_expansion=.
** Constraint logic programming
Why does use_module(library(clpfd)) increases loading time perceptibly?

Should we use clpfd #=/2 instead of is/2?
But it's good to have minimal dependencies.

Motivation?

Consider this program for enumerating the duplicates in an array.
#+BEGIN_EXAMPLE
duplicate(F, I, J, A) :-
    arg(I, F, A),
    arg(J, F, A),
    I \= J.
#+END_EXAMPLE

The compiler should be able to infer the constraints and use it to produce this, reducing the number of comparisons to half the original?
#+BEGIN_EXAMPLE
duplicate(F, J, K, A) :-
    functor(F, _, N),
    between(1, N, J),
    between(J, N, K),
    arg(J, F, A),
    arg(K, F, A),
    J \= K.
#+END_EXAMPLE
** Advanced logic programming
According to some curriculums, advanced logic programming includes
SLG (tableau) resolution,
constraint logic programming,
and inductive logic programming.
** Language-oriented programming, embedding a language in Prolog
Advantages:
- Reuse all of Prolog.
- Concentrate on the abstract syntax and the semantics, and not on the surface syntax.

Disadvantages:
- No custom syntax error messages, because we embed our language in Prolog.
- Limited to Prolog syntax.
  No array index operator such as =a[i]=.

Several possibilities:
- Horn clauses.
- Custom terms with custom interpretation function.

The 2010 article "Using DSLs for Developing Enterprise Systems" [[https://research.cyber.ee/simpl/enterprise-dsl.pdf][pdf]]:
- It uses the terms "language engineer", "transformation specialist", and "business engineer".
- It defines several usage scenarios of DSLs.
- It defines five criteria for comparing DSL tools.
- It compares some DSL tools.
- It should have been a wiki article.

A relation can be thought as an interpretation of function terms.
For example, m0/2 and m1/2 give different meanings to the same function term f/1.
#+BEGIN_EXAMPLE
m0(f(X), Y) :- Y is X+1.
m1(f(X), Y) :- Y is 2*X.
#+END_EXAMPLE

Prolog is ideal for writing DSLs because:
- We can embed the abstract syntax in Prolog syntax.
  We can skip specifying the grammar and go directly to specifying the semantics.
- Specifying the semantics is straightforward.

#+BEGIN_EXAMPLE
exp_val(S, T) :- string(S), !, S = T.
exp_val(S, T) :- number(S), !, S = T.
exp_val(A+B, C) :- string(A), string(B), !, string_concat(A, B, C).
exp_val(A+B, C) :- number(A), number(B), !, C is A+B.
#+END_EXAMPLE
** Iterative deepening search with length/1
Prolog uses depth-first search.
It isn't complete.
(What does that mean?)

If you have a query =goal(List)= where =List= is a list,
then you can query =length(List, _), goal(List)= to make the search complete.

https://en.wikibooks.org/wiki/Prolog/Search_techniques
** Prolog = Lisp + operators + reflection + backtracking
Both Prolog and Lisp has terms, read, eval, write, and macros.

Prolog has read/1.
Lisp has read.

Prolog has call/1.
Lisp has eval.

Prolog has term_expansion/2.
Lisp has defmacro.

Prolog has infix prefix, infix, and suffix operators.
Lisp does not have them?
Lisp is all prefix?
There may be some extensions?

Operators facilitate human-reading but complicate machine-parsing.

If we are going to pick a high-level language,
we should pick one that has solid mathematical foundation.
But that is enough.
How about language usability and toolchain?
** All state computations are pure in the bigger supersystem
Endofunction from state to state.

Side-effects are like weed:
They are human-invented labels, a subjective teleological categorization without objective ontological existence.
** Warren abstract machine
"Goal: Adapting the Warren abstract machine to the LLVM IR machine model for later compilation."
"Hassan AÃ¯t-Kaci's WAM book"
2018
https://www.researchgate.net/project/Compiling-Prolog
** Attributed variables
I feel that attributed variables seem to be an engineering hack without mathematical justification.
It interacts badly with term-copying.
** Partial evaluation
A common way to make compiler is to use a parser generator and what?

A possibly better way is to write an interpreter and /get a compiler for free/ by partial evaluation.

Writing an interpreter is much easier than writing a compiler.

"Partial deduction" is partial evaluation from logic point of view.
* Foreign language interface
SWI-Prolog has a foreign language interface[fn::http://www.swi-prolog.org/pldoc/man?section=foreign], but I demand more.

I want to write low-level code /directly in Prolog/.

I want to write C code in Prolog.
I want to have C with type inference and other cool features in Prolog.

I dream of writing foreign code directly in Prolog.
I dream of a Prolog code that can output an amd64 ELF binary.
Related in mailing list[fn::https://groups.google.com/forum/#!topic/comp.lang.prolog/-WhsxJqPRRU].
Related from the 1990s[fn::https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/compiler2.html].
Related: Warren 1980 \cite{warren1980logic}.

There are two problems:
emitting machine code, and executing machine code.

Options for emitting machine code:
- Design a DSL like ASN.1 to describe binary layout such as C struct or Pascal record.
  I have a sketch in database_internal_dcg.pro.
- Design an language that can be represented in Prolog and translated to C.
- Reuse LLVM.
- Building something like LLVM.
  Write our own intermediate representation.
  Static-single-assignment three-address code.
- Write amd64 machine code directly.
  This is bad.
  Too tightly coupled.
  We will want to generate i386, arm, and jvm machine codes.

Options for executing machine code:
- Write machine code to some memory area, set PROT_EXEC with mprotect, and call the address.
- Write an ELF SO object and use dlopen.

The skeleton of the minimum viable product:
#+BEGIN_EXAMPLE
example :-
    compile(ret, ByteCode),
    write_bytes(ByteCode).

nb_write_address(+Address, -Thing)
#+END_EXAMPLE
* What next after Prolog?
** Embedding Prolog/Haskell in Haskell/Prolog
Why bother with this?
Why not just use Oz?
*** Embedding Prolog in Haskell
- 1999 article "Embedding Prolog in Haskell" https://pdfs.semanticscholar.org/7c46/5d25205830735d0a034532746b7243221eca.pdf
  - "We propose an embedding of logic programming into lazy functional programming
    in which each predicate in a Prolog program becomes a Haskell function,
    in such a way that both the declarative and the procedural reading of the Prolog predicate are preserved."
- 1988 article "Towards functional programming in Prolog" ftp://obaluae.inf.puc-rio.br/pub/docs/Publications/88_AI_Furtado_SINPLAN.Not.pdf
*** Embedding Haskell in Prolog: Nobody is talking about this?
translate haskell to prolog
- https://stackoverflow.com/questions/1932770/haskell-vs-prolog-comparison
- https://github.com/COMS30106/slides
- https://github.com/COMS30106/slides/blob/master/haskell2prolog.pdf

Prolog and Haskell are almost equally concise.
Prolog and Haskell are even in head/2 and tail/2.
Prolog beats Haskell in null/1 and reverse/2.
Haskell beats Prolog in length/2, sumList/2, and everything that has arithmetics where Prolog requires intermediate variable such as "N1 is N-1".
** Comparison with other programming languages
"GOEDEL is intended to be a declarative successor to Prolog."
https://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/prolog/impl/other/goedel/0.html

How are Prolog and Lisp similar?
- Both Prolog and Lisp have symbols and cons cells.
  - This is a Lisp cons cell: =(cons 'a 'b)= or ='(a . b)=.
  - This is the corresponding SWI-Prolog cons cell: =[a|b]= (the canonical form is ='[|]'(a,b)=).
- Both have macros.
  - Lisp has defmacro.
  - Prolog has term_expansion/2 and goal_expansion/2.

I'd say Prolog = Lisp + unification + backtracking - lambda.

Comparison between what is difficult in various programming languages:
- 2014 presentation "That scripting language called Prolog" https://www.slideshare.net/SergeiWinitzki/prolog-talk
  - It compares what is difficult in various programming languages.
  - It defines "declarative": 'Programming is "declarative" when /specifications are programs/.'
    - Slide 29: "declarative programming = creating a good DSL for your domain"
  - Slide 24 compares SQL, Datalog, and Prolog.

Comparison with other relational programming languages:

Comparison with miniKanren:
- https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp
  - William E. Byrd's answer:
    - Prolog is practical; miniKanren is pure.
    - Prolog unification doesn't use occurs check; miniKanren unification uses occurs check.
    - Prolog uses depth-first search; miniKanren uses complete interleaving search.
    - '[...] miniKanren is being used for research in "relational" programming.'
    - "Over time miniKanren has added more symbolic constraints, really becoming a symbolically-oriented Constraint Logic Programming language."
    - "There are other very interesting logic programming languages as well, such as Mercury, Curry, and GÃ¶del, each of which has its own take on logic programming."

Mercury vs Prolog
- http://lambda-the-ultimate.org/node/890
- <2018-10-21> "The Prolog to Mercury transition guide" https://www.mercurylang.org/information/doc-latest/transition_guide.pdf

SQL? Datalog?
** History of logic programming? The key idea of logic programming operational semantics?
Colmerauer & Roussel 1996 \cite{colmerauer1996birth}:
"It can be said that Prolog was the offspring of a successful marriage between natural language processing and automated theorem-proving."

Philippe Roussel coined the name "Prolog" in Marseilles in 1972. \cite{colmerauer1996birth}

Robinson 1965 \cite{robinson1965machine}

The key idea of logic programming is the interpretation of a Horn clause as a procedure declaration (Kowalski 1974 \cite{kowalski1974predicate}).

Logic seems to be the internal language of thought.

Elaborated in van Emden & Kowalski 1976 \cite{van1976semantics}.

Predicate logic can be used both for programming and for knowledge representation.

What is "refutation-complete"[fn::https://en.wikipedia.org/wiki/SLD_resolution]?

http://www.prolog-heritage.org/en/ph1.html

SWI-Prolog goes back to 1986.[fn::http://www.swi-prolog.org/pldoc/man?section=implhistory]

Did logic programming emerge from automated theorem proving?
What is computational logic?
What is automated reasoning?

Maarten van Emden has a blog[fn::https://vanemden.wordpress.com].

The relationship between Lisp and lambda calculus is superficial:
van Emden[fn::https://vanemden.wordpress.com/2017/09/08/conceptual-integrity-why-it-matters-and-how-to-get-it/]) wrote that John McCarthy wrote (emphasis mine):
#+BEGIN_QUOTE
To use functions as arguments, one needs a notation for functions, and it seemed natural to use the lambda notation of Church (1941).
/I didnâ€™t understand the rest of his book/, so I wasnâ€™t tempted to try to implement his more general mechanism for defining functions.
#+END_QUOTE
** Programming can be thought as applied mathematics?
Prolog can be approached from logic, database theory, philosophy.

In Prolog, by default, function symbols mean themselves,
and this gives us freedom to write interpreters to interpret function symbols differently.
** Theorem proving
Problem statement of automated theorem proving:
Given a formula G (query, goal), a set of axioms A, and a set of inference rules R, prove G.

A formula can be represented by a Prolog term.

An inference rule transforms a formula into another formula having the same truth value.

It may be better to write a theorem prover in Prolog than to use Prolog directly as theorem prover.

Prolog can be used as a theorem prover.
#+BEGIN_EXAMPLE
p.
q :- p.

?- q.
true.
#+END_EXAMPLE

It is simple to write a theorem prover for propositional logic.
But how about first-order logic?

What is resolution[fn::https://en.wikipedia.org/wiki/Resolution_(logic)]?
Why is it widely used in automatic theorem proving?

Aren't theorem provers just constrained rewriting systems?

Modus ponens \( \alpha, (\alpha \to \beta) \vdash \beta \).
** Logic programming vs theorem proving
- https://stackoverflow.com/questions/36335633/difference-between-logic-programming-and-automated-theorem-proving
- https://en.wikipedia.org/wiki/Automated_theorem_proving
** <2018-12-05> How to present Prolog to newcomers
This is a draft.
These are slides.
Assume that one section is one slide.

There are several ways to introduce Prolog:
- as a deductive database
- as a logic programming language
- as a procedural programming language with backtracking
- as a natural language processing tool, which is its original reason of existence \cite{colmerauer1996birth}
- as an artifical intelligence tool (what? automated reasoning?)

It may be best to introduce Prolog as a deductive database.
We want people to have understanding and good habit.
*** "Talking" with the computer
We can think of an interactive Prolog session as a /conversation/ with the computer.

The Prolog phrase "append(A, B, C)" means the English clause "appending list A and list B produces list C".

Here we show some ways of calling append/3.

Here we show how to read Prolog fragments in English.

"Prolog, does appending [1] and [2,3] produce [1,2,3]?"
#+BEGIN_EXAMPLE
?- append([1], [2,3], [1,2,3]).
true.
#+END_EXAMPLE

"Prolog, what does appending [1] and [2,3] produce?"
#+BEGIN_EXAMPLE
?- append([1], [2,3], C).
C = [1,2,3].
#+END_EXAMPLE

"Prolog, what list do I have to append to [1] in order to produce [1,2,3]?"
#+BEGIN_EXAMPLE
?- append([1], B, [1,2,3]).
B = [2,3].
#+END_EXAMPLE

"Prolog, what list produces [1,2,3] when appended with [2,3]?"
#+BEGIN_EXAMPLE
?- append(A, [2,3], [1,2,3]).
A = [1] ;
false.
#+END_EXAMPLE

"Prolog, does appending [1] and [2] produce [1,2,3]?"
#+BEGIN_EXAMPLE
?- append([1], [2], [1,2,3]).
false.
#+END_EXAMPLE

We press ";" to ask Prolog to find another solution.
Prolog prints "false" when it doesn't find any more solutions.

"Prolog, what list produces [1] when appended with itself?"
#+BEGIN_EXAMPLE
?- append(A, A, [1]).
false.
#+END_EXAMPLE

"Prolog, what list produces [1,2,1,2] when appended with itself?"

"[1,2]."

"Is there any other such list?"

"No."
#+BEGIN_EXAMPLE
?- append(A, A, [1,2,1,2]).
A = [1,2] ;
false.
#+END_EXAMPLE

"Prolog, what two lists A and B produce [1,2,3] when appended?"
#+BEGIN_EXAMPLE
append(A, B, [1,2,3]).
A = [], B = [1,2,3] ;
A = [1], B = [2,3] ;
A = [1,2], B = [3] ;
A = [1,2,3], B = [] ;
false.
#+END_EXAMPLE
*** Write once, run in several directions
The Prolog code for append/3 seems simple.
We can see in SWI-Prolog library/lists.pl [[http://www.swi-prolog.org/pldoc/doc/_SWI_/library/lists.pl?show=src#append/3][append/3]] (I renamed some variables):
#+BEGIN_EXAMPLE
append([], B, B).
append([H|A], B, [H|C]) :- append(A, B, C).
#+END_EXAMPLE

Haskell seems simpler:
#+BEGIN_EXAMPLE
append [] b = b
append (h : a) b = h : append a b
#+END_EXAMPLE

But those fragments differ.
In Prolog we can run the code in other /directions/.
There are 3 parameters, each with two directions (input/bound or output/unbound); thus there are 2^3 = 8 possible directions.
The Prolog predicate translates to at least 5 Haskell functions,
for the 5 ways of using append/3 we saw earlier.

We write append/3 once, and we get at least five ways of calling it.

But this beautiful dream crumbles outside pure symbolic logic programming.
*** Another declarative example: palindromes
"A list L is a palindrome iff L is its own reverse."
#+BEGIN_EXAMPLE
palindrome(L) :- reverse(L, L).
#+END_EXAMPLE
*** Learning resources?
2015
Approaches for Learning Prolog Programming
https://www.tandfonline.com/doi/full/10.11120/ital.2007.06040088

[[http://kti.ms.mff.cuni.cz/~bartak/prolog/index.html][Roman BartÃ¡k's "On-line Guide to Prolog Programming"]]

https://www.cis.upenn.edu/~matuszek/Concise%20Guides/Concise%20Prolog.html

display/1 vs write_canonical/2? https://swi-prolog.discourse.group/t/re-swipl-re-pedagogy/48/10
** Avoid using list too much
Perhaps think more about the relations between the individuals.

Perhaps normalize your predicates to sixth-normal form.
** miniKanren?
Relational programming, microKanren
http://matt.might.net/articles/microkanren/

2017
A Unified Approach to Solving Seven Programming Problems (Functional Pearl)
http://io.livecode.ch/learn/gregr/icfp2017-artifact-auas7pp

2013
rKanren - Guided Search in miniKanren, Part I
http://cgswords.github.io/rkanren/

Schelog vs minikanren?
** What is wrong with logic programming?
"What is Wrong with Logic Programming?"
"A Deductive Solution to Mutable State and I/O"
https://pdfs.semanticscholar.org/ca08/dcb9eddc1e7651509daac7fa02eddb7f675b.pdf
** Why use Prolog for AI?
Because Prolog produces /explainable/ AI.
** Dreams, speculations, ambitions
Harel 2008 \cite{harel2008can} has a lovely ambition.
But I'm afraid I see only two way to realize that ambition:
either invent a human-level AI that can write software, or invent a machine that can do telepathy.
But I believe that we will someday have at least one of that.

I want a browser like this.
Each user should have total control of what runs on his/her machine.
I should be able to tell my browser how to modify the CSS and JavaScript for certain websites.
From \cite{harel2008can}:
#+BEGIN_QUOTE
[...] conveniently remove pieces of behavior that we donâ€™t like and replace them with others [...]
I would love to be able to reprogram the interactions that the web-based systems I work with force me to followâ€”not to mention reprogramming my annoying and unnecessarily complicated DVD.
I canâ€™t change the way Amazon or B&H respond to what I do, for example, but I can surely change everything that has to do with the way my browser and my computer deal with these websites.
And how better to do that than by simply canceling some pieces of interactive behavior and playing in new ones, using the very interface on which we interact, subject, of course, to my inability to change their behavior?
#+END_QUOTE
** Closures, higher-order logic programming
Ulrich Neumerkel's "Lambdas in ISO Prolog"[fn::https://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/ISO-Hiord.html].

Logtalk 2.38.0 has lambda expressions.[fn::https://blog.logtalk.org/2009/12/lambda-expressions-in-logtalk/]

Why can't it be this?
Isn't "apply" just variable substitution?
But the problem is not substitution.
The problem is /scoping/.
#+BEGIN_EXAMPLE
apply(A^B, A, B).
#+END_EXAMPLE

<2019-04-05>
See lambda.pro.
It does the job, but the variables cannot be reused.

Example of closure:
#+BEGIN_EXAMPLE
let makeGetter list = \ i -> elemAt list i
#+END_EXAMPLE

We can manually do closure conversion (lambda lifting)[fn::https://en.wikipedia.org/wiki/Lambda_lifting].

Naish 1996 \cite{naish1996higher} [fn::http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/naish.html]:
"First, we point out that call/N is not the way to go,
despite its recent popularity as the primitive to use for higher order logic programming."

Let's try something else.

I propose "local predicate" as the logic-relational analog of the functional lambda expression.

The meaning of the expression =A ^ B= is "prove B assuming that A is true".
The semantics is substitution.

Define the meaning of =A^B= as prove =B= assuming =A=.
Thus, the meaning of =p(1) ^ (p(A), q(B))= is =(A = 1, q(B))=.
* What mess?
** Gospel
If everyone could be 20x more productive using Prolog, then it is a sin to let them use Java or C++.
It is a massive waste of human life.
** Alternative Prolog syntax?
Curry/ML-like syntax for Prolog?

#+BEGIN_EXAMPLE
append([],B,B).
append([H|A], B, [H|C]) :- append(A,B,C).

append [] B B.
append [H|A] B [H|C] :- append A B C.
#+END_EXAMPLE
** What?
Prolog web browser, prolog gui, prolog operating system, prolog system f, normal-order lambda calculus, Haskell in prolog

Prolog to glue Haskell, racket, typescript

"adding a search Path in SWI prolog"
https://stackoverflow.com/questions/6334050/adding-a-search-path-in-swi-prolog

"The Mess We're In" by Joe Armstrong"
https://www.youtube.com/watch?v=lKXe3HUG2l4
43:20
We assume that two files A and B are similar if size(compress(A)) is similar to size(compress(A++B)).

decompilation, reverse engineering

"J.P. Bowen, From Programs to Object Code and Back Again Using Logic Programming: Compilation and Decompilation, Journal of Software Maintenance: Research and Practice, Vol. 5, No. 4, pp.205-234, December, 1993"
https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/compiler2.html
** Prolog parser in Prolog
https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/grammars/parser.html
** overview
https://www.ajibot.com/blog/overview-of-logic-languages
** what
Prolog clpq documentation doesn't mention multivariate optimization?
https://stackoverflow.com/questions/27716598/constraint-values-on-local-variable

http://www.amzi.com/manuals/amzi/pro/ref_execution.htm

http://users.cs.cf.ac.uk/O.F.Rana/prolog/lectureP5/node3.html

https://coderwall.com/p/laduzw/how-to-measure-execution-time-in-swi-prolog

https://www.reddit.com/r/prolog/comments/9mxhbw/the_art_of_prolog_second_edition_is_available_as/

http://www.swi-prolog.org/pldoc/man?section=modes
** Java
https://stackoverflow.com/questions/1817010/embedded-prolog-interpreter-compiler-for-java

https://github.com/raydac/java-prolog-parser
** what
http://dbs.informatik.uni-halle.de/Lehre/LP09/c3_purep.pdf

http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf
** beginner
prolog headless clause
https://stackoverflow.com/questions/14168363/what-does-a-clause-without-a-head-mean-in-prolog
** what
Read "The art of Prolog", second-order programming,

https://stackoverflow.com/questions/32835086/prolog-how-to-avoid-backtracking-without-cuts

Now I know this is false:
- Relational programming subsumes functional programming.
  - Functional programming is a special case of relational programming.
  - Every function is a relation.

Functional programming is more concise and readable than logic (relational?) programming when we are describing functions:
#+BEGIN_SRC haskell
fib 0 = 1
fib 1 = 1
fib n = fib (n-1) + fib (n-2)
#+END_SRC

#+BEGIN_SRC prolog
fib(0,1).
fib(1,1).
fib(N,F) :- N1 is N-1, N2 is N-2, fib(N1,F1), fib(N2,F2), F is F1+F2.
#+END_SRC

But we can translate a function to a deterministic (det) predicate in Prolog.
** whaaat
This marshallp guy is... inhuman?
He uses Prolog for note taking!
https://news.ycombinator.com/item?id=1142292
** Search engine?
AntRank
http://www.ijettcs.org/Volume3Issue2/IJETTCS-2014-04-23-113.pdf
** Reverse engineering?
- 1992 "A Logic-Based Approach to Reverse Engineering Tools Production"
https://pdfs.semanticscholar.org/4882/9fd716349ff586e21e9277890989daa0e916.pdf

Prolog-COBOL stuff

- 1991, Using Prolog for Reverse-Engineering and Validation
http://www.academia.edu/2493008/Using_Prolog_for_reverse-engineering_and_validation
- 1994, "Reverse Engineering of COBOL Programs into Prolog Programs"
http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.5073&rep=rep1&type=pdf
- 1992, "The Art of Computer Un-Programming: Reverse Engineering in Prolog"
http://www.academia.edu/1413561/The_art_of_computer_un-programming_Reverse_engineering_in_Prolog
  - https://link.springer.com/chapter/10.1007/3-540-55930-2_20

http://www.academia.edu/1413561/The_art_of_computer_un-programming_Reverse_engineering_in_Prolog
** Prolog, somewhat object-oriented, mapping from Java to Prolog
Prior arts:
2017 "Mapping Objects to Persistent Predicates"
https://pdfs.semanticscholar.org/f1ec/9e0e24faa1332d0cb60149e1d633b8d2509e.pdf

http://ceur-ws.org/Vol-274/paper6.pdf

Every Java class instantiation expression becomes a Prolog compound.

#+BEGIN_EXAMPLE
% From Java expression: new Class_name(field_1, field_n)
class_name(Field_1, ..., Field_N)
#+END_EXAMPLE

Every Java class instantiation statement becomes a Prolog fact.

#+BEGIN_EXAMPLE
% From Java statement: Class_name instance_name = new Class_name(field_1, field_n)
Class_name(Instance_name, Field_1, ..., Field_N).
#+END_EXAMPLE

Example
2010 "Simulating BPMN Models with Prolog"

#+BEGIN_EXAMPLE
final class Car {
    final String brand;
    final int year;
    // constructor omitted
}

Car a_car = new Car("Toyota", 2000);
#+END_EXAMPLE

becomes

#+BEGIN_EXAMPLE
car(a_car, [brand('Toyota'), year(2000)]).
% or
car(a_car, 'Toyota', 2000).
% or
car(a_car, car('Toyota', 2000)).
#+END_EXAMPLE

Large-scale Prolog?
1991 "Efficient Access To Large Prolog Knowledge Bases"
https://link.springer.com/chapter/10.1007/978-3-7091-7555-2_26
** What? 99 Prolog problems?
There is the [[http://www.ic.unicamp.br/~meidanis/courses/problemas-prolog/][99 Prolog problems]].
But what if you we are not undergraduate students with too much free time?
** Difference lists
- Who invented difference lists when?

A "difference list" is a term of the form =A - B= where =A= is a list and =B= is a list.

A difference list represents a list.

The difference list =A - []= represents the list =A=.

- https://en.wikipedia.org/wiki/Difference_list
- https://en.wikibooks.org/wiki/Prolog/Difference_Lists
  - Difference list has constant-time append.
    Ordinary list has linear-time append.
- https://wiki.haskell.org/Difference_list
  - "Whether this kind of difference list is more efficient than another list representations depends on usage patterns."
- http://homepages.inf.ed.ac.uk/pbrna/prologbook/node180.html
** <2018-10-20> How do we make sense of this counterintuitive module syntax?
- https://stackoverflow.com/questions/42399020/how-to-get-a-listing-of-a-specific-knowledge-base
** Discover the wonderful world of Prolog / logic programming / relational programming
*** Symbolic AI is the easiest AI approach.
- Connectionist AI (neural networks) excels at tasks that are difficult to describe in formal logic.
- Symbolic AI (Prolog) is much more understandable and predictable than connectionist AI.
  - Understanding connectionist AI requires probability, statistics, and real analysis.
- Why not both?
  2017 article "SLDR-DL: A Framework for SLD-Resolution with Deep Learning" https://arxiv.org/pdf/1705.02210.pdf?
*** Dreams
- offload/scale/formalize thinking/cognition
- transform reasoning into data entry
- brain prosthetics; cognitive prosthetics
- Leibniz, "Let us calculate!", calculus ratiocinator
  - https://en.wikipedia.org/wiki/Calculus_ratiocinator
  - https://publicdomainreview.org/2016/11/10/let-us-calculate-leibniz-llull-and-computational-imagination/
- probabilistic logic programming
- https://softwareengineering.stackexchange.com/questions/275680/the-dream-of-declarative-programming
** Making compilers
- https://www.reddit.com/r/ProgrammingLanguages/comments/9em9jf/future_directions_for_optimizing_compilers/
  - "Future Directions for Optimizing Compilers" https://arxiv.org/abs/1809.02161

"Universal-transpiler" may be similar to what we want.

- "Universal-transpiler"
  - https://github.com/jarble/transpiler
    - it also has links to similar projects
  - http://www.swi-prolog.org/pack/list?p=transpiler
** Declarative programming languages
[[http://www.cse.chalmers.se/~oloft/Papers/wm96/node2.html][Declarative Programming Languages]], functional logic programming, two ways it is done (narrowing and residuation);
definitional programming, GCLA language (separate definition and control)

- 1995, "Functional Logic Programming in GCLA", [[http://www.cse.chalmers.se/~oloft/Papers/wm95.pdf][pdf]]
** Speculative
*** Fast logic programming?
- https://www.reddit.com/r/ProgrammingLanguages/comments/9fgv3v/can_logic_programming_execute_as_fast_as/
  - https://www.info.ucl.ac.be/~pvr/Peter.thesis/Peter.thesis.html
- https://stackoverflow.com/questions/23711790/comparision-of-abstract-machines-for-execution-of-prolog
*** Lambda-prolog?

- lambda-prolog http://www.lix.polytechnique.fr/~dale/lProlog/
** Resources
*** For beginners
*** Not for beginners
- 1990 book "The craft of Prolog" by Richard A. O'Keefe
  - from the preface:
    "There are a lot of introductory Prolog books around.
    This is not one of them.
    Think of it as "second steps in Prolog".
    If you have already read one of the introductory books, if you have taken an introductory course on Prolog, if you have written one or two Prolog programs, and if you are wondering why it is still hard to writegood Prolog programs, this book is meant to help you.
    The purpose of the book is to show you how you can write Prolog programs that work, that don't take an unreasonable amount of time, and that are clean enough to show to your friends."
** What?
*** P# translates Prolog to C#.
https://pdfs.semanticscholar.org/12ec/568a6583d3d66b6821f28269f06937a9f2eb.pdf
*** "Real World Programming in SWI-Prolog"
http://www.pathwayslms.com/swipltuts/index.html
*** "Frequently Asked Questions for ##Prolog"
http://www.pathwayslms.com/swipltuts/student/
*** What are these trying to say?
- 1991 article "Logic Programming, Functional Programming, and Inductive Definitions" https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-205.pdf
  - "The unification of logic and functional programming, like the Holy Grail, is sought by countless people"
  - "More generally, we suggest that the traditional paradigm â€” logic programming as first-order logic â€” is seriously out of step with practice.
    We offer an alternative paradigm. We view the logic program as an /inductive definition/ of sets and relations."
  - "To justify the Closed World Assumption, we propose that logic programs should be viewed as inductive definitions, not as first-order theories.
    Some people refuse to abandon the dream of programming in first-order logic.
    But we have to ask whether this dream is possible â€” even whether it is desirable.
    The first-order paradigm does not deal adequately with negation in databases, and seems to be an unreliable guide in research on program correctness and language design.
    Inductive definitions are more fundamental than first-order logic, and perhaps easier to understand."
*** Books?
- 1995 book "Prolog Programming in Depth" http://www.lsv.fr/~reichert/Enseignement/2012/PPL/Prolog_Programming_In_Depth.pdf
  - 1.16 Styles of encoding knowledge, p. 28
    - parent, male, female vs. father, mother
    - "Which style is computationally more efficient depends on the kinds of queries to be answered."
    - "Unlike other knowledge representation languages, Prolog does not force the knowledge base builder to state information in a particular logical style.
      Information can be entered in whatever form is most convenient, and then appropriate rules can be added to retrieve the information in a different form."
    - "We could use a 'data-record' format to encode the family tree like [person(Name,Sex,Father,Mother)]"
      - "The only advantage of this style is that the multi-argument facts are often easy to generate from conventional databases,
        by simply printing out the data in a format that conforms to Prolog syntax."
  - 5.12 Grand Finale: Reading a Lotus Spreadsheet, p. 148
  - 5.13 Language and Metalanguage, p. 153
    - "A Prolog program can extend and modify the inference engine that controls program execution.
      Thus, the language can change itself in ways that go beyond superficial syntax."
      - Really? How?
  - 5.17 Intensional and Extensional Queries, p. 159
  - 5.19 Giving Meaning to Operators, p. 163
    - "How to make the ampersand mean 'and' in Prolog"
  - 5.20 Prolog in Prolog, p. 165
    - "Meta-interpreter for Prolog"
  - 5.21 Extending the inference engine, p. 167
    - biconditionals
  - 11 Defeasible Prolog, p. 347
    - 11.1 Nonmonotonic reasoning and Prolog, p. 347
      - "If our reasoning is monotonic, the set of conclusions we draw from the information we have only gets larger as we get more and more information.
        Once we reach a conclusion, no additional information will cause us to reject it.
        When our reasoning is nonmonotonic, we may reject an earlier conclusion on the basis of new information."
      - "Human reasoning is notoriously nonmonotonic. We make plans based on what we expect to happen,
        but we constantly revise our expectations, and our plans, as events unfold."
      - "The Prolog inference engine is nonmonotonic because of the way it handles negation."
      - Why is "defeasible" not spelled "defeatable"?
    - 11.2 New syntax for defeasible reasoning, p. 348
      - "Although Prolog can perform some kinds of nonmonotonic reasoning, Prolog rules are not defeasible."
      - "Some instances of defeasible reasoning cannot be reproduced in ordinary Prolog."
      - "What we need is a new way to represent defeasible rules and presumptions and
        an inference engine that knows how to use them. We also need a negation operator
        that is different from negation-as-failure so we can represent rules that tell us
        when something is positively not the case rather than just that we cannot /prove/ that it is the case.
        These negative rules are needed to tell us when we have an exception to a defeasible rule, but they are desirable in their own right as well."
        - The second sentence is too long.
    - (I haven't read it.)
** The things we have to know
This chapter should not exist.
The users have to know these, but when should we introduce these topics?
- operational semantics: how the Prolog program actually runs: depth-first search (brute force)
- how to get unstuck
*** Some Greek words used in philosophy and programming
"ontos" is "(of) being".

"episteme" is "knowledge".

"logos" is "word", "theory".

Thus, "ontology" is "theory of being", and "epistemology" is "theory of knowledge".
They are two branches of philosophy.
*** Modules?
Prolog syntax for use_module is documented in [[http://www.swi-prolog.org/FAQ/LoadLibrary.html][LoadLibrary FAQ]], not in the documentation for use_module/1.
The =library= alias is defined in file_search_path/2.

swipl: use =-s= instead of =-l=
http://www.swi-prolog.org/pldoc/man?section=cmdline
*** Equalities and equivalences?
What is the difference: =, ~==~, ~=:=~, is
** Drafts and archives of my correspondence with the Prolog community
*** Avoiding future SWI-Prolog pack nightmare
Semantic Web should be applied to make SWI-Prolog packs searchable and manageable.

SWI-Prolog packs need curation/vetting/testimony/promotion.
*** <2019-04-02> Draft: SWI-Prolog roadmap suggestion: A clash-free module system
**** About this draft
The target audience is the SWI-Prolog maintainer, Jan Wielemaker.

I wish to convince Jan that we must have a clash-free module system
so that we do not become the victim of our own success when Prolog becomes mainstream.

I wish to see such module system standardized and implemented.

Where should we publish this to?
- Post in SWI-Prolog Discourse group https://swi-prolog.discourse.group
- Open an issue in SWI-Prolog Roadmap https://github.com/SWI-Prolog/roadmap
**** The problem: We could be a victim of our own success if we don't act
We must standardize a clash-free module system before we have too many users.
Imagine that there were 10,000 SWI-Prolog packs: There would be naming conflicts.
We can learn from the Haskell community's complaints with Haskell's module system,
and do it right before it becomes too painful.
Let us prepare, so that we do not become a victim of our own success.
**** Criteria of a satisfactory solution
A solution is satisfactory iff many people can write many Prolog libraries without name clashes.
**** A possible solution
I am proposing these constraints:
- A file must not contain any module names/references.
- use_module/2 must ignore its first argument (the module name).
- Dependency must be specified by file paths and not module names.

I have a working code in [[https://github.com/edom/work/blob/master/software/boot/load.pro][boot/load.pro]].
It defines an =import/2= directive using =term_expansion/2=.
The loader generates module names.
An example usage looks like this:
#+BEGIN_EXAMPLE
:- import("somefile.pl",[
    pred/1
    , run/0 as somefile_run
]).
#+END_EXAMPLE
**** The semantics of the import/2 directive
The presence of an =:- import(Source, Specs)= in a file means that the file requires some things from Source.

Source may be:
- =file(Path)= where =Path= is a relative path to a file.
  This path is resolved against the file that contains the import/2 directive.

Specs is a list of Spec.

Spec may be:
- =Name/Arity=
- =Name/Arity as Alias=
- =multifile(Name/Arity)=: a "reverse-import"
- =multifiles(Preds)= where each Pred is a Name/Arity

Not yet implemented:
importing operators like SWI-Prolog 7.6.4 use_module/2.
#+BEGIN_EXAMPLE
use_module(..., [
    op(_,_,#<)
]).
#+END_EXAMPLE

One day someone may make it possible for Source to be =github(...)= or =pack(...)=,
but perhaps we should not do that because it will increase compilation time.
**** Other possibilities
This is only one possibility in the design space of clash-free modules.
Another solution is Logtalk.
There may also be other solutions.

Examples of other languages with clash-free module systems are JavaScript and TypeScript.
** Discourse is interesting
Discourse[fn::https://www.discourse.org] reputation system is an example of using software
to enforce a policy that creates a system that self-heals against attacks.

I should put it in my open-source page somewhere.
