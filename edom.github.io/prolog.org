#+TITLE: Relational-multidirectional-logic programming in production in SWI-Prolog
#+DATE: 2018-04-11 00:00 +0700
#+OPTIONS: ^:nil toc:nil
#+PERMALINK: /prolog.html
#+TOC: headlines 1
* Before you go full Prolog
#+TOC: headlines 2 local
** <2018-11-30> This is a book in progress! I don't know whether I will ever finish this.
** Let me warn you about the woes and blockers.
I'm selling you Prolog here, but let me be honest:
Don't buy it if any of these year-2018 deal-breakers are an issue for you.
Prolog isn't ready for these use cases in 2018; I hope these will change.

<2018-11-30>
No arrays.

<2018-11-30>
SWI-Prolog is honest:
"The main weakness of Prolog are algorithms that require destructive assignment,
intensive array processing or bare-metal performance for e.g., processing pixels."
http://www.swi-prolog.org/FAQ/PrologLAMP.txt

<2018-10-24>
There is no standard date/time/calendar library?
There may be one?
I'm still looking.
- Java 8 has "java.util.time"; previous Java versions can use "Joda Time".
- Haskell has the "time" package ("Data.Time" module).
** Let me hype you up.
(You can skip this.)

<2018-11-30>
Don't take this too seriously.
I'm on a honeymoon with Prolog.

Prolog is a /mind augmentation language/.
Prolog is a mental prosthesis.
With prosthetic arms, I can beat you in arm wrestling.
With prosthetic legs, I can beat you in running.
With prosthetic minds, I can beat you in thinking.
If logic is the language of thought, then Prolog is the closest thing we have to mind dump.
Offload your reasoning to computers.
As Leibniz said, "Let us calculate!"

You love Lisp macros?
Prolog has term_expansion/2, goal_expansion/2, op/2, and the infix operators that you have been dreaming of!

You love Haskell type system?
In Prolog you can write your own type systems!

You love C++ operator overloading?
In Prolog you can define your own operators with their precedences and associativities!

You want to beat/outdo/one-up your coworkers?
Prolog is perfect for that!
Unless you're low-level-programming,
Prolog is the secret weapon that multiplies your productivity by 20 compared to a low-level programming language such as C, C++, Java.
When you build your home, you don't build your own bricks.

Your coworkers are beating you with Prolog?
Well, what the hell are you waiting for?
Learn Prolog now, or lose your job and die in oblivion!

Things that I haven't found in Prolog:
the speed of C,
the toolchain of Go.
** Not sure yet? Try Prolog with minimal investment.
If you're not sure yet, I suggest that you
read [[https://www.metalevel.at/prolog][Markus Triska's book "The power of Prolog"]]
while doodling some code on [[http://pengines.swi-prolog.org/apps/swish/index.html][SWISH online Prolog interpreter]].
** Comparison of Prolog implementations
https://en.wikipedia.org/wiki/Comparison_of_Prolog_implementations

Comparison between SWI Prolog, YAP, GNU Prolog.
http://www.david-reitter.com/compling/prolog/compare.html

There are many Prolog implementations.
Some companies have their own Prolog implementations.

I use SWI-Prolog because it's what I use in university, and because of this [[http://www.swi-prolog.org/features.html][SWI-Prolog sales pitch]].

This book assumes that the reader uses SWI-Prolog 7.6.4.
* Using the interactive prompt
#+TOC: headlines 2 local
** <2018-10-20> Installing SWI-Prolog 7.6.4 on Ubuntu 14.04
If you are using Ubuntu 14.04, follow my instructions below.

If your operating system has packaged SWI-Prolog 7.6.4 or newer, use it.
(Thank you, volunteer package maintainers!)

If you aren't using Ubuntu 14.04, follow the [[http://www.swi-prolog.org/Download.html][official instructions]].
Choose the current stable release.

The following guide is for installing SWI-Prolog 7.6.4 on Ubuntu 14.04.

Uninstall existing SWI-Prolog installations.
The version packaged with Ubuntu 14.04 is too old (6.6.4).
SWI-Prolog 7 fixes a lot of issues with strings in SWI-Prolog 6.

Install dependencies.
I take this from the [[http://www.swi-prolog.org/build/Debian.html][Debian build instructions]] with these changes.
I replace =libunwind-dev= with =libunwind8-dev=.
I remove =openjdk-8-jdk= and =junit=.
I add =libreadline-dev=.
#+BEGIN_EXAMPLE
sudo apt-get install \
        build-essential autoconf curl chrpath pkg-config \
        ncurses-dev libreadline-dev libedit-dev \
        libunwind8-dev \
        libgmp-dev \
        libssl-dev \
        unixodbc-dev \
        zlib1g-dev libarchive-dev \
        libossp-uuid-dev \
        libxext-dev libice-dev libjpeg-dev libxinerama-dev libxft-dev \
        libxpm-dev libxt-dev \
        libdb-dev \
        libpcre3-dev \
        libyaml-dev \
        libreadline-dev
#+END_EXAMPLE

That doesn't include the documentation dependencies because they are too big.
Just read the documentation online.

After apt-get finishes, for security (avoiding sudo cache), close that terminal, and open a new one.

Download the [[http://www.swi-prolog.org/download/stable][source]].

Check the checksum using sha256sum.

=cp -p build.templ build=

=mkdir -p $HOME/.local=

Edit =build= script.
Set =PREFIX= to =$HOME/.local=.
Uncomment the =--link= option in =EXTRACFG= variable.

Run =./build=.
It should take a few minutes (about 5 minutes on my 4-core 8-GB-RAM machine).

Ensure that =$HOME/.local/bin= is in your =PATH=.
For example, I have this line somewhere near the end of my =~/.bashrc= file:
#+BEGIN_EXAMPLE
export PATH=$PATH:$HOME/.local/bin
#+END_EXAMPLE

If you edit your bashrc, close your terminal and open a new one.
Entering =swipl --version= should print this:
#+BEGIN_EXAMPLE
SWI-Prolog version 7.6.4 for x86_64-linux
#+END_EXAMPLE

If you don't want to edit your bashrc, you can run swipl by its full path =~/.local/bin/swipl=.

Tell SWI-Prolog to use readline.
Create a FILE containing this:
#+BEGIN_EXAMPLE
:- set_prolog_flag(readline, readline).
#+END_EXAMPLE

Add =-f FILE= switch to the command line you use to start =swipl=.
Related GitHub issue https://github.com/SWI-Prolog/issues/issues/72.
** Establishing workflow
=swipl -l FILE=

=:- [foo].= is shorthand for =:- consult(foo).=.
http://www.swi-prolog.org/pldoc/man?predicate=consult/1

We can enter temporary definitions from the prompt: =?- [user].=
Enter definitions.
End with a new line and Control+D.
** Interacting with SWI-Prolog
- To show the canonical representation of a term, query =write_canonical(Term)=.
- To show the source of a predicate, query =listing(Module:Name)= or =listing(Name)=.
** TODO <2018-11-30> Prolog needs static checking like Erlang Dialyzer.
SWI-Prolog has check library?

Is there a Prolog totality/determinism checker?

Prolog typechecking is vital to prevent stupid mistakes in a large knowledge base?

1997 inconclusive discussion "Prolog Type Checker"
https://dtai.cs.kuleuven.be/projects/ALP/newsletter/archive_93_96/net/typing/types.html
** How do I use SWI-Prolog?
- You write /rules/ in files.
  You write /queries/ in the query interpreter.
  - Pasting a file into the interpreter does /not/ load the file.
    - This is contrary to Lisp/Python/Ruby interpreters.
** SWI-Prolog, PostgreSQL, and ODBC
Install the Ubuntu 14.04 package =odbc-postgresql=.

I want my application to self-contain its configuration.
I don't configure ODBC INI files.

ODBC Data Source Name (DSN) connection string

Relevant commands: =odbcinst -j=

The file =/etc/odbcinst.ini= contains a list of driver names.
* Handling errors
#+TOC: headlines 2 local
** Fail, throw, stack traces
Two options: throw or fail.

If backtracking doesn't make sense, then throw, don't fail.

#+BEGIN_EXAMPLE
person(joe).
pair_first_second(pair(A,_), A, B).
#+END_EXAMPLE

Should =person(1)= fail or throw?
Should =pair_first_second(foo)= fail or throw?

Fail means try the next alternative.

If you want throw/1 with stack trace,
you must write it like =throw(error(Something, _))=.

A /function/ should always throw and not fail, when an argument has a wrong type.

#+BEGIN_EXAMPLE
negate(A,B) :- integer(A), !, B is -A.
negate(A,B) :- integer(B), !, A is -B.
negate(A,B) :- throw(error(negate(A,B),_)).
#+END_EXAMPLE
** Structured logging
This is how we log messages in Prolog:
- Design a term that represents the /meaning/ of the message.
- Call =print_message(Kind,Message)= where Message is that term.
- Extend =prolog:message//1= to translate that term to string.

#+BEGIN_EXAMPLE
% Syntax:
prolog:message(Term) --> Lines.

% Example:
prolog:message(Term) -->
    [ 'The term is ~q.'-[Term] ],
    [ 'This is the second line in the message.' ].
#+END_EXAMPLE

Syntax description:
- 'Lines' is a list of 'Line's.
  - A 'Line' has this shape:
    - Format-Args: 'Format' and 'Args' are the same arguments accepted by format/2.
    - Terms of other shapes are converted to string.

The printed message is the concatenation of all 'Line's.

TODO:
- How do we log to file?
- How do we rotate log files?

References:
- [[http://www.pathwayslms.com/swipltuts/message/index.html][Anne Ogborn's "Printing Messages in SWI-Prolog"]]
- http://www.swi-prolog.org/pldoc/man?section=printmsg
- http://www.swi-prolog.org/pldoc/man?section=debug

Usability issues:
- Where is =prolog:message//1= documented?
  I found that by trial-and-error.
- Why do we require people to understand DCG rules before they can use the messaging system?
* Writing elegant Prolog knowledge bases
#+TOC: headlines 2 local
** Prolog predicate parameter ordering convention: Order the parameters from the most likely to be bound
If parameter A is more likely to be more bound than parameter B, then A should come before B.
Example: Write list_length/2 instead of length_list/2.

Not everyone follows this convention.

** Don't multifile if clause order matters.
Reloading changes clause order.
http://www.swi-prolog.org/FAQ/Multifile.html
** Naming the parts of a list: head, tail, and butt
- "head" is the first element
- "tail" is everything but the head
- "butt" is the last element
** Total relational programming? Relational programs that can be proven to terminate?
A total relation is a relation that is defined for every element in its domain.

If there is total functional programming, then there should be total relational programming.

It is too easy to write a Prolog program that doesn't terminate.
** Prolog procedural semantics
*** Swapped phrases
There is only a small syntactic difference between =dfs= and =bfs= (it's just flipped order).

Which one exploits tail call optimization (last call optimization)?
#+BEGIN_SRC prolog
bit(0).
bit(1).

dfs([]).
dfs([H|T]) :- bit(H), dfs(T).

bfs([]).
bfs([H|T]) :- bfs(T), bit(H).
#+END_SRC
*** Understanding depth-first search, backtracking, choice points, performance, and cuts
Save this knowledge base into a file, and load it into Prolog.
#+BEGIN_SRC prolog
a(0).
a(1).

b(0).
b(1).
#+END_SRC

Run the query =a(A), b(B).= and press =;= until Prolog fails.

This is what Prolog finds (we remove the newlines to make it more readable):
#+BEGIN_EXAMPLE
A = B, B = 0 ;
A = 0, B = 1 ;
A = 1, B = 0 ;
A = B, B = 1.
#+END_eXAMPLE

This is the search space (search tree) of that query.
#+BEGIN_EXAMPLE
       ?- a(A), b(B).
      /              \
    A = 0           A = 1
   /     \         /     \
B = 0   B = 1   B = 0   B = 1
#+END_EXAMPLE

Prolog traverses that tree in depth-first order as follows:
#+BEGIN_EXAMPLE
- ?- a(A), b(B).
  - A = 0
    - B = 0
    - B = 1
  - A = 1
    - B = 0
    - B = 1
#+END_EXAMPLE

The important things to infer from this experiment are:
- Prolog repeats the work on =b= as many times as the number of ways of satisfying =a=.
  If =a= can be satisfied in N ways, and satisfying =b= is a lot of work,
  then Prolog may do that work N times,
  although the work produces the same result.
- Everything to the right of an infinite branch will never be visited.

What is a choice point?

A cut makes =a(A), b(B)= and =b(B), a(A)= return different results.

How far does a cut cut?

"The craft of Prolog" defines three kinds of cuts: red, green, and blue.
- A red cut destroys the logical meaning of a program.
  Green and blue cuts don't.
*** Prolog is a depth-first brute-forcer
But you can emulate other search algorithms too.
**** Non-termination pitfalls, and how to generate terms correctly
Sometimes we forget that Prolog, on failure, backtracks (retries), not stops.

Sometimes we focus too much on the logical reading and neglect the procedural reading.

For example, suppose that you want to generate all lists whose length doesn't exceed 2.

The following is a mathematically correct statement about that fact,
but it doesn't work in Prolog.
It has correct logical reading, but incorrect procedural reading.
If you keep pressing =;=, this will fail to terminate.
#+BEGIN_SRC prolog
?- length(A, LA), LA =< 2.
#+END_SRC

The correct way to do that is to use =between/3= (inclusive):
#+BEGIN_SRC prolog
?- between(0, 2, LA), length(A, LA).
#+END_SRC

We can also use the =clpfd= library:
#+BEGIN_SRC prolog
:- use_module(library(clpfd)).

?- LA in 0..2, indomain(LA), length(A, LA).
#+END_SRC

We shouldn't have to resort to cuts:
#+BEGIN_SRC prolog
% Don't do this.
?- length(A, LA), (LA =< 2 -> true; !, fail).
#+END_SRC

See also:
- https://www.metalevel.at/prolog/nontermination
  - "[Non-termination is] common among beginners, and often lead them to perceive Prolog as 'slow', when in fact their program does not terminate /at all/."
** Which string representation should I use?
*** The answer: Dedicated double-quoted string type (SWI-Prolog 7)
- "Strings are distinct from lists" http://www.swi-prolog.org/pldoc/man?section=strings
- "Why has the representation of double quoted text changed?" http://www.swi-prolog.org/pldoc/man?section=ext-dquotes-motivation
- 2013 article "Strings in ECLiPSe 6.2, SWI-7 and YAP" http://eclipseclp.org/wiki/Prolog/Strings
  - "With SWI-7 and ECLiPSe 6.2 string support has been harmonized, and YAP is expected to agree as well."
  - "Agreed Common Functionality"
  - "Situation before December 2013"
*** Non-answers
**** Edinburgh style: Double-quoted string as list of integer codes (default mode of SWI-Prolog 6.6.4 on Ubuntu 14.04)
- A Unicode character is represented as an integer that is the code of that character.
- A string is represented as a list of codes.
  Example: ="aaa" = [97,97,97]=.
- Inconvenient to debug.
- This behavior changes in SWI-Prolog 7.
- This was in 1993 ISO standard draft. http://fsl.cs.illinois.edu/images/9/9c/PrologStandard.pdf
  - This wasn't in the final version?
**** Double-quoted string as list of one-character atoms
- A Unicode character is represented as a one-character atom.
- A string is represented as a list of one-character atoms.
  Example: ="aaa" = [a,a,a]=.
- This assumes that the Prolog implementation garbage-collects atoms.
- More convenient to debug.
** Warnings are errors!
** TODO debugging: spy/1, tspy/1, trace/0, gtrace/0, notrace/0, debug/0, nodebug/0; stepping: creep, skip, and leap
debug/0 disables optimizations.

Fixing programming errors:
- https://www.cs.ucsb.edu/~kyledewey/cs162w15/debugging_prolog.html
- http://www.swi-prolog.org/pldoc/man?section=debugoverview
  - Type =/f= in the tracer prompt to run to the next failure.

Singleton variables most likely mean there's a typo.
* Speeding things up
** Profiling: finding where your program spends time; finding where it is slow; diagnosing slowness
To run your =Goal= with profiling, simply query =profile(Goal)=.

Profiling couldn't be any simpler than this!
* Where things get ugly
** Functional/expression style sometimes beats relational/unification style
#+BEGIN_EXAMPLE
-- Functional/expression style
g (f0 x0) (f1 x1) (f2 x2)

% Relational/unification style
f0(X0, Y0), f1(X1, Y1), f2(X2, Y2), g(Y0, Y1, Y2, Z).
#+END_EXAMPLE
Example where functional style wins:
- string formatting
- number crunching

If backtracking isn't involved, functional style wins (is more concise than relational style).

If computation is reversible, relational style wins (half the amount of code of functional style).

We should use both styles depending on circumstances.

We can define a functional/expression/applicative/evaluative sublanguage in Prolog, roughly like this:

#+BEGIN_SRC prolog
eval((A = B), Val) :- A = B, eval(B, Val), !.
eval(F, Val) :- callable(F), call(F, Val), !. % lots of hand-waving here
% etc.
#+END_SRC

Haskell is weak against the AST decoration problem.
Dynamic languages (Scheme, JavaScript, Prolog) / gradual-typed languages (TypeScript) beat static languages (Haskell) on the AST decoration problem.
How about Ocaml polymorphic variants?

Should we move from Prolog to Scheme/miniKanren or Mercury?
** Directives like =:- op= complicate parsing a Prolog source code.
** Zero-arity compound term
Use compound_name_arity/3 instead of functor/3, but this seems to be an SWI-Prolog extension.

http://www.swi-prolog.org/pldoc/man?section=ext-compound-zero
* Writing enterprise web applications?
** Comparison between ontology, relational programming, and database programming
Open World Assumption vs Closed World Assumption http://www.mkbergman.com/852/the-open-world-assumption-elephant-in-the-room/

How do we combine closed-world assumption (logic programming / relational database) and open-world assumption (web ontology)?
** Knowledge representation and software specification
*** Their relationships
- 2010, "Functional-Logic Programming Lecture Notes", Harold Boley, slides, [[http://www.cs.unb.ca/~boley/FLP/cs6905FLP.pdf][pdf]]
  - Knowledge representation in AI roughly corresponds to software specification in software engineering.
  - Declarative programs can be thought as executable specifications.
  - Invertibility principle (slide 36)
  - Nesting/conjunction principle (slide 46)
  - Unification principle (slide 50)
  - Amalgamation/integration principle (slide 55)
  - That's a long deck: 270 slides.
*** Executable specification?
- lightweight executable mathematics https://www.cl.cam.ac.uk/~pes20/lem/

** Logic programming vs theorem proving
- https://stackoverflow.com/questions/36335633/difference-between-logic-programming-and-automated-theorem-proving
- https://en.wikipedia.org/wiki/Automated_theorem_proving


* Theories
** Embedding Prolog/Haskell in Haskell/Prolog
*** Embedding Prolog in Haskell
- 1999 article "Embedding Prolog in Haskell" https://pdfs.semanticscholar.org/7c46/5d25205830735d0a034532746b7243221eca.pdf
  - "We propose an embedding of logic programming into lazy functional programming
    in which each predicate in a Prolog program becomes a Haskell function,
    in such a way that both the declarative and the procedural reading of the Prolog predicate are preserved."
- 1988 article "Towards functional programming in Prolog" ftp://obaluae.inf.puc-rio.br/pub/docs/Publications/88_AI_Furtado_SINPLAN.Not.pdf
*** Embedding Haskell in Prolog: Nobody is talking about this.

** How are Prolog and Lisp similar?
- Both Prolog and Lisp have symbols and cons cells.
  - This is a Lisp cons cell: =(cons 'a 'b)= or ='(a . b)=.
  - This is the corresponding SWI-Prolog cons cell: =[a|b]= (the canonical form is ='[|]'(a,b)=).
- Both have macros.
  - Lisp has defmacro.
  - Prolog has term_expansion/2 and goal_expansion/2.

I'd say Prolog = Lisp + unification + backtracking - lambda.

** Comparison between what is difficult in various programming languages
- 2014 presentation "That scripting language called Prolog" https://www.slideshare.net/SergeiWinitzki/prolog-talk
  - It compares what is difficult in various programming languages.
  - It defines "declarative": 'Programming is "declarative" when /specifications are programs/.'
    - Slide 29: "declarative programming = creating a good DSL for your domain"
  - Slide 24 compares SQL, Datalog, and Prolog.

** Comparison with other relational programming languages
Comparison with miniKanren:
- https://stackoverflow.com/questions/28467011/what-are-the-main-technical-differences-between-prolog-and-minikanren-with-resp
  - William E. Byrd's answer:
    - Prolog is practical; miniKanren is pure.
    - Prolog unification doesn't use occurs check; miniKanren unification uses occurs check.
    - Prolog uses depth-first search; miniKanren uses complete interleaving search.
    - '[...] miniKanren is being used for research in "relational" programming.'
    - "Over time miniKanren has added more symbolic constraints, really becoming a symbolically-oriented Constraint Logic Programming language."
    - "There are other very interesting logic programming languages as well, such as Mercury, Curry, and Gödel, each of which has its own take on logic programming."

Mercury vs Prolog
- http://lambda-the-ultimate.org/node/890
- <2018-10-21> "The Prolog to Mercury transition guide" https://www.mercurylang.org/information/doc-latest/transition_guide.pdf

SQL? Datalog?

** Two camps in programming
There are two camps in programming:
the bottom-up camp and the top-down camp.

The bottom-up camp starts from machines and goes up toward mathematics.
This camp produces Assembly, Fortran, Cobol, Pascal, C, C++, Go.
This camp produced fast but ugly implementations.
Haphazard incremental improvements.

The top-down camp starts from mathematics and goes down toward machines.
This camp produces Lisp, Scheme, Prolog, ML, Ocaml, Haskell, Coq, Idris, Agda, Lean.
This camp produced elegant but slow implementations.
Big design up front.

They seem to be converging to a middle ground: ugly and slow.

Why can't we get fast and elegant?
* TODO Half-baked things to shuffle around
#+TOC: headlines 2 local
** Defining your own operators
- =:- op(Precedence, Type, Name)=
** Meta-programming
- To define 'macros', use =term_expansion= or =goal_expansion=.
** Use clpfd #=/2 instead of is/2?
But it's good to have minimal dependencies.
** Difference lists
- Who invented difference lists when?

A "difference list" is a term of the form =A - B= where =A= is a list and =B= is a list.

A difference list represents a list.

The difference list =A - []= represents the list =A=.

- https://en.wikipedia.org/wiki/Difference_list
- https://en.wikibooks.org/wiki/Prolog/Difference_Lists
  - Difference list has constant-time append.
    Ordinary list has linear-time append.
- https://wiki.haskell.org/Difference_list
  - "Whether this kind of difference list is more efficient than another list representations depends on usage patterns."
- http://homepages.inf.ed.ac.uk/pbrna/prologbook/node180.html
** What? 99 Prolog problems?
- 99 Prolog problems http://www.ic.unicamp.br/~meidanis/courses/problemas-prolog/
** Iterative deepening search with length/1
Prolog uses depth-first search.
It isn't complete.
(What does that mean?)

If you have a query =goal(List)= where =List= is a list,
then you can query =length(List, _), goal(List)= to make the search complete.

https://en.wikibooks.org/wiki/Prolog/Search_techniques
** <2018-10-20> How do we make sense of this counterintuitive module syntax?
- https://stackoverflow.com/questions/42399020/how-to-get-a-listing-of-a-specific-knowledge-base
** Discover the wonderful world of Prolog / logic programming / relational programming
*** Symbolic AI is the easiest AI approach.
- Connectionist AI (neural networks) excels at tasks that are difficult to describe in formal logic.
- Symbolic AI (Prolog) is much more understandable and predictable than connectionist AI.
  - Understanding connectionist AI requires probability, statistics, and real analysis.
- Why not both?
  2017 article "SLDR-DL: A Framework for SLD-Resolution with Deep Learning" https://arxiv.org/pdf/1705.02210.pdf?
*** Dreams
- offload/scale/formalize thinking/cognition
- transform reasoning into data entry
- brain prosthetics; cognitive prosthetics
- Leibniz, "Let us calculate!", calculus ratiocinator
  - https://en.wikipedia.org/wiki/Calculus_ratiocinator
  - https://publicdomainreview.org/2016/11/10/let-us-calculate-leibniz-llull-and-computational-imagination/
- probabilistic logic programming
- https://softwareengineering.stackexchange.com/questions/275680/the-dream-of-declarative-programming
** Reminder for those who already know
Elucidating
https://en.wikipedia.org/wiki/Prolog_syntax_and_semantics
** Making compilers
- https://www.reddit.com/r/ProgrammingLanguages/comments/9em9jf/future_directions_for_optimizing_compilers/
  - "Future Directions for Optimizing Compilers" https://arxiv.org/abs/1809.02161

"Universal-transpiler" may be similar to what we want.

- "Universal-transpiler"
  - https://github.com/jarble/transpiler
    - it also has links to similar projects
  - http://www.swi-prolog.org/pack/list?p=transpiler
** Declarative programming languages
[[http://www.cse.chalmers.se/~oloft/Papers/wm96/node2.html][Declarative Programming Languages]], functional logic programming, two ways it is done (narrowing and residuation);
definitional programming, GCLA language (separate definition and control)

- 1995, "Functional Logic Programming in GCLA", [[http://www.cse.chalmers.se/~oloft/Papers/wm95.pdf][pdf]]
** Speculative
*** Fast logic programming?
- https://www.reddit.com/r/ProgrammingLanguages/comments/9fgv3v/can_logic_programming_execute_as_fast_as/
  - https://www.info.ucl.ac.be/~pvr/Peter.thesis/Peter.thesis.html
- https://stackoverflow.com/questions/23711790/comparision-of-abstract-machines-for-execution-of-prolog
*** Lambda-prolog?

- lambda-prolog http://www.lix.polytechnique.fr/~dale/lProlog/
** Resources
*** For beginners
*** Not for beginners
- 1990 book "The craft of Prolog" by Richard A. O'Keefe
  - from the preface:
    "There are a lot of introductory Prolog books around.
    This is not one of them.
    Think of it as "second steps in Prolog".
    If you have already read one of the introductory books, if you have taken an introductory course on Prolog, if you have written one or two Prolog programs, and if you are wondering why it is still hard to writegood Prolog programs, this book is meant to help you.
    The purpose of the book is to show you how you can write Prolog programs that work, that don't take an unreasonable amount of time, and that are clean enough to show to your friends."
** What?
*** P# translates Prolog to C#.
https://pdfs.semanticscholar.org/12ec/568a6583d3d66b6821f28269f06937a9f2eb.pdf
*** "Real World Programming in SWI-Prolog"
http://www.pathwayslms.com/swipltuts/index.html
*** "Frequently Asked Questions for ##Prolog"
http://www.pathwayslms.com/swipltuts/student/
*** What are these trying to say?
- 1991 article "Logic Programming, Functional Programming, and Inductive Definitions" https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-205.pdf
  - "The unification of logic and functional programming, like the Holy Grail, is sought by countless people"
  - "More generally, we suggest that the traditional paradigm — logic programming as first-order logic — is seriously out of step with practice.
    We offer an alternative paradigm. We view the logic program as an /inductive definition/ of sets and relations."
  - "To justify the Closed World Assumption, we propose that logic programs should be viewed as inductive definitions, not as first-order theories.
    Some people refuse to abandon the dream of programming in first-order logic.
    But we have to ask whether this dream is possible — even whether it is desirable.
    The first-order paradigm does not deal adequately with negation in databases, and seems to be an unreliable guide in research on program correctness and language design.
    Inductive definitions are more fundamental than first-order logic, and perhaps easier to understand."
*** Books?
- 1995 book "Prolog Programming in Depth" http://www.lsv.fr/~reichert/Enseignement/2012/PPL/Prolog_Programming_In_Depth.pdf
  - 1.16 Styles of encoding knowledge, p. 28
    - parent, male, female vs. father, mother
    - "Which style is computationally more efficient depends on the kinds of queries to be answered."
    - "Unlike other knowledge representation languages, Prolog does not force the knowledge base builder to state information in a particular logical style.
      Information can be entered in whatever form is most convenient, and then appropriate rules can be added to retrieve the information in a different form."
    - "We could use a 'data-record' format to encode the family tree like [person(Name,Sex,Father,Mother)]"
      - "The only advantage of this style is that the multi-argument facts are often easy to generate from conventional databases,
        by simply printing out the data in a format that conforms to Prolog syntax."
  - 5.12 Grand Finale: Reading a Lotus Spreadsheet, p. 148
  - 5.13 Language and Metalanguage, p. 153
    - "A Prolog program can extend and modify the inference engine that controls program execution.
      Thus, the language can change itself in ways that go beyond superficial syntax."
      - Really? How?
  - 5.17 Intensional and Extensional Queries, p. 159
  - 5.19 Giving Meaning to Operators, p. 163
    - "How to make the ampersand mean 'and' in Prolog"
  - 5.20 Prolog in Prolog, p. 165
    - "Meta-interpreter for Prolog"
  - 5.21 Extending the inference engine, p. 167
    - biconditionals
  - 11 Defeasible Prolog, p. 347
    - 11.1 Nonmonotonic reasoning and Prolog, p. 347
      - "If our reasoning is monotonic, the set of conclusions we draw from the information we have only gets larger as we get more and more information.
        Once we reach a conclusion, no additional information will cause us to reject it.
        When our reasoning is nonmonotonic, we may reject an earlier conclusion on the basis of new information."
      - "Human reasoning is notoriously nonmonotonic. We make plans based on what we expect to happen,
        but we constantly revise our expectations, and our plans, as events unfold."
      - "The Prolog inference engine is nonmonotonic because of the way it handles negation."
      - Why is "defeasible" not spelled "defeatable"?
    - 11.2 New syntax for defeasible reasoning, p. 348
      - "Although Prolog can perform some kinds of nonmonotonic reasoning, Prolog rules are not defeasible."
      - "Some instances of defeasible reasoning cannot be reproduced in ordinary Prolog."
      - "What we need is a new way to represent defeasible rules and presumptions and
        an inference engine that knows how to use them. We also need a negation operator
        that is different from negation-as-failure so we can represent rules that tell us
        when something is positively not the case rather than just that we cannot /prove/ that it is the case.
        These negative rules are needed to tell us when we have an exception to a defeasible rule, but they are desirable in their own right as well."
        - The second sentence is too long.
    - (I haven't read it.)
