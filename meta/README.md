# Metaprogramming

- Subcontents
    - [Make a programming language](doc/lang.md)
- Goals
    - Write a metaprogram in Haskell to generate a Java 8 enterprise web application.
        - What we mean by "enterprise web application":
            - User uses web browser to interact with the application.
            - Lots of CRUD (Create, Read, Update, Delete).
            - Some business logic.
            - Used internally in a small company.
            - Less than 100 users.
        - What we don't mean by "enterprise web application":
            - Java Enterprise Edition (Java EE), except Servlet API.
    - Reverse-engineer an obfuscated Java 6 application.
        - Approach:
            - Transform Java bytecode into something related to lambda calculus.
            - Simplify (optimize) the representation.
            - Transform it back into Java bytecode.
    - Create an abstract programming language that can represent the semantics of all programming languages.
        - Use it to translate programs across programming languages.
        - Similar to Pandoc but for programming languages.
- Assumptions
    - The user of this library is programmer / developer / software engineer.
    - Small changes are more likely to be accepted and persisted than big changes.
- Directory structure
    - Non-generated files
        - `src`: Haskell source files
        - `rt`: runtimes
            - `java`: Java runtime
        - `har`: harness for running example application
            - the non-generated part of the examples
    - Generated files
        - `src1`: stage-1 Haskell source files
- Plans
    - Small changes that are likely to be accepted.
        - Generate Java entity class from PostgreSQL information_schema or DDL statements.
            - Decision:
                - Parse DDL statements, don't connect to database.
            - Choose:
                - Parse SQL DDL statements from a file (manually written, or dumped from database).
                    - Pros:
                        - More secure: The program doesn't need the database credentials.
                    - Cons:
                        - Need to write an SQL parser.
                - Connect to database.
                    - Pros:
                        - Doesn't need SQL DDL file.
                            - But the DDL file can be generated easily from the database anyway ("dump schema" option).
                    - Cons:
                        - How standard is information_schema?
    - Add a type parameter to Query.
    - Pretty URL (URL path component instead of GET parameters)?
    - Refactoring, maintainability/usability improvements
        - Make Meta.Xml use Meta.WrapM
    - Absorb haji, pragmatic, ptt.
    - Do we want this?
        - change deploy script
            - build on developer machine
        - describe tables in Relat
        - CUD (create, update, delete) of CRUD
        - servlet: basic auth
        - dto: auto-jackson
        - dto: Api req/res Dto includes write and read to json using jackson core without databind; collect those static methods in 1 class
        - dto: Backend, Android, and iOS dto generation
        - java: compile-time design pattern (mixin, delegation, decorator)
            - requires reading java class to delegate all public instance methods
            - requires reading java source for mixin
        - derive web view from database table (from hs, not sql)
            - query description language Query, basically Linq
                - assume cross-server query ("federation")
                    - https://en.wikipedia.org/wiki/Federated_database_system
                    - assume different database servers
                    - assume different database vendors
                    - a Table must know its "location"/"type"/"source type"/"access method",
                    to determine what code is generated to query it.
                        - decide terminology: "source type"? "access method"? "source alias"?
                            - Examples of access methods: postgresql, mysql, in-application.
                        - how to access the table:
                            - what code to generate for query
                            - where the table is (where to connect to)
                                - how to find out where to connect to
                                    - hardcoded in the application
                                    - read from file at runtime, not in version control
                                    - by a variable passed by harness
                    - assume that a data source is an Iterable<Object[]>?
                        - Linq assumes that every table is a Sequence?
                - https://www.devart.com/dotconnect/postgresql/articles/tutorial_linq.html
            - view description language View
                - VAutoFromQuery :: Query -> View
            - try-with-resources: JavaSta, JavaRender
            - begin with dump all
            - then add pagination (offset, limit)
            - then add conjunctive-normal-form filter
        - fix auto-increment column ddl, limit to int16, int32, and int64 (smallserial, serial, bigserial)
        - embed lambda calculus in Query?
        - user experience
            - read from XML? YAML?
        - Generate XSD from Haskell record so that IDEA can autocomplete?
            - incorporate UUXML? But that's from XSD to Haskell. We want from Haskell to XSD.
                - http://wiki.di.uminho.pt/twiki/pub/Education/Archive/XMLtoSQLConversionToolAFPProject/padl04.pdf
        - Standardize C project build and layout?
