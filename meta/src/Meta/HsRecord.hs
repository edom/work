{- |
* See also:

    * the \"record\" library on Hackage

        * http://nikita-volkov.github.io/record/
-}
module Meta.HsRecord where

import qualified Data.Char as DC
import qualified Meta.HsDat as D
import qualified Meta.HsMod as M
import qualified Meta.HsType as T

-- * Constructors

type Der = T.SymCls

type TyParam = T.VarName

mkRecord :: T.ModName -> T.TypName -> [Field] -> Record
mkRecord mn tn fs = defRecord {
        rModName = mn
        , rName = tn
        , rConName = "Mk" ++ tn
        , rFields = fs
    }

getterCamel :: Field -> Field
getterCamel fld = fld {
        fGetterName = Just $ "get" ++ upfirst (fName fld)
    }

getterSnake :: Field -> Field
getterSnake fld = fld {
        fGetterName = Just $ "get_" ++ fName fld
    }

setterCamel :: Field -> Field
setterCamel fld = fld {
        fSetterName = Just $ "set" ++ upfirst (fName fld)
    }

setterSnake :: Field -> Field
setterSnake fld = fld {
        fSetterName = Just $ "set_" ++ fName fld
    }

{- |
Output:

@
module Mod where

data Rec = MkRec {
        field1 :: type1
        , field2 :: type2
        , ...
    }

-- Getters
getField1 :: Rec -> type1
getField2 :: Rec -> type2
...

-- Setters
setField1 :: type1 -> Rec -> Rec
setField2 :: type2 -> Rec -> Rec
...
@
-}
generateModule :: Record -> M.Module
generateModule rec = M.mkModule modName $ preamble ++ dat ++ getters ++ setters
    where
        preamble = [
                M.LineComment $ " Generated by Meta.HsRecord.generateModule for record " ++ rQualName rec
            ]
        dat = rDat rec
        modName = rModName rec
        fields = rFields rec
        getters = [ g | f <- fields, Just nam <- [fGetterName f], g <- mkGetter rec f nam ]
        setters = [ s | f <- fields, Just nam <- [fSetterName f], s <- mkSetter rec f nam ]

-- * Internals

setPars :: [TyParam] -> Record -> Record
setPars p r = r { rTyParams = p }

setDers :: [Der] -> Record -> Record
setDers d r = r { rDers = d }

upfirst :: String -> String
upfirst "" = ""
upfirst (h : t) = DC.toUpper h : t

rDat :: Record -> [M.Member]
rDat rec = [
        M.LineComment $ " Generated by Meta.HsRecord.rDat for " ++ rQualName rec
        , M.MDat $ D.empty {
                D.dName = rName rec
                , D.dPars = rTyParams rec
                , D.dCons = [D.conRec (rConName rec) cFields]
                , D.dDers = rDers rec
            }
    ]
    where
        fields = rFields rec
        rtoc :: Field -> (T.VarName, T.Type)
        rtoc fld = (fName fld, fType fld)
        cFields = map rtoc fields

mkGetter :: Record -> Field -> T.VarName -> [M.Member]
mkGetter rec fld name = [
        M.LineComment $ " Generated by Meta.HsRecord.mkGetter for record " ++ rQualName rec ++ " field " ++ fName fld
        , M.Dec name tGet
        -- TODO Def
    ]
    where
        tFld = fType fld
        tRec = rType rec
        tGet = tRec `T.Arr` tFld

mkSetter :: Record -> Field -> T.VarName -> [M.Member]
mkSetter rec fld name = [
        M.LineComment $ " Generated by Meta.HsRecord.mkSetter for record " ++ rQualName rec ++ " field " ++ fName fld
        , M.Dec name tSet
        -- TODO Def
    ]
    where
        tFld = fType fld
        tRec = rType rec
        tSet = tFld `T.Arr` tRec `T.Arr` tRec

data Record
    = MkRecord {
        rModName :: T.ModName
        , rName :: T.TypName
        , rTyParams :: [T.VarName]
        , rConName :: T.ConName
        , rFields :: [Field]
        , rDers :: [T.SymCls]
    } deriving (Read, Show)

rQualName :: Record -> T.QualName
rQualName r = T.sQualName $ rSym r

rSym :: Record -> T.SymTyp
rSym r = T.MkSym (rModName r) (rName r)

rType :: Record -> T.Type
rType rec = T.appMany (T.val modName name) (map T.Var pars)
    where
        name = rName rec
        modName = rModName rec
        pars = rTyParams rec

defRecord :: Record
defRecord = MkRecord {
        rModName = ""
        , rName = ""
        , rTyParams = []
        , rConName = ""
        , rFields = []
        , rDers = []
    }

data Field
    = MkField {
        fName :: T.ConName -- ^ plain name, not including clash-avoiding prefix
        , fType :: T.Type
        , fPrefix :: T.VarName -- ^ clash-avoiding prefix
        , fGetterName :: Maybe T.VarName
        , fSetterName :: Maybe T.VarName
    } deriving (Read, Show)

defField :: Field
defField = MkField {
        fName = ""
        , fType = T.val "Prelude" "()"
        , fPrefix = ""
        , fGetterName = Nothing
        , fSetterName = Nothing
    }

mkField :: T.VarName -> T.Type -> Field
mkField nam typ = defField { fName = nam, fType = typ }
