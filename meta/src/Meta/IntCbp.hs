{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE TypeSynonymInstances #-}

module Meta.IntCbp where

import qualified Meta.Java as J
import qualified Meta.JavaType as JT
import qualified Meta.Prop as P
import qualified Meta.RdbCol as RC
import qualified Meta.Relat as R

import Meta.Prop ((|>))

-- * Type

data Type
    = TUnit -- ^ unit type
    | TNat8 -- ^ unsigned 8-bit integer
    | TInt8 -- ^ two's-complement 8-bit signed integer
    | TInt32 -- ^ two's-complement 32-bit integer
    | TInt64 -- ^ two's-complement 64-bit integer
    | TString -- ^ string (character sequence)
    | TArray Type Int -- ^ fixed-length array
    | TClass Class -- ^ aggregate
    | TPointer Type -- ^ pointer
    | TNullablePtr Type -- ^ nullable pointer
    deriving (Read, Show)

-- * Class

-- | Simple name, without package.
type Class_name = String

data Class
    -- | Internal. Do not use. Use 'defClass'.
    = MkClass {
        cPkg :: String -- ^ package
        , cName :: Class_name -- ^ simple name (name without package)
        , cParents :: [Class]
        , cMembers :: [Member]
        , cAbstract :: Bool
    } deriving (Read, Show)

defClass :: Class
defClass = MkClass {
        cPkg = ""
        , cName = ""
        , cParents = []
        , cMembers = []
        , cAbstract = False
    }

get_class_name :: Class -> Class_name
get_class_name = cName

set_class_name :: Class_name -> Class -> Class
set_class_name n c = c { cName = n }

map_class_name :: (Class_name -> Class_name) -> Class -> Class
map_class_name f c = set_class_name (f $ get_class_name c) c

-- * Class member

data Member
    = MField Field
    | MMethod Method
    | MProp Prop
    | MLineComment String
    | MBlockComment String
    deriving (Read, Show)

data Field = MkField {
        fType :: Type
        , fName :: String
    } deriving (Read, Show)

data Method
    -- | Internal. Do not use. Use 'defMethod'.
    = MkMethod {
        mRet :: Type
        , mName :: String
        , mParams :: [Param]
        , mStatic :: Bool -- ^ true means has no implicit first parameter
        , mAbstract :: Bool -- ^ true means has no body
        , mVirtual :: Bool -- ^ true means overrideable; false means final
        , mOverride :: Bool -- ^ true means this method is expected to override an overrideable method in a parent
        , mBody :: [Sta]
    } deriving (Read, Show)

data Prop
    = MkProp {
        prType :: Type -- ^ Internal. Do not use. Use 'P.getType' and 'P.setType'.
        , prName :: String -- ^ Internal. Do not use. Use 'P.getName' and 'P.setName'.
    } deriving (Read, Show)

instance P.GetName Prop String where getName = prName
instance P.SetName Prop String where setName n p = p { prName = n }
instance P.GetType Prop Type where getType = prType
instance P.SetType Prop Type where setType t p = p { prType = t }

data Param = MkParam {
        pType :: Type
        , pName :: String
    } deriving (Read, Show)

defMethod :: Method
defMethod = MkMethod {
        mRet = TUnit
        , mName = ""
        , mParams = []
        , mStatic = False
        , mAbstract = False
        , mVirtual = False
        , mOverride = False
        , mBody = []
    }

-- * Statement

data Sta
    = SExp Exp -- ^ expression statement
    | SRet Exp -- ^ return statement
    | SDecl Type String -- ^ variable declaration statement
    | SAssign String Exp -- ^ assignment statement
    deriving (Read, Show)

-- * Expression

-- | Embedded lambda calculus.

data Exp
    = EConUnit
    | EConInt Integer
    | EConStr String
    | EConDbl Double
    | EPlus Exp Exp
    | EIf Exp Exp Exp -- ^ EIf condition truePart falsePart
    | EDot Exp Exp -- ^ dot (member access) expression
    | ECall Exp [Exp] -- ^ call expression
    deriving (Read, Show)

-- * Generate DTO (Data Transfer Object) class from relational database table

-- | Configuration for 'genDto'.
data GenDto
    -- | Internal. Do not use. Use 'defGenDto'
    = MkGenDto {
        gdCommentField :: Bool -- ^ Whether to comment every field.
        , gdImmutable :: Bool -- ^ Whether to make every field const/final.
    } deriving (Read, Show)

-- | Default configuration for 'genDto'.
defGenDto :: GenDto
defGenDto = MkGenDto {
        gdCommentField = False
        , gdImmutable = False
    }

gen_dto :: R.Table -> Class
gen_dto = genDtoWith defGenDto

-- TODO generate getter methods
-- TODO generate setter methods
-- TODO generate 0-param constructor
-- TODO generate n-param constructor
-- TODO make every field private
genDtoWith :: GenDto -> R.Table -> Class
genDtoWith conf table = defClass {
        cName = tabName
        , cMembers = [
            MLineComment $ " Generated by Meta.IntCbp.genDto from table \"" ++ tabName ++ "\"."
        ] ++ concatMap mapCol cols
    }
    where
        tabName = R.tName table
        cols = R.tCols table
        wantCommentField = gdCommentField conf
        mapCol :: RC.Col -> [Member]
        mapCol col =
            if wantCommentField
                then [comment, field]
                else [field]
            where
                comment = MLineComment $ " Column \"" ++ colName ++ "\" (" ++ show typ ++ ")."
                field = MField (MkField (mapType typ) colName)
                typ = RC.getType col
                colName = RC.getName col
                mapType :: RC.Type -> Type
                mapType ty = case ty of
                    RC.TInt32 -> TInt32
                    RC.TInt64 -> TInt64
                    RC.TVarChar _ -> TString
                    _ -> error $ "genDto.mapCol.mapType: not implemented: " ++ show ty

-- * Transform to Java

toJavaType :: Type -> JT.Type
toJavaType typ = case typ of
    TInt32 -> JT.Int32
    TInt64 -> JT.Int64
    TString -> JT.string
    _ -> error $ "Meta.IntCbp.javaType: not implemented: " ++ show typ

toJavaClass :: Class -> J.Class
toJavaClass cls =
    J.defClass { J.cPkg = pkg, J.cMembers = concat mem }
    |> P.setName name
    where
        mem = toJavaMember <$> cMembers cls
        pkg = cPkg cls
        name = cName cls

toJavaMember :: Member -> [J.Member]
toJavaMember mem = case mem of
    MField fld -> [J.MField $ toJavaField fld]
    MLineComment x -> [J.MLineComment x]
    MBlockComment x -> [J.MBlockComment x]
    _ -> error $ "Meta.IntCbp.toJavaMember: not implemented: " ++ show mem

toJavaField :: Field -> J.Field
toJavaField fld = J.mkField typ nam
    where
        typ = toJavaType $ fType fld
        nam = fName fld
