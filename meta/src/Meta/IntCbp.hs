module Meta.IntCbp where

import qualified Meta.File as F
import qualified Meta.Relat as R

-- * Type

data Type
    = TUnit -- ^ unit type
    | TNat8 -- ^ unsigned 8-bit integer
    | TInt8 -- ^ two's-complement 8-bit signed integer
    | TInt32 -- ^ two's-complement 32-bit integer
    | TInt64 -- ^ two's-complement 64-bit integer
    | TString -- ^ string (character sequence)
    | TArray Type Int -- ^ fixed-length array
    | TClass Class -- ^ aggregate
    | TPointer Type -- ^ pointer
    | TNullablePtr Type -- ^ nullable pointer
    deriving (Read, Show)

-- * Class

data Class
    -- | Internal. Do not use. Use 'defClass'.
    = MkClass {
        cPkg :: String -- ^ package
        , cName :: String -- ^ simple name (name without package)
        , cParents :: [Class]
        , cMembers :: [Member]
        , cAbstract :: Bool
    } deriving (Read, Show)

defClass :: Class
defClass = MkClass {
        cPkg = ""
        , cName = ""
        , cParents = []
        , cMembers = []
        , cAbstract = False
    }

-- * Class member

data Member
    = MField Field
    | MMethod Method
    | MLineComment String
    | MBlockComment String
    deriving (Read, Show)

data Field = MkField {
        fType :: Type
        , fName :: String
    } deriving (Read, Show)

data Method
    -- | Internal. Do not use. Use 'defMethod'.
    = MkMethod {
        mRet :: Type
        , mName :: String
        , mParams :: [Param]
        , mStatic :: Bool -- ^ true means has no implicit first parameter
        , mAbstract :: Bool -- ^ true means has no body
        , mVirtual :: Bool -- ^ true means overrideable; false means final
        , mOverride :: Bool -- ^ true means this method is expected to override an overrideable method in a parent
        , mBody :: [Sta]
    } deriving (Read, Show)

data Param = MkParam {
        pType :: Type
        , pName :: String
    } deriving (Read, Show)

defMethod :: Method
defMethod = MkMethod {
        mRet = TUnit
        , mName = ""
        , mParams = []
        , mStatic = False
        , mAbstract = False
        , mVirtual = False
        , mOverride = False
        , mBody = []
    }

-- * Statement

data Sta
    = SExp Exp -- ^ expression statement
    | SRet Exp -- ^ return statement
    | SDecl Type String -- ^ variable declaration statement
    | SAssign String Exp -- ^ assignment statement
    deriving (Read, Show)

-- * Expression

-- | Embedded lambda calculus.

data Exp
    = EConUnit
    | EConInt Integer
    | EConStr String
    | EConDbl Double
    | EPlus Exp Exp
    | EIf Exp Exp Exp -- ^ EIf condition truePart falsePart
    | EDot Exp Exp -- ^ dot (member access) expression
    | ECall Exp [Exp] -- ^ call expression
    deriving (Read, Show)

-- * Generate DTO (Data Transfer Object) class from relational database table

-- | Configuration for 'genDto'.
data GenDto
    -- | Internal. Do not use. Use 'defGenDto'
    = MkGenDto {
        gdCommentField :: Bool -- ^ Whether to comment every field.
    } deriving (Read, Show)

-- | Default configuration for 'genDto'.
defGenDto :: GenDto
defGenDto = MkGenDto {
        gdCommentField = False
    }

genDto :: GenDto -> R.Table -> Class
genDto conf table = defClass {
        cName = name
        , cMembers = [
            MLineComment $ " Generated by Meta.IntCbp.genDto from table \"" ++ name ++ "\"."
        ] ++ concatMap mapCol cols
    }
    where
        name = R.tName table
        cols = R.tCols table
        wantCommentField = gdCommentField conf
        mapCol :: R.Column -> [Member]
        mapCol col =
            if wantCommentField
                then [comment, field]
                else [field]
            where
                comment = MLineComment $ " Column \"" ++ name ++ "\" (" ++ show typ ++ ")."
                field = MField (MkField (mapType typ) name)
                typ = R.cType col
                name = R.cName col
                mapType :: R.Type -> Type
                mapType typ = case typ of
                    R.TInt32 -> TInt32
                    R.TInt64 -> TInt64
                    R.TVarChar _ -> TString
                    _ -> error $ "genDto.mapCol.mapType: not implemented: " ++ show typ

-- * Render to Java

renderJavaClass :: Class -> F.File
renderJavaClass cls = F.text path content
    where
        name = cName cls
        pkg = cPkg cls
        members = cMembers cls
        prefix = case pkg of
            "" -> ""
            _ -> map replace pkg ++ "/"
            where
                replace '.' = '/'
                replace x = x
        path = prefix ++ name ++ ".java"
        content =
            "public class " ++ name ++ " {\n"
            ++ (unlines $ map ("    " ++) $ map renderJavaMember $ members)
            ++ "}\n"

renderJavaType :: Type -> String
renderJavaType typ = case typ of
    TInt64 -> "long"
    TString -> "java.lang.String"
    _ -> error $ "renderJavaType: not implemented: " ++ show typ

-- | Internal. Do not use.
renderJavaMember :: Member -> String
renderJavaMember mem = case mem of
    MField (MkField typ nam) -> "public " ++ renderJavaType typ ++ " " ++ nam ++ ";"
    MLineComment s -> "//" ++ s;
    MBlockComment s -> "/*" ++ s ++ "*/";
    _ -> error $ "renderJavaMember: not implemented: " ++ show mem
