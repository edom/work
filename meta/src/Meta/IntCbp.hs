{-# LANGUAGE ApplicativeDo #-}

module Meta.IntCbp where

import qualified Meta.File as F
import qualified Meta.Java as J
import qualified Meta.JavaType as JT
import qualified Meta.Prop as P
import qualified Meta.Relat as R

import Meta.Prop ((|>))

-- * Type

data Type
    = TUnit -- ^ unit type
    | TNat8 -- ^ unsigned 8-bit integer
    | TInt8 -- ^ two's-complement 8-bit signed integer
    | TInt32 -- ^ two's-complement 32-bit integer
    | TInt64 -- ^ two's-complement 64-bit integer
    | TString -- ^ string (character sequence)
    | TArray Type Int -- ^ fixed-length array
    | TClass Class -- ^ aggregate
    | TPointer Type -- ^ pointer
    | TNullablePtr Type -- ^ nullable pointer
    deriving (Read, Show)

-- * Class

data Class
    -- | Internal. Do not use. Use 'defClass'.
    = MkClass {
        cPkg :: String -- ^ package
        , cName :: String -- ^ simple name (name without package)
        , cParents :: [Class]
        , cMembers :: [Member]
        , cAbstract :: Bool
    } deriving (Read, Show)

defClass :: Class
defClass = MkClass {
        cPkg = ""
        , cName = ""
        , cParents = []
        , cMembers = []
        , cAbstract = False
    }

-- * Class member

data Member
    = MField Field
    | MMethod Method
    | MProp Prop
    | MLineComment String
    | MBlockComment String
    deriving (Read, Show)

data Field = MkField {
        fType :: Type
        , fName :: String
    } deriving (Read, Show)

data Method
    -- | Internal. Do not use. Use 'defMethod'.
    = MkMethod {
        mRet :: Type
        , mName :: String
        , mParams :: [Param]
        , mStatic :: Bool -- ^ true means has no implicit first parameter
        , mAbstract :: Bool -- ^ true means has no body
        , mVirtual :: Bool -- ^ true means overrideable; false means final
        , mOverride :: Bool -- ^ true means this method is expected to override an overrideable method in a parent
        , mBody :: [Sta]
    } deriving (Read, Show)

data Prop
    = MkProp {
        prType :: Type -- ^ Internal. Do not use. Use 'P.getType' and 'P.setType'.
        , prName :: String -- ^ Internal. Do not use. Use 'P.getName' and 'P.setName'.
    } deriving (Read, Show)

instance P.GetName Prop String where getName = prName
instance P.SetName Prop String where setName n p = p { prName = n }
instance P.GetType Prop Type where getType = prType
instance P.SetType Prop Type where setType t p = p { prType = t }

data Param = MkParam {
        pType :: Type
        , pName :: String
    } deriving (Read, Show)

defMethod :: Method
defMethod = MkMethod {
        mRet = TUnit
        , mName = ""
        , mParams = []
        , mStatic = False
        , mAbstract = False
        , mVirtual = False
        , mOverride = False
        , mBody = []
    }

-- * Statement

data Sta
    = SExp Exp -- ^ expression statement
    | SRet Exp -- ^ return statement
    | SDecl Type String -- ^ variable declaration statement
    | SAssign String Exp -- ^ assignment statement
    deriving (Read, Show)

-- * Expression

-- | Embedded lambda calculus.

data Exp
    = EConUnit
    | EConInt Integer
    | EConStr String
    | EConDbl Double
    | EPlus Exp Exp
    | EIf Exp Exp Exp -- ^ EIf condition truePart falsePart
    | EDot Exp Exp -- ^ dot (member access) expression
    | ECall Exp [Exp] -- ^ call expression
    deriving (Read, Show)

-- * Generate DTO (Data Transfer Object) class from relational database table

-- | Configuration for 'genDto'.
data GenDto
    -- | Internal. Do not use. Use 'defGenDto'
    = MkGenDto {
        gdCommentField :: Bool -- ^ Whether to comment every field.
        , gdImmutable :: Bool -- ^ Whether to make every field const/final.
    } deriving (Read, Show)

-- | Default configuration for 'genDto'.
defGenDto :: GenDto
defGenDto = MkGenDto {
        gdCommentField = False
        , gdImmutable = False
    }

-- TODO generate getter methods
-- TODO generate setter methods
-- TODO generate 0-param constructor
-- TODO generate n-param constructor
-- TODO make every field private
genDto :: GenDto -> R.Table -> Class
genDto conf table = defClass {
        cName = name
        , cMembers = [
            MLineComment $ " Generated by Meta.IntCbp.genDto from table \"" ++ name ++ "\"."
        ] ++ concatMap mapCol cols
    }
    where
        name = R.tName table
        cols = R.tCols table
        wantCommentField = gdCommentField conf
        mapCol :: R.Column -> [Member]
        mapCol col =
            if wantCommentField
                then [comment, field]
                else [field]
            where
                comment = MLineComment $ " Column \"" ++ name ++ "\" (" ++ show typ ++ ")."
                field = MField (MkField (mapType typ) name)
                typ = R.cType col
                name = R.cName col
                mapType :: R.Type -> Type
                mapType typ = case typ of
                    R.TInt32 -> TInt32
                    R.TInt64 -> TInt64
                    R.TVarChar _ -> TString
                    _ -> error $ "genDto.mapCol.mapType: not implemented: " ++ show typ

-- * Transform to Java

toJavaType :: (P.AppliError f) => Type -> f JT.Type
toJavaType typ = case typ of
    TInt32 -> pure JT.Int32
    TInt64 -> pure JT.Int64
    TString -> pure JT.string
    _ -> P.raise ["Meta.IntCbp.javaType: not implemented: " ++ show typ]

toJavaClass :: (P.AppliError f) => Class -> f J.Class
toJavaClass cls = do
    mem <- sequenceA $ map toJavaMember $ cMembers cls
    pure (
            J.defClass { J.cPkg = pkg, J.cMembers = concat mem }
            |> P.setName name
        )
    where
        pkg = cPkg cls
        name = cName cls

toJavaMember :: (P.AppliError f) => Member -> f [J.Member]
toJavaMember mem = case mem of
    MField fld -> do
        jfld <- toJavaField fld
        pure [J.MField jfld]
    MLineComment x -> pure [J.MLineComment x]
    MBlockComment x -> pure [J.MBlockComment x]
    _ -> P.raise ["Meta.IntCbp.toJavaMember: not implemented: " ++ show mem]

toJavaField :: (P.AppliError f) => Field -> f J.Field
toJavaField fld = do
    typ <- toJavaType $ fType fld
    nam <- pure $ fName fld
    pure $ J.mkField typ nam
