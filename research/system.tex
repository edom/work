\chapter{Systems}

This chapter defines \emph{system}.
Later chapters discuss interesting systems.
We classify systems, hoping to gain some insight.
We can classify systems into two big classes:
\emph{time-dependent} (time-variant, temporal)
and \emph{time-independent} (time-invariant, atemporal).

\section{What is a system?}

We define a system as an input, a state, and an output.
The input is \(x\), the output is \(y\), and an equation relates them.
The state is implied by the equation.
Such equation can be written \(f~y~x = y\).
The equation can be quite arbitrary.
The terms \(f,x,y\) may appear on both sides of the equation.

\begin{m:def}[System]
A system is \((x,y,f)\) where \(y=f~y~x\).
\end{m:def}

An \emph{invariant} of a system is a property that stays
the same throughout the evolution of the system.

The behavior of a system is its output, especially the observable part of the output.

Composition

Continuous system

Discrete system

Finite system

An embedded system is a system in another system.
The outer system feeds the inner system's output back to the inner system's input,
possibly with some change.

Don't confuse this with embedded systems in computer engineering.

How do we measure system complexity?

\section{Ignoring degenerate feedback: feedforward}

Every function \(f\) is a special case of the general feedback equation \(f(x) = g(f,x)\)
where \(g\) is an identity function.
This suggests that feedforward is a degenerate case of feedback.
To simplify the writing, from this point on,
we always assume that a feedback is non-degenerate
unless written otherwise.

\section{Finding feedback: the inverse fixed point problem}

Given \(f\), find a \(g\) such that \(f(x) = g(f,x)\) and \(g\) is not an identity function.

The forward fixed point problem:
Given \(f\), find an \(x\) such that \(x=f(x)\).

The inverse fixed point problem is
``Given \( x \), find an \( f \) such that \( x = f(x) \) and \(f\) is not an identity function.''
This problem arises when we want to determine
if \(f\) has a feedback.

Example of non-feedback: linear functions.
Consider a function of the form \(f(x) = a \cdot x + b\) where \(a\) and \(b\) are non-zero constants.
The only \(g\) that satisfies \(g(f) = f\) is the identity function \(g(x)=x\).

Example of feedback: functional equation.
Consider a function of the form \(f(x) = x \cdot f(x-1)\).

Recursive functions are special cases of feedback.
Searching in list.
\(f(N,e) = 0\).
\(f(C,h,t,e) = h \equiv e \vee f(t,e)\).
\(g\) is the Y-combinator.

We have a problem: there are infinitely many wildly discontinuous functions satisfying that.
We want smooth functions.

\section{Feedback based on differentiability-preserving map}

We want a map that preserves differentiability.
Formally, given \(f=g(f)\), we want \(g\) to have the property
that iff \(f\) is differentiable then \(g(f)\) is also differentiable.
Surely if \(f\) is differentiable and \(g\) is differentiable then \(g(f)\) is also differentiable?
Surely if \(f\) is differentiable \(g\) is a polynomial then \(g(f)\) is differentiable?

We begin with the generalized differential on a field:
\( g~(f+h) = g~f + h \cdot d~g~f \)
where \( (f + g)~x = f~x + g~x \) and \( (f \cdot g)~x = f~x \cdot g~x \).
Thus \( h \cdot d~g~f = g~(f+h) - g~f \).
This is like computing the gradient of a vector function,
but the vector is infinite-dimensional.

Is it time to learn topology? Smooth manifolds?

\section{Measuring feedback}

Given a system \( f(x) = g(f,x) \),
we're interested in measuring how much feedback it has.

Assume that \(f\) is a vector.
We can measure the feedback by measuring \( d_f ~ g \):
the differential of \(g\) with respect to \(f\).
Using non-standard analysis, we define the gradient \( d f \)
as something satisfying \( f(x + h) = f(x) + h \cdot (d f)(x) \)
where \(h\) is an infinitesimal.

\section{Linear feedback and function classes}

If \(f\) is linear and \(g\) is linear, then \(f \circ g\) is linear.
A linear feedback does not add anything interesting to a linear function.

\section{Temporal systems}

A temporal system, a time-dependent system, or a time-variant system is a system that depends on time.
With time, we can define more interesting systems.

\begin{m:def}[Temporal system]
    A temporal system is a function whose type is \((T \to X) \to T \to Y\).
\[
    \SysTmp~T~X~Y = (T \to X) \to (T \to Y)
\]
\end{m:def}

We can see a temporal system as a transformation of time functions.
\((T \to X) \to (T \to Y)\).

Example:
\(f~x~t = (x~t)^2\).

Example:
\[f~x~t = x~t + \int_0^t (s - f~x~t) \cdot dt\].

%wrong
\begin{m:def}[Temporal system]
    A temporal system is \((x,y,f,T)\) that satisfies
    \(\forall t \in T : f~y~x~t\).
\end{m:def}

\section{First-order system}

The previous section talks about second-order system.

This is a first-order system:
\(\SysTmp~T~X~Y = X \to T \to Y \).

\(\SysTmp~T~X~Y = T \to X \to Y \).

There are two points of view: \(d_x~f\) and \(d_t~f\).

First-order system should be more analyzable.

Continuous-time and discrete-time system?

In the above definition, \(T\) is the time type.
If \(T = \R\) we call the system continuous-time.
If \(T = \N\) we call the system discrete-time.

\section{Chaining temporal systems}

We can feed the output temporal system \(f\)
to the input of the temporal system \(g\)
this produces the temporal system \(h\) where
\(h~x~t = g~(f~x)~t\),
or \(h~x = g~(f~x)\) after eta-conversion,
or \(h = g \circ f\).
It turns out that system composition is just plain function composition.

\section{Stateless and stateful systems}

A system is stateless iff the same input always gives the same output.
There is no way to tell apart a system that has state
but doesn't use it and a system that really has no state.

\begin{m:def}[Stateless system]
    A stateless system is a temporal system that satisfies \(\forall t : \forall u: x~t = x~u \implies y~t = y~u\).
\end{m:def}

In a stateful system, the same input can give different outputs, depending on time.

Why do we define those?

\section{Property}

If \(p\) is a predicate that is always true for a system,
then \(p\) is a property of that system.
\( \SysTmp~T~X~Y \to \{0,1\} \)

\section{Constraint}

A constraint of \(S\) is a property of \(S\) that is always true.

\section{Parameter/family}

Parameterized system.

\( P \to \SysTmp~T~X~Y \)

System parameter.

Family of systems.

Indexed family of systems.

\section{Measure}

Categorical inverse of parameter. (Whatever categorical inverse means.)

From type theory point of view, parametrization is the inverse of measurement.

\( \SysTmp~T~X~Y \to M \)

\section{Temporal measure}

\( m : \SysTmp~T~X~Y \to (T \to M) \)

Find \(s\) that minimizes \(m~s~t\) as \(t\) grows.

\section{System space}

Like function space.
Metric space.

\section{System endofunction}

\( \SysTmp~T~X~Y \to \SysTmp~T~X~Y \).

\section{Output-input gradient}

\( f : \SysTmp~T~X~Y \)

\( f~(x+h) - f~x = h \cdot d~f~x \) but \(h\) is a function.

\(m\)-adaptivity

\( (m~f~(x+h) - m~f~x) / h \)

Reversal:
\( \SysTmp~T~X~Y \to \SysTmp~T~Y~X \)

Time-reversible/Time-symmetric:
\( f~x~t = f~x~(-t) \)

\section{Minimand}

The minimand is the thing that is to be minimized.
It's an English word.
The minimand of a temporal system is a function that is minimized as time goes by.

Recall that a temporal system has type \((T \to X) \to T \to Y\).
A minimand is a function that has type \((T \to X) \to T \to M\).

\begin{m:def}[A minimand of a temporal system]
    The function \(g\) is a minimand of a temporal system \(s\) iff \(g~s~t \xrightarrow[t \to \infty]{} 0\).
\end{m:def}

There's always a trivial minimand: \(g~s~t = 0\).

Does every system have a non-trivial minimand?

\section{Constrained system}

Constrained system: a system whose equation is subject to constraints (which can be inequalities).
Every system is constrained; the definition requires it. So why bother defining this?

\section{Optimizing system}

A system is \emph{optimizing} iff it optimizes a function.
We call this function a \emph{goal function}.
The purpose of the system is to minimize the goal function.

A goal is something that a system wants to reach.
This implies that the definition of goal involves time.
The goal function is usually hidden.

\section{Purposeful system}

We also call a purposeful system an optimizing system.

\emph{Purpose requires time.}

Let \(x\) be a function of time.
Let the equation \(f~x~t = y\) govern the system.
Let \(g~x\) be a function of time.
The system is \emph{purposeful} iff \(g~x~t\) approaches zero as \(t\) grows,
for some non-trivial \(g\).
We say that \(g\) is a \emph{purpose} or a \emph{goal} of the system.
The goal function may represent the sensed error
with respect to a setpoint.

A purposeful system doesn't have to be adaptive.
A simple thermostat is purposeful but not adaptive.

\section{How do we measure how well a system serves its purpose?}

is like measuring the rate of convergence of an approximation scheme.

\section{What is an intelligent system?}

Stable system:
See stability theory.
Lyapunov.

How do we measure how adaptive a system is?

An adaptive system is a system that adapts.

Adaptation implies change.

Adapt means ``fit, adjust''.
% http://www.dictionary.com/browse/adapt

% https://en.wikipedia.org/wiki/Adaptive_system
% http://link.springer.com/article/10.1007%2Fs11047-008-9096-6
% Adaptation, anticipation and rationality in natural and artificial systems: computational paradigms mimicking nature

Adaptive with respect to what?

Chaotic system:
Small change in input causes large change in output.
See chaos theory.
